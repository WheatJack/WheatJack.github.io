<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://WheatJack.github.io</id>
    <title>JackJack</title>
    <updated>2024-01-25T03:48:49.722Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://WheatJack.github.io"/>
    <link rel="self" href="https://WheatJack.github.io/atom.xml"/>
    <subtitle>记录自己的生活</subtitle>
    <logo>https://WheatJack.github.io/images/avatar.png</logo>
    <icon>https://WheatJack.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, JackJack</rights>
    <entry>
        <title type="html"><![CDATA[Mac设置多个JDK版本]]></title>
        <id>https://WheatJack.github.io/post/mac-she-zhi-duo-ge-jdk-ban-ben/</id>
        <link href="https://WheatJack.github.io/post/mac-she-zhi-duo-ge-jdk-ban-ben/">
        </link>
        <updated>2024-01-25T03:18:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>去Oracle下载多个需要的版本,并一步步next安装</p>
<blockquote>
<p>https://www.oracle.com/cn/java/technologies/downloads/</p>
</blockquote>
</li>
<li>
<p>编辑bash_profile文件</p>
<blockquote>
<pre><code class="language-shell">vi ~/.bash_profile
</code></pre>
<p>新增配置：</p>
<pre><code class="language-shell"># 设置 jdk1.8
 
export JAVA_8_HOME='$(/usr/libexec/java_home -v 1.8)'
 
# 设置 jdk17
 
export JAVA_17_HOME='$(/usr/libexec/java_home -v 17)'
 
# 默认 jdk 使用1.8版本
 
JAVA_HOME=$JAVA_8_HOME
 
PATH=$JAVA_HOME/bin:$PATH
 
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
 
  export JAVA_HOME PATH CLASSPATH
  
  alias jdk11=&quot;export JAVA_HOME=$JAVA_11_HOME&quot; 
 
alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;
</code></pre>
<p>刷新配置</p>
<pre><code class="language-shell">source ～/.bash_profile
</code></pre>
</blockquote>
</li>
<li>
<p>编辑 /etc/profile 文件</p>
<blockquote>
<pre><code class="language-shell">vi /etc/profile
</code></pre>
<p>增加配置</p>
<pre><code> alias jdk11=&quot;export JAVA_HOME=$JAVA_11_HOME&quot; 
 
alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;
</code></pre>
<p>刷新配置</p>
<pre><code>source /etc/profile
</code></pre>
</blockquote>
</li>
<li>
<p>验证</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://WheatJack.github.io/post-images/1706153997556.png" alt="验证图片" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql 基础篇]]></title>
        <id>https://WheatJack.github.io/post/mysql-ji-chu-pian/</id>
        <link href="https://WheatJack.github.io/post/mysql-ji-chu-pian/">
        </link>
        <updated>2022-02-27T07:39:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mysql学习">MYSQL学习</h1>
<blockquote>
<p>开始学习mysql了，奥力给⛽️⛽️</p>
</blockquote>
<h1 id="一-基础学习">一、基础学习</h1>
<h2 id="1-通用语法及分类">1、通用语法及分类</h2>
<h3 id="sql分类">SQL分类</h3>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzjxc4b8mmj20m00663z3.jpg" alt="image-20220220134319454" loading="lazy"></figure>
<h4 id="ddl语句">DDL语句</h4>
<h5 id="数据库操作-crud">数据库操作-CRUD</h5>
<pre><code class="language-mysql">// 查询所有数据库
show Database;
// 查询当前数据库
select database();
// 创建数据库
Create database [if not exists] 数据库名 [default charset utf8mb4][collate 排序规则];
// 删除数据库
drop database  if exists test_database;
// 使用数据库
use test_database;

</code></pre>
<h5 id="表操作-查询">表操作-查询</h5>
<pre><code class="language-mysql">// 查询数据库所有的表
show tables;
// 查询所有表的状态
show table status;
// 查询表结构
desc table_name;
// 查询指定表的建表语句
show create table table_name;
</code></pre>
<h5 id="表操作-创建">表操作-创建</h5>
<pre><code class="language-mysql">// 创建表--结构
CREATE TABLE table_name (
'id' varchar(50) [comment 注释],
'id' varchar(50) [comment 注释],
'id' varchar(50) [comment 注释],
)[comment 表注释];

// 创建表
CREATE TABLE `employ` (
  `id` varchar(50) NOT NULL COMMENT '主健id',
  `name` varchar(5) DEFAULT NULL COMMENT 'name',
  `time` datetime DEFAULT NULL COMMENT '创建时间',
  `age` int DEFAULT NULL COMMENT '年纪',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表';
</code></pre>
<h5 id="表数据类型及案例">表数据类型及案例</h5>
<h6 id="数值类型"><strong>数值类型</strong></h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1  byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2  bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3  bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4  bytes</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8  bytes</td>
<td>(-2<sup>63，2</sup>63-1)</td>
<td>(0，2^64-1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4  bytes</td>
<td>(-3.402823466 E+38，3.402823466351  E+38)</td>
<td>0 和 (1.175494351  E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8  bytes</td>
<td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>
<td>0 和  (2.2250738585072014 E-308，1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody>
</table>
<h6 id="字符串类型">字符串类型</h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">explain</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char(10)  -----------&gt; 性能好</td>
<td>用户名 username   varchar(50)</td>
</tr>
<tr>
<td style="text-align:left">varchar(10)  ---------&gt; 性能较差</td>
<td>性别 gender   char(1)</td>
</tr>
</tbody>
</table>
<h6 id="时间类型"><strong>时间类型</strong></h6>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至  9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至  838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h5 id="表结构-修改">表结构-修改</h5>
<pre><code class="language-mysql">// 新增字段
alter table table_name add 字段 类型(长度) [comment 注释] [约束];
// 只修改数据类型
alter table table_name modify 字段 类型(长度) [comment 注释] [约束];
// 修改字段名和字段类型
Alter table table_name change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];
// 删除字段
alter table table_name drop 字段名;
// 修改表名
alter table table_name rename to new_table_name;
// 删除表
drop table if exists table_name;
// 删除(截断)指定表 并重新创建该表
truncate table table_name;
</code></pre>
<h4 id="dml语句">DML语句</h4>
<h5 id="添加数据">添加数据</h5>
<pre><code class="language-mysql">// 给指定字段添加数据
insert into table_name (字段1,字段2) values (值1,值2......);
// 给全部字段添加数据
insert into table_name values (值1,值2......);
// 批量添加数据
insert into table_name (字段1,字段2) values (值1,值2......),(值1,值2......),(值1,值2......);
insert into table_name values (值1,值2......),(值1,值2......),(值1,值2......);
// 从别的表取数 插入到这个表
insert into table_name select * from table_name2;
</code></pre>
<p>Notes：</p>
<ul>
<li>插入数据时，指定的字段顺序需要与值的顺序一一对应的</li>
<li><strong>字符串和日期类型应该包含在引号中</strong></li>
<li>插入的数据大小 应该在字段的规定范围内</li>
</ul>
<h5 id="修改数据">修改数据</h5>
<pre><code class="language-mysql">// 更新数据
update table_name set 字段1=值1,字段2=值2	.... [where 条件];
// 删除数据
delete from table_name  [where 条件];
</code></pre>
<h4 id="dql语句">DQL语句</h4>
<pre><code class="language-mysql">// 结构
select 
	字段列表 
from 
	table_name 
where 条件列表 
group by 分组字段列表 
having 分组后条件查询 
order by 排序字段列表 
limit 分页参数 ;
</code></pre>
<p><strong>查询学习：</strong></p>
<ul>
<li>基本查询</li>
<li>条件查询 where</li>
<li>聚合函数 （count、max、min、avg、sum）</li>
<li>分组查询 group by</li>
<li>排序查询 order by</li>
<li>分页查询 limit</li>
</ul>
<h5 id="基本查询">基本查询</h5>
<pre><code class="language-mysql">// 查询全部
select * from table_name;
// 设置字段别名  as 可以省略
select name as userName from table_name;
// 去除重复 distinct
select distinct name from table_name;

</code></pre>
<h5 id="条件查询">条件查询</h5>
<pre><code class="language-mysql">select * from table_name where 条件列表;
// 查询名字为两个字的员工信息---使用like 或者使用length
select * from emp where name like '__';
</code></pre>
<p><strong>条件列表：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk0fhu4bij20ed08qgm2.jpg" alt="image-20220220153026880" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk0fv6c9kj20do03u0st.jpg" alt="image-20220220153048518" loading="lazy"></figure>
<hr>
<h5 id="聚合函数">聚合函数</h5>
<blockquote>
<p>将<strong>一列</strong>数据作为一个整体，进行纵向计算</p>
<p><strong>所有的null值是不参与聚合函数的</strong></p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk0mip1bgj20f204wjrf.jpg" alt="image-20220220153712548" loading="lazy"></figure>
<pre><code class="language-mysql">// 语法
select max(age) from table_name;
</code></pre>
<hr>
<h5 id="分组查询">分组查询</h5>
<pre><code class="language-mysql">// 语法
select 字段列表 from table_name where 条件  group by 分组字段名 having  分组过滤条件;
</code></pre>
<p><strong>WHERE与HAVING的区别：</strong></p>
<ul>
<li>执行时机不同：<strong>where 是分组之前</strong>进行过滤的 不满足where条件 不参与分组；<strong>having是分组之后</strong>对结果进行过滤</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ul>
<p><strong>Notes：</strong></p>
<ul>
<li>执行顺序：where&gt;聚合函数&gt;having</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li>
</ul>
<hr>
<h5 id="排序查询">排序查询</h5>
<pre><code class="language-mysql">// 语法  默认asc  
Select 字段列表 from table_name  order by 字段1 asc,字段2 desc;
</code></pre>
<hr>
<h5 id="分页查询">分页查询</h5>
<pre><code class="language-mysql">// 语法
select * from table_name limit 起始索引,查询记录数;

</code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>起始索引 从0开始 起始索引= 查询页码-1  * 每页显示的条数</li>
<li>分页查询是数据库的方言，不同的数据库有不同的实现 Mysql是Limit</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</li>
</ul>
<hr>
<h5 id="执行顺序">执行顺序</h5>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzk99ryqehj20t80crwfo.jpg" alt="image-20220220203618076" loading="lazy"></figure>
<hr>
<h4 id="dcl语句">DCL语句</h4>
<blockquote>
<p>Data Control Language ，用来管理数据库用户、控制数据库的访问权限等等</p>
</blockquote>
<h5 id="基础crud">基础CRUD</h5>
<pre><code class="language-mysql">// 使用mysql 库
use mysql;
// 查询用户
select * from user;

// 创建用户 test_user
create user 'test_user'@'主机名：localhost' identified  by '123456';

// 修改用户密码
alter user 'test_user 用户名'@'主机名: localhost' identified  with mysql_native_password By '新密码';

// 删除用户
drop user 'test_user 用户名'@'主机名: localhost';
</code></pre>
<hr>
<h5 id="权限控制">权限控制</h5>
<p>权限列表</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzkbahykr6j20t409xwf0.jpg" alt="image-20220220214614372" loading="lazy"></figure>
<pre><code class="language-mysql">// 查询权限
SHOW GRANTS FOR 'root'@'%';

// 授予权限 如果授予所有的 就使用*.*
GRANTS 权限列表 ON 数据库.表名 TO '用户名：test_user'@'主机名：localhost';
grant all on *.* to 'test_user'@'localhost';

//撤销权限
REVOKE 权限列表 ON 数据库.表名 FROM '用户名：test_user'@'主机名：localhost';
REVOKE all ON *.* FROM 'test_user'@'localhost';

</code></pre>
<h3 id="2-函数">2、函数</h3>
<blockquote>
<p>可以直接被调用的程序或代码</p>
</blockquote>
<h4 id="字符串函数">字符串函数</h4>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzkburecjrj20t80aewfq.jpg" alt="image-20220220220543391" loading="lazy"></figure>
<pre><code class="language-mysql">// 字符串拼接
select concat('aaaa', name) from employ where id = 1;
select concat('hello', 'world');
// 转大小写
select lower('hello');
select upper('hello');
// 左右填充
select  lpad('aaa',10,'___');
select  rpad('aaa',10,'___');
// 去掉空格
select  trim(' hello world  ');
// 截取字符串
select  substr('11aaaaaa',1,5);
</code></pre>
<p><strong>案例：使得员工编号小于5位的前面自动补0，例如 1变成00001；</strong></p>
<pre><code class="language-mysql">update employ set  id = lpad(id,5,'0');
</code></pre>
<hr>
<h4 id="数值函数">数值函数</h4>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznrhydzjlj20ri07fwex.jpg" alt="image-20220223212333518" loading="lazy"></figure>
<pre><code class="language-mysql">// 向上取整 --13
select ceil(12.1);
// 向下取整  --1
select floor(1.1);
//返回x/y的模 --20
select mod(20,100);
// 返回0-1的随机数
select rand();
// 参数x的四舍五入，保留指定小数 ----1.2222
select round(1.222222,4);
</code></pre>
<p><strong>生成6位随机数</strong></p>
<pre><code class="language-mysql">select lpad(round((select rand()*1000000),0),6,'0');
</code></pre>
<hr>
<h4 id="日期函数">日期函数</h4>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznrtp75f4j20rr0bbmy7.jpg" alt="image-20220223213455206" loading="lazy"></figure>
<pre><code class="language-mysql">-- 当前日期  2022-03-15
select curdate();
-- 当前时间  21:04:07
select curtime();
-- 当前日期和时间2022-03-15 21:04:32
select now();
// 获取data的年份
select year(now());
// 获取data的月份
select month(now());
// 获取data的日份
select day(now());
// 是时间相加
select date_add(now(),INTERVAL 100 YEAR );
select date_add(now(),INTERVAL 100 day );
select date_add(now(),INTERVAL 100 month );
// 时间差
select datediff(now(),now());
</code></pre>
<hr>
<h4 id="流程函数">流程函数</h4>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzns458rvyj20rs06pq3n.jpg" alt="image-20220223214454850" loading="lazy"></figure>
<pre><code class="language-mysql">-- IFNULL
select ifnull('',111);
select ifnull('2222',111);
select ifnull(null,'22');
-- IF
select if(true,'1','0');
-- CASE WHEN
select name, (case age when 10 then '10岁' when 11 then '11岁' else '不是这个年纪' end) as age
from employ;

</code></pre>
<hr>
<h3 id="3-约束">3、约束</h3>
<blockquote>
<p><strong>作用于表中字段上的规则，用于限制存储在表中的数据</strong></p>
</blockquote>
<h4 id="概述">概述</h4>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznsitdjlgj20ok081q3y.jpg" alt="image-20220223215903635" loading="lazy"></figure>
<p>Notes：</p>
<p><strong>约束是作用于表字段上的，可以在创建表/修改表的时候添加约束</strong></p>
<h4 id="约束演示">约束演示</h4>
<p>id 主键、自动增长</p>
<p>name 不为空 唯一</p>
<p>age &gt;0 小于等于120</p>
<p>status 如果没有指定值，默认为1</p>
<pre><code class="language-mysql">CREATE TABLE `table_user` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(10) NOT NULL COMMENT 'name',
  `age` int DEFAULT NULL COMMENT '年纪',
  `status` char(1) DEFAULT '1' COMMENT 'status',
  `gender` char(1) NOT NULL COMMENT 'gender',
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  CONSTRAINT `table_user_chk_1` CHECK (((`age` &gt; (0 &amp; `age`)) &lt;= 120))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表';
</code></pre>
<h4 id="外键约束">外键约束</h4>
<blockquote>
<p>目前不在使用强关联物理外键约束</p>
</blockquote>
<pre><code class="language-mssql">-- 添加外键
alter table  employ add constraint  foreign_key_id foreign key (id) references table_user(id);
-- 删除外键
alter table  employ drop foreign key  foreign_key_id;
</code></pre>
<h5 id="删除更新行为">删除/更新行为</h5>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznti7j9hyj20sr06x3zs.jpg" alt="image-20220223223305281" loading="lazy"></figure>
<h3 id="4-多表查询">4、多表查询</h3>
<h4 id="多表关系">多表关系</h4>
<p><em>关系分为：</em></p>
<ul>
<li>一对一**（单表拆分，在任意一方加入外键盘，关联另一方的外键，并设置外键为unique）**</li>
<li>一对多</li>
<li>多对多**（需要中间表维护关系）**</li>
</ul>
<h4 id="多表查询概述">多表查询概述</h4>
<pre><code class="language-mysql">-- 两个表关联 隐式内连接 形成笛卡尔积
select * from employ,table_user;
</code></pre>
<hr>
<h4 id="内连接">内连接</h4>
<blockquote>
<p><strong>查询AB交集的部分数据</strong></p>
</blockquote>
<h5 id="隐式内连接">隐式内连接</h5>
<pre><code class="language-mysql">select * from employ e,gift_history g where e.id =g.id;
</code></pre>
<h5 id="显式内连接">显式内连接</h5>
<pre><code class="language-mysql">select * from employ e inner join  gift_history g on  e.id =g.id;
</code></pre>
<hr>
<h4 id="外连接">外连接</h4>
<h5 id="左外连接">左外连接</h5>
<blockquote>
<p><strong>查询左表所有数据，以及两张表交集部分数据</strong></p>
</blockquote>
<pre><code class="language-mysql">select * from employ  e left join table_user P on e.id = P.id where e.name is not null ;
</code></pre>
<h5 id="右外连接">右外连接</h5>
<blockquote>
<p><strong>查询右表所有数据，以及两张表交集部分数据</strong></p>
</blockquote>
<pre><code class="language-mysql">select * from employ  e right outer join  table_user P on e.id = P.id where e.name is not null ;
</code></pre>
<h4 id="自连接">自连接</h4>
<blockquote>
<p><strong>自己与自己关联查询</strong></p>
</blockquote>
<pre><code class="language-mysql">-- 显示自连接
select * from employ  e1 join employ e2 on e1.id = e2.id;
-- 隐式自连接
select * from employ  e1 , employ e2 on e1.id = e2.id;
</code></pre>
<p>业务场景：比如员工表，需要查询员工的上级领导是谁，那么就自连接，根据自己的manager_id 等于自己表的id ，那么就可以查询对应的信息出来</p>
<p>Notes：自连接查询，可以是内连接查询，也可以是外连接查询</p>
<hr>
<h4 id="联合查询">联合查询</h4>
<blockquote>
<p><strong>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</strong></p>
</blockquote>
<p>union，union all</p>
<p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p>
<pre><code class="language-mysql">select * from employ where age&gt;10
union
select * from employ where age&lt;10
union
select a.id,a.age,a.name,a.status
from table_user a where a.id&gt;1;
</code></pre>
<p>Notes：</p>
<ul>
<li>对于联合查询的多张表的数据必须保持一致，字段类型也需要保持一致</li>
<li>union all 会将全部的数据直接合并在一起**（不做任何操作）**，<strong>union会对合并之后的数据去重、排序</strong></li>
</ul>
<hr>
<h4 id="子查询">子查询</h4>
<blockquote>
<p>sql中嵌套select语句</p>
</blockquote>
<pre><code class="language-mysql">select * from table_name where column =(select id form table_name2 where ....);
</code></pre>
<h5 id="标量子查询">标量子查询</h5>
<p>查询结果为单个值 ---一种条件 确定</p>
<pre><code class="language-mysql">select * from employ where id &gt; (select id from employ where age ='11');
</code></pre>
<h5 id="列子查询">列子查询</h5>
<p>查询结果为一列--- in、not in</p>
<pre><code class="language-mysql">select * from employ where id in (select id from employ where age &gt;1);
-- all 用法 满足查询出来的所有条件
select * from employ where id &gt; all (select id from employ where age ='1');
-- some 用法 满足查询出来的其中一个条件
select * from employ where id &gt; some (select id from employ where age ='1');
</code></pre>
<h5 id="行子查询">行子查询</h5>
<p>查询结果为一行</p>
<pre><code class="language-mysql">-- 新语法🐮🍺
select * from employ where  (name,age)!=(select name,age from employ where id =00011);

</code></pre>
<h5 id="表子查询">表子查询</h5>
<p>查询结果为多行多列</p>
<pre><code class="language-mysql">-- 多条件in 🐮🍺
select * from employ where  (name,age) in(select name,age from employ where id is not null);
-- 子查询当一个表
select * from (select * from employ where time&lt;now()) as a;
</code></pre>
<hr>
<h3 id="5-事务">5、事务</h3>
<h4 id="事务简介">事务简介</h4>
<blockquote>
<p>要么全部成功，要么全部失败，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求</p>
</blockquote>
<p>默认mysql的事务是自动提交的，也就是说，<strong>当执行一条dml语句，mysql会立即隐式的提交事务</strong></p>
<h4 id="事务操作">事务操作</h4>
<pre><code class="language-mysql">-- 银行转账例子
-- 查看当前事务是否自动提交  1就是自动提交  基于session级别
select @@autocommit;
-- 设置为手动提交
set @@autocommit = 0;
-- 开启事务
start transaction 或者 begin;

-- 开始处理业务逻辑
update account set money = money-1000 where name = 'Jack';
update account set money = money+1000 where name = 'Tony';
-- 提交操作
commit;
-- 异常回滚操作
rollback;

</code></pre>
<h4 id="事务四大特性acid">事务四大特性（ACID）</h4>
<p><strong>原子性（atomicity）</strong>：事务是不可分割的最小单元，要么全部成功，要么全部失败。</p>
<p><strong>一致性（consistency）</strong>：事务完成时，必须使所有的数据都保持一致状态</p>
<p><strong>隔离性（isolation）</strong>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p>
<p><strong>持久性（durability）</strong>：事务一旦提交或回滚，它对数据库中的操作的改变时永久的</p>
<hr>
<h4 id="并发事务问题">并发事务问题🌟</h4>
<ul>
<li><strong>脏读</strong>：一个事务读到另外一个事务还没提交的数据</li>
<li><strong>不可重复读</strong>：一个事务先后读取同一条记录，但是两次读取到数据不同，称之为不可重复读</li>
<li><strong>幻读</strong>：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻觉</li>
</ul>
<h4 id="事务隔离级别">事务隔离级别🌟</h4>
<p>各个级别会出现的情况：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read uncommitted</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Read committed</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><strong>Repeatable Read（默认）</strong></td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">-- 查看事务隔离级别
select @@transaction_isolation;

-- 设置事务隔离级别
set session  transaction isolation level read uncommitted ;
set session  transaction isolation level read committed ;
set session  transaction isolation level repeatable read ;
set session  transaction isolation level serializable ;
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JUC学习呀]]></title>
        <id>https://WheatJack.github.io/post/juc-xue-xi-ya/</id>
        <link href="https://WheatJack.github.io/post/juc-xue-xi-ya/">
        </link>
        <updated>2022-01-17T14:21:30.000Z</updated>
        <content type="html"><![CDATA[<ol start="2">
<li>进程与线程</li>
</ol>
<p>2.1 进程与线程</p>
<p>进程</p>
<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的</p>
<p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
<p>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程(例如网易云音乐、360安全卫士等)</p>
<p>线程</p>
<p>一个进程之内可以分为一到多个线程。</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行<br>
Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器</p>
<p>二者对比</p>
<p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>
进程拥有共享的资源，如内存空间等，供其内部的线程共享<br>
进程间通信较为复杂</p>
<p>同一台计算机的进程通信称为IPC(Inter-process communication)<br>
不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP<br>
线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>
线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
<p>2.2 并发和并行</p>
<p>单核cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15毫秒)分给不同的线程们使用，只是由于cpu在线程间(时间片很短)的切换非常快，人类感觉是同时运行的。总结为一句话就是:微观串行，宏观并行</p>
<p>一般会将这种 线程轮流使用 CPU的做法称为并发 concurrent</p>
<p>引用RobPike的一段描述：</p>
<p>并发（concurrent）是同一时间应对（dealing with）多件事情的能力。</p>
<p>并行（parallel）是同一时间动手做（doing）多件事情的能力</p>
<p>2.3 应用</p>
<p>应用之异步调用（案例1）</p>
<p>从方法调用的角度来讲，如果</p>
<p>需要等待结果返回，才能继续运行就是同步。</p>
<p>不需要等待结果返回，就能继续运行就是异步</p>
<p>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致</p>
<p>1）设计</p>
<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停..</p>
<p>2）结论</p>
<p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</p>
<p>tomcat的异步servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞tomcat的工作线程■ui程序中，开线程进行其他操作，避免阻塞ui线程</p>
<p>3）总结</p>
<p>代码见【应用之效率-案例1】<br>
1.单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活<br>
2.多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的，</p>
<p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）。</p>
<p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p>
<p>3.IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞I0】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞I0】和【异步IO】优化</p>
<p>3.Java线程创建</p>
<p>3.1 创建和运行线程</p>
<p>方法一：直接使用Thread</p>
<pre><code>public static void main(String[] args) {
</code></pre>
<p>​<br>
new Thread(() -&gt; {<br>
log.debug(&quot;aaa&quot;);<br>
}, &quot;aa&quot;).start();<br>
log.debug(&quot;bbb&quot;);<br>
}<br>
方法二：使用runnable</p>
<p>public static void main(String[] args) {<br>
​<br>
Runnable runnable = new Runnable() {<br>
@Override<br>
public void run() {<br>
log.debug(&quot;runnable&quot;);<br>
}<br>
};<br>
​<br>
Thread aa = new Thread(runnable, &quot;runnable&quot;);<br>
aa.start();<br>
log.debug(&quot;bbb&quot;);<br>
}<br>
原理之Thread与Runnable的关系</p>
<p>分析Thread的源码，理清它与Runnable的关系</p>
<p>小结</p>
<p>方法1是把线程和任务合并在了一起，方法2是把线程和任务分开了</p>
<p>用Runnable更容易与线程池等高级API配合</p>
<p>用Runnable让任务类脱离了Thread继承体系，更灵活</p>
<p>方法三：使用futureTask创建</p>
<pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {

    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() {
        @Override
        public Integer call() throws Exception {
            log.debug(Thread.currentThread().getName() + &quot;线程输出:&quot; + &quot;Thread1Callable&quot;);
            Thread.sleep(1000);
            return 200;
        }
    });

    Thread aa = new Thread(futureTask, &quot;futureTask&quot;);

    aa.start();
    // 阻塞等待线程结果
    Integer integer = futureTask.get();
    log.debug(&quot;线程返回结果：{}&quot;, integer);
    log.debug(Thread.currentThread().getName() + &quot;线程输出:&quot; + &quot;bbb&quot;);
}
</code></pre>
<p>3.2 查看进程的方法</p>
<p>windows</p>
<p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p>
<p>tasklist查看进程</p>
<p>taskkill杀死进程</p>
<p>linux</p>
<p>ps-fe查看所有进程</p>
<p>ps-fT-p《PID》查看某个进程（PID）的所有线程</p>
<p>kill杀死进程</p>
<p>top按大写H切换是否显示线程</p>
<p>top -H -p《PID》查看某个进程（PID）的所有线程</p>
<p>Java</p>
<p>■ps命令查看所有Java进程</p>
<p>jstack 《PID》查看某个Java进程（PID）的所有线程状态</p>
<p>jconsole来查看某个Java进程中线程的运行情况（图形界面）</p>
<p>jconsole远程监控配置<br>
。需要以如下方式运行你的java类<br>
java -Djava.rmi.server.hostname=~ip地址-Dcom.sun.management.jmxremote-<br>
Dcom.sun.management.jmxremote.port='连接端口-Dcom.sun.management.jmxremote.ssl=是否安全连接-Dcom.sun.management.jmxremote.authenticate=是否认证java类<br>
■修改/etc/hosts文件将127.0.0.1映射至主机名<br>
如果要认证访问，还需要做如下步骤<br>
■复制jmxremote.password文件<br>
■修改jmxremote.password和jmxremote.access文件的权限为600即文件所有者可读写■连接时填入controlRole（用户名），R&amp;D（密码）</p>
<p>3.3 线程运行原理</p>
<p>栈与栈帧</p>
<p>Java Virtual Machine Stacks （Java虚拟机栈）</p>
<p>我们都知道JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存，每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存■每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
<p>栈帧是相互独立的，每个线程有自己的栈帧。</p>
<p>单线程栈帧演示</p>
<p>每次新的线程起来，就会入栈，使用完毕后就出栈。</p>
<p>image-20210725113349782</p>
<p>image-20210725114453084</p>
<p>出栈 会带着返回地址，找到要返回的那个地址</p>
<p>image-20210725113438700</p>
<p>image-20210725114525969</p>
<p>aaa</p>
<p>image-20210725114555917</p>
<p>多线程栈帧演示</p>
<pre><code>public static void main(String[] args) {

    new Thread(() -&gt; {
        method1(20);
    }, &quot;t1&quot;).start();

    method1(10);
}

public static void method1(int x) {

    System.out.println(x);
    Object o = method2(x);
    System.out.println(o);
}

public static Object method2(int x) {
    return new Object();
}
</code></pre>
<p>首先改变断点模式</p>
<p>image-20210725114927737</p>
<p>线程上下文切换(Thread Context Switch)</p>
<p>因为以下一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码</p>
<p>线程的cpu时间片用完</p>
<p>垃圾回收</p>
<p>有更高优先级的线程需要运行</p>
<p>线程自己调用了sleep、 yield、 wait、join、 park、 synchronized、lock等方法</p>
<p>上下文切换图例</p>
<p>image-20210725142530526</p>
<p>当Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条jvm指令的执行地址，是线程私有的</p>
<p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>Context Switch频繁发生会影响性能</p>
<p>3.4 常见方法</p>
<p>start()<br>
启动一个新线程，start方法只是让线程进入就绪，里面代码不一定立刻运行在新的线程运行run（CPU的时间片还没分给它）。每个线程对象的start方法只方法中的代码能调用一次，如果调用了多次会出现IllegalThreadStateException</p>
<p>image-20210725142719859</p>
<p>重点注意⚠️</p>
<p>isInterrupted()   判断是否被打断，不会清除打断标记</p>
<p>interrupted())   static   判断当前线程是否被打断. 会清除打断标记</p>
<p>image-20210725143039366</p>
<ol>
<li>run和start</li>
</ol>
<p>Run()方法调用---执行的是普通方法，是main线程调用的 非新开线程调用</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;run方法&quot;);
    }, &quot;aaa&quot;);

    // 执行的是普通方法，是main线程调用的 非新开线程调用
    thread.run();

}
</code></pre>
<p>start() 执行的新开线程调用</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;线程:&quot; + &quot;run方法&quot;);
    }, &quot;aaa&quot;);

    // 执行的新开线程调用
    thread.start();
    log.info(Thread.currentThread().getName() + &quot;线程执行了日志&quot; + &quot;：aaa&quot;);

}
</code></pre>
<ol start="2">
<li>sleep和yield</li>
</ol>
<p>yield 让出当前线程</p>
<p>调用yield会让当前线程从Running进入Rumable状态，然后调度执行其它同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果</p>
<p>具体的实现依赖于操作系统的任务调度器</p>
<p>案例</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {<br>
Thread thread = new Thread(() -&gt; {<br>
int count = 0;<br>
for (; ; ) {<br>
System.out.println(&quot;---&gt;&quot;+Thread.currentThread().getName() + &quot;线程：&quot; + count++);<br>
}<br>
}, &quot;thrad1&quot;);</p>
<pre><code>    Thread thread2 = new Thread(() -&gt; {
        int count = 0;

        for (; ; ) {
            Thread.yield();
            System.out.println(&quot;                    --------&gt;&quot;+Thread.currentThread().getName() + &quot;线程：&quot; + count++);
        }
    }, &quot;thrad2&quot;);

    thread.start();
    thread2.start();
}
</code></pre>
<p>sleep</p>
<p>调用sleep会让当前线程从Running进入Timed Waiting状态</p>
<p>其它线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException</p>
<p>睡眠结束后的线程未必会立刻得到执行</p>
<p>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</p>
<p>1、状态演示</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;线程:&quot; + &quot;run方法&quot;);
    }, &quot;aaa&quot;);

    System.out.println(thread.getName()+&quot;线程：&quot;+thread.getState());
    // 新开线程调用
    thread.start();
    System.out.println(thread.getName()+&quot;线程：&quot;+thread.getState());
    log.info(Thread.currentThread().getName() + &quot;线程执行了日志&quot; + &quot;：aaa&quot;);
    System.out.println(thread.getName()+&quot;线程：&quot;+thread.getState());

}
</code></pre>
<p>输出：</p>
<p>//info日志<br>
aaa线程：NEW<br>
aaa线程：RUNNABLE<br>
15:01:04.816 [main] INFO com.example.heimajuc.my2thread.Thread1SleepMethodStatus - main线程执行了日志：aaa<br>
aaa线程：TIMED_WAITING<br>
15:01:05.813 [aaa] INFO com.example.heimajuc.my2thread.Thread1SleepMethodStatus - aaa线程:run方法<br>
线程中断-打断</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            log.info(&quot;interrupt .....&quot;);
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;线程:&quot; + &quot;run方法&quot;);
    }, &quot;aaa&quot;);

    // 新开线程调用
    thread.start();
    Thread.sleep(1000);
    log.info(Thread.currentThread().getName() + &quot;：interrupt aa Thread&quot;);
    // 中间thread线程
    thread.interrupt();

}
</code></pre>
<p>2.1 线程优先级</p>
<p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，绸度器可以忽略它</p>
<p>如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但cpu闲时，优先级几乎没作用</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        int count = 0;
        for (; ; ) {
            System.out.println(&quot;---&gt;&quot; + Thread.currentThread().getName() + &quot;线程：&quot; + count++);
        }
    }, &quot;thrad1&quot;);

    Thread thread2 = new Thread(() -&gt; {
        int count = 0;
        for (; ; ) {
            System.out.println(&quot;                    --------&gt;&quot; + Thread.currentThread().getName() + &quot;线程：&quot; + count++);
        }
    }, &quot;thrad2&quot;);

    thread.setPriority(Thread.MAX_PRIORITY);
    thread2.setPriority(Thread.MIN_PRIORITY);
    thread.start();
    thread2.start();
}
</code></pre>
<ol start="3">
<li>join使用</li>
</ol>
<p>等待其他线程结束完成<br>
为什么使用join？结果是啥</p>
<p>private static int anInt = 0;</p>
<pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {
    method1();
}

public static void method1() {
    log.info(Thread.currentThread().getName() + &quot;：线程：start&quot;);
    new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;：线程：sleep start&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;：sleep：end&quot;);
        anInt = 100;
    }, &quot;thrad1&quot;).start();

    log.info(&quot;int,{}&quot;, anInt);
    log.info(&quot;int,{}&quot;, &quot;end&quot;);
}
</code></pre>
<p>结果是0；</p>
<p>分析：</p>
<p>main线程还没有等thrad1线程执行完，就已经去拿数据了。所以是0</p>
<p>解决办法：</p>
<p>使用sleep 不推荐使用 因为不知道要休眠多久</p>
<p>使用join</p>
<p>使用futureTask get方法 拿到结果</p>
<p>方法2解决</p>
<p>private static int anInt = 0;</p>
<pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {
    method1();
}

public static void method1() {
    log.info(Thread.currentThread().getName() + &quot;：线程：start&quot;);
    Thread thread = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;：线程：sleep start&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;：sleep：end&quot;);
        anInt = 100;
    }, &quot;thrad1&quot;);
    thread.start();

    // 等待线程结束 在执行下面的代码
    try {
        thread.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.info(&quot;int结果,{}&quot;, anInt);
    log.info(&quot;int结果,{}&quot;, &quot;end&quot;);
}
</code></pre>
<p>image-20210725155740764</p>
<p>如果使用多个同步操作呢。实际耗费1s中</p>
<p>private static int anInt = 0;</p>
<pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {
    method1();
}

public static void method1() throws InterruptedException {
    log.info(Thread.currentThread().getName() + &quot;：线程：start&quot;);
    Thread thread = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;：线程：sleep start&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;：sleep：end&quot;);
        anInt = 100;
    }, &quot;thrad1&quot;);

    Thread thread2 = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;：线程：sleep start&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;：sleep：end&quot;);
        anInt = 200;
    }, &quot;thrad1&quot;);

    thread.start();
    thread2.start();
    // 等待线程结束 在执行下面的代码
    log.info(&quot;join1--begin&quot;);
    thread.join();
    log.info(&quot;join1--end&quot;);

    log.info(&quot;join2--begin&quot;);
    thread2.join();
    log.info(&quot;join2--end&quot;);
    log.info(&quot;int结果,{}&quot;, anInt);
}
</code></pre>
<p>join方法等待其他线程操作</p>
<p>image-20210725161055059</p>
<p>带等待时间的join</p>
<p>private static int anInt = 0;</p>
<pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {
    method1();
}

public static void method1() throws InterruptedException {
    log.info(Thread.currentThread().getName() + &quot;：线程：start&quot;);
    Thread thread = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;：线程：sleep start&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;：sleep：end&quot;);
        anInt = 100;
    }, &quot;thrad1&quot;);

    thread.start();
    Instant now = Instant.now();
    // 等待线程结束 在执行下面的代码
    log.info(&quot;join1--begin&quot;);
    // 如果等到时间小于休眠时间 那么就会不再等待
</code></pre>
<p>//        thread.join(500);<br>
// 如果等到时间大于休眠时间 那么就会提前结束<br>
thread.join(2000);<br>
log.info(&quot;join1--end&quot;);<br>
long l = Duration.between(now, Instant.now()).toMillis();<br>
log.info(&quot;int结果,{}&quot;, anInt);<br>
log.info(&quot;时间,{}&quot;, l);<br>
}<br>
4. interrupt使用</p>
<p>打断阻塞状态的线程：sleep、wait、join线程<br>
打断阻塞线程才是清楚。非阻塞线程都是通知</p>
<p>打断sleep、wait、join线程都是直接抛出异常</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            log.info(&quot;interrupt .....&quot;);
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;线程:&quot; + &quot;run方法&quot;);
    }, &quot;aaa&quot;);

    // 新开线程调用
    thread.start();
    TimeUnit.SECONDS.sleep(2);
    log.info(Thread.currentThread().getName() + &quot;：interrupt aa Thread&quot;);
    // 中间thread线程
    thread.interrupt();
    log.info(thread.getName() + &quot;：打断标记：&quot;+thread.isInterrupted());
}
</code></pre>
<p>输出：</p>
<p>20:04:24.739 [main] INFO com.example.heimajuc.my2thread.Thread1InterruptMethodJoin - main：interrupt aa Thread<br>
20:04:24.744 [main] INFO com.example.heimajuc.my2thread.Thread1InterruptMethodJoin - aaa：打断标记：false<br>
20:04:24.745 [aaa] INFO com.example.heimajuc.my2thread.Thread1InterruptMethodJoin - interrupt .....<br>
20:04:24.746 [aaa] INFO com.example.heimajuc.my2thread.Thread1InterruptMethodJoin - aaa线程:run方法<br>
java.lang.InterruptedException: sleep interrupted<br>
at java.lang.Thread.sleep(Native Method)<br>
at java.lang.Thread.sleep(Thread.java:340)<br>
at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)<br>
at com.example.heimajuc.my2thread.Thread1InterruptMethodJoin.lambda$main$0(Thread1InterruptMethodJoin.java:19)<br>
at java.lang.Thread.run(Thread.java:748)<br>
正常线程</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<pre><code>    Thread thread = new Thread(() -&gt; {
        while (true) {
            boolean interrupted = Thread.interrupted();
            if (interrupted) {
                // 线程被人通知打断
                log.info(&quot;线程被打断，退出循环&quot;);
                break;
            }

        }
    }, &quot;aaa&quot;);
    // 新开线程调用
    thread.start();
    TimeUnit.SECONDS.sleep(2);
    // 中间thread线程
    thread.interrupt();
    log.info(thread.getName() + &quot;：打断标记：&quot; + thread.isInterrupted());
}
</code></pre>
<p>输出：</p>
<p>20:21:00.488 [main] INFO com.example.heimajuc.my2thread.Thread1InterruptMethod - aaa：打断标记：false<br>
20:21:00.489 [aaa] INFO com.example.heimajuc.my2thread.Thread1InterruptMethod - 线程被打断，退出循环<br>
打断park线程</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {<br>
Thread thread =  new Thread(() -&gt; {<br>
log.info(&quot;park  ing .....&quot;);<br>
LockSupport.park();<br>
log.info(&quot;park  end .....&quot;);<br>
log.info(&quot;打断状态：{}&quot;,Thread.currentThread().isInterrupted());<br>
// 打断标记为真的时候 就不再打断了 park失效状态<br>
LockSupport.park();<br>
log.info(&quot;park  end .....&quot;);<br>
}, &quot;thread&quot;);<br>
thread.start();<br>
System.out.println(thread.getName()+&quot;线程：&quot;+thread.getState());<br>
System.out.println(Thread.currentThread().getName()+&quot;线程：&quot;+Thread.currentThread().getState());<br>
thread.interrupt();<br>
System.out.println(thread.getName()+&quot;线程：&quot;+thread.getState());<br>
}<br>
// 打断标记为真的时候 就不再打断了 park失效状态**<br>
LockSupport.park();**</p>
<p>输出：</p>
<p>thread线程：RUNNABLE<br>
main线程：RUNNABLE<br>
thread线程：RUNNABLE<br>
22:44:07.018 [thread] INFO com.example.heimajuc.my2thread.Thread1InterruptPark - park  ing .....<br>
22:44:07.022 [thread] INFO com.example.heimajuc.my2thread.Thread1InterruptPark - park  end .....<br>
22:44:07.022 [thread] INFO com.example.heimajuc.my2thread.Thread1InterruptPark - 打断状态：true<br>
3.5 主线程和守护线程</p>
<p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p>守护线程</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {<br>
Thread thread =  new Thread(() -&gt; {<br>
while (true){<br>
if (Thread.currentThread().isInterrupted()){<br>
break;<br>
}<br>
System.out.print(&quot;aa&quot;);<br>
}<br>
log.info(&quot;aaa&quot;);<br>
}, &quot;thread&quot;);<br>
// 守护线程<br>
thread.setDaemon(true);<br>
thread.start();<br>
System.out.println(Thread.currentThread().getName()+&quot;线程：&quot;+Thread.currentThread().getState());<br>
}<br>
注意⚠️</p>
<p>垃圾回收器线程就是一种守护线程</p>
<p>Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</p>
<p>3.6 线程的五种状态</p>
<p>从操作系统层面来描述。</p>
<p>image-20210726203444819</p>
<p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p>
<p>【可运行状态】Runnable（就绪状态）指该线程已经被创建（与操作系统线程关联）</p>
<p>可以由CPU调度执行【运行状态】start 指获取了CPU时间片运行中的状态</p>
<p>当CPU时间片用完，会从【运行状态】Running 转换至【可运行状态】Runnable，会导致线程的上下文切换</p>
<p>【运行状态】获取cpu调度使用</p>
<p>【阻塞状态】</p>
<p>如果调用了阻塞API，如BIO读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入【阻塞状态】</p>
<p>等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p>
<p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p>
<p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
<p>3.7 线程的六种状态</p>
<p>这是从 Java API层面来描述的<br>
根据 Thread. State枚举,分为六种状态</p>
<p>NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;</p>
<p>image-20210726204505441</p>
<p>NEW线程刚被创建，但是还没有调用start（）方法</p>
<p>RUNNABLE当调用了start（）方法之后，注意，Java API层面的RUNNABLE状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（由于BIO导致的线程阻塞，在Java里无法区分，仍然认为是可运行）</p>
<p>BLOCKED，WAITING，TIMED_WAITING都是JavaAPI层面对【阻塞状态】的细分，后面会在状态转换一节详述</p>
<p>TERMINATED当线程代码运行结束</p>
<p>public static void main(String[] args) throws ExecutionException, InterruptedException {<br>
// NEW状态<br>
Thread thread1 = new Thread(() -&gt; {<br>
}, &quot;thread1&quot;);</p>
<pre><code>    //RUNNABLE
    Thread thread2 = new Thread(() -&gt; {
        while (true) {
        }
    }, &quot;thread2&quot;);
    thread2.start();

    // TERMINATED
    Thread thread3 = new Thread(() -&gt; {
        log.info(&quot;thread3.......&quot;);
    }, &quot;thread3&quot;);
    thread3.start();

    // TIMED_WAITING
    Thread thread4 = new Thread(() -&gt; {
        synchronized (Thread1Status.class){
            try {
                TimeUnit.SECONDS.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, &quot;thread4&quot;);
    thread4.start();

    // WAITING
    Thread thread5 = new Thread(() -&gt; {
        try {
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, &quot;thread5&quot;);
    thread5.start();

    //BLOCK
    Thread thread6 = new Thread(() -&gt; {
        synchronized (Thread1Status.class){
            try {
                TimeUnit.SECONDS.sleep(1000000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, &quot;thread6&quot;);
    thread6.start();

    TimeUnit.SECONDS.sleep(1);

    System.out.println(thread1.getName() + &quot;线程：&quot; + thread1.getState());
    System.out.println(thread2.getName() + &quot;线程：&quot; + thread2.getState());
    System.out.println(thread3.getName() + &quot;线程：&quot; + thread3.getState());
    System.out.println(thread4.getName() + &quot;线程：&quot; + thread4.getState());
    System.out.println(thread5.getName() + &quot;线程：&quot; + thread5.getState());
    System.out.println(thread6.getName() + &quot;线程：&quot; + thread6.getState());
}
</code></pre>
<p>输出：</p>
<p>thread1线程：NEW<br>
thread2线程：RUNNABLE<br>
thread3线程：TERMINATED<br>
thread4线程：TIMED_WAITING<br>
thread5线程：WAITING<br>
thread6线程：BLOCKED<br>
3.7 习题</p>
<p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示</p>
<p>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程</p>
<p>文中办法乙、丙都相当于任务串行</p>
<p>而图一相当于启动了4个线程，有点浪费</p>
<p>用sleep（n）模拟洗茶壶、洗水壶等耗费的时间</p>
<p>附：华罗庚《统筹方法》<br>
统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。<br>
怎样应用呢？主要是把工序安排好。<br>
比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗；火已生了，茶叶也有了。怎么办？</p>
<p>办法甲：洗好水壶，灌上凉水，放在火上，在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。</p>
<p>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</p>
<p>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</p>
<p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p>
<p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p>
<p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下边的箭头图来表示：</p>
<p>image-20210726211924941</p>
<p>工业的错综复杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现“万事俱备，只欠东风”的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。<br>
洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因而可以合并成为：</p>
<p>image-20210726214512602</p>
<p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。<br>
这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法虽然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p>
<p>coding</p>
<p>public static void main(String[] args) {<br>
Thread t1 = new Thread(() -&gt; {<br>
// 开始洗水壶 花费一分钟<br>
log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;开始洗水壶&quot;);<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;洗完了洗水壶 花费1s&quot;);<br>
log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;水壶洗完，就开始烧水&quot;);<br>
try {<br>
TimeUnit.SECONDS.sleep(8);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;烧水烧完了，花费8秒&quot;);<br>
}, &quot;001&quot;);<br>
t1.start();</p>
<pre><code>    Thread t2 = new Thread(() -&gt; {
        log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;开始--洗茶杯、洗茶壶、拿茶叶&quot;);
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;洗茶杯、洗茶壶、拿茶叶,洗完了花费3秒&quot;);
        try {
            t1.join();
            log.info(Thread.currentThread().getName() + &quot;:&quot; + &quot;开始泡茶&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, &quot;002&quot;);
    t2.start();
}
</code></pre>
<p>输出：</p>
<p>21:44:08.018 [001] INFO com.example.heimajuc.sample.ThreadTeaSample - 001:开始洗水壶<br>
21:44:08.022 [002] INFO com.example.heimajuc.sample.ThreadTeaSample - 002:开始--洗茶杯、洗茶壶、拿茶叶<br>
21:44:09.022 [001] INFO com.example.heimajuc.sample.ThreadTeaSample - 001:洗完了洗水壶 花费1s<br>
21:44:09.022 [001] INFO com.example.heimajuc.sample.ThreadTeaSample - 001:水壶洗完，就开始烧水<br>
21:44:11.022 [002] INFO com.example.heimajuc.sample.ThreadTeaSample - 002:洗茶杯、洗茶壶、拿茶叶,洗完了花费3秒<br>
21:44:17.025 [001] INFO com.example.heimajuc.sample.ThreadTeaSample - 001:烧水烧完了，花费8秒<br>
21:44:17.025 [002] INFO com.example.heimajuc.sample.ThreadTeaSample - 002:开始泡茶<br>
解法1的缺陷：</p>
<p>上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶呢？代码最好能适应两种情况</p>
<p>上面的两个线程其实是各执行各的，如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡茶呢</p>
<p>本章总结</p>
<p>本章的重点在于掌握</p>
<p>线程创建</p>
<p>线程重要api，如start，run，sleep，join，interrupt等</p>
<p>线程状态</p>
<p>应用方面</p>
<p>异步调用：主线程执行期间，其它线程异步执行耗时操作。提高效率：并行计算，缩短运算时间</p>
<p>同步等待：join</p>
<p>统筹规划：合理使用线程，得到最优效果</p>
<p>原理方面</p>
<p>线程运行流程：栈、栈帧、上下文切换、程序计数器，Thread两种创建方式的源码</p>
<p>模式方面</p>
<p>两阶段终止</p>
<ol start="4">
<li>共享模型之管程</li>
</ol>
<p>共享问题 &quot; synchronized</p>
<p>线程安全分析</p>
<p>Monitor</p>
<p>wait/notify</p>
<p>线程状态转换</p>
<p>活跃性</p>
<p>Lock</p>
<p>4.1 共享带来的问题</p>
<p>image-20210726221529667</p>
<p>image-20210726221701681</p>
<p>image-20210726221946430</p>
<p>image-20210726221848245</p>
<p>Java体现</p>
<p>static int anInt = 0;</p>
<pre><code>public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -&gt; {
        for (int i = 0; i &lt; 5000; i++) {
            anInt++;
        }
    });

    Thread thread1 = new Thread(() -&gt; {
        for (int i = 0; i &lt; 5000; i++) {
            anInt--;
        }
    });
    thread.start();
    thread1.start();
    thread.join();
    thread1.join();
    System.out.println(anInt);
}
</code></pre>
<p>输出：</p>
<p>56<br>
上下切换导致</p>
<p>负数情况：</p>
<p>image-20210726231003297</p>
<p>正数情况：</p>
<p>image-20210726231123189</p>
<p>临界区</p>
<p>临界区 Critical Section</p>
<p>一个程序运行多个线程本身是没有问题的。</p>
<p>问题出在多个线程访问共享资源，多个线程读共享资源其实也没有问题。在多个线程对共享资源读写操作时发生指令交错，就会出现问题，一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p>
<p>例如，下面代码中的临界区</p>
<p>static int counter = 0;<br>
static void increment() {cqunter++;}// 临界区<br>
static void decrement() {counter--;}//临界区<br>
竞态条件</p>
<p>竞态条件 Race Condition<br>
多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>4.1 synchronized解决方案</p>
<p>应用之互斥</p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<p>阻塞式的解决方案：synchronized，Lock</p>
<p>非阻塞式的解决方案：原子变量</p>
<p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。注意，虽然java中互斥和同步都可以采用synchronized关键字来完成，但它们还是有区别的：</p>
<p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p>
<p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p>
<p>加锁解决上下文切换导致数据不对的问题：</p>
<p>​<br>
static int anInt = 0;<br>
static Object object = new Object();<br>
​<br>
public static void main(String[] args) throws InterruptedException {<br>
Thread thread = new Thread(() -&gt; {<br>
for (int i = 0; i &lt; 5000; i++) {<br>
synchronized (object) {<br>
anInt++;<br>
}<br>
}<br>
});<br>
​<br>
Thread thread1 = new Thread(() -&gt; {<br>
for (int i = 0; i &lt; 5000; i++) {<br>
synchronized (object) {<br>
anInt--;<br>
}<br>
}<br>
});<br>
thread.start();<br>
thread1.start();<br>
thread.join();<br>
thread1.join();<br>
System.out.println(anInt);<br>
}<br>
类比：</p>
<p>image-20210728202754938</p>
<p>image-20210728203143848</p>
<p>image-20210728203207647</p>
<p>思考</p>
<p>synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。<br>
为了加深理解，请思考下面的问题：</p>
<p>如果把synchronized（obj）放在for循环的外面，如何理解？</p>
<p>循环外，是一次性执行完整个for循环，执行完以后在执行其他的操作</p>
<p>如果tl synchronized（obJ1）而t2synchronized（obj2）会怎样运作？</p>
<p>对象不一致的时候，获取的对象锁不一致，所以无效</p>
<p>如果tl synchronized（obj）而2没有加会怎么样？如何理解？</p>
<p>2没有加synchronize，时间片轮到线程2的时候，不会去拿对象锁，他自己执行自己的内容</p>
<p>4.2 方法上的synchronized</p>
<p>public synchronized void addCount() {<br>
count++;<br>
}<br>
// 等价于<br>
public void addCount() {<br>
synchronized (this) {<br>
count++;<br>
}<br>
}<br>
所谓的“线程八锁”</p>
<p>情况1:</p>
<p>答案为：12或者21</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A a = new A();<br>
Thread thread = new Thread(() -&gt; { a.a1(); });</p>
<pre><code>    Thread thread1 = new Thread(() -&gt; { a.a2(); });
    thread.start();
    thread1.start();
}
</code></pre>
<p>}</p>
<p>@Slf4j<br>
class A {<br>
// synchronized 锁住的是this对象<br>
public synchronized void a1() {<br>
log.info(&quot;111111&quot;);<br>
}</p>
<pre><code>public synchronized void a2() {
    log.info(&quot;222222&quot;);
}
</code></pre>
<p>情况2：</p>
<p>答案为：12或者21</p>
<p>两种情况：</p>
<p>存在thread1 先拿到时间片 然后输出方法；然后thread在拿到时间片，在睡眠1s，在输出</p>
<p>thread拿到时间片，然后等到一秒后，输出，thread2拿到时间片，输出</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A1 a = new A1();<br>
Thread thread = new Thread(() -&gt; {a.a1(); });</p>
<pre><code>    Thread thread1 = new Thread(() -&gt; { a.a2(); });
    thread.start();
    thread1.start();
}
</code></pre>
<p>}</p>
<p>@Slf4j<br>
class A1 {<br>
// synchronized 锁住的是this对象<br>
public synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}</p>
<pre><code>public synchronized void a2() {
    log.info(&quot;222222&quot;);
}
</code></pre>
<p>}<br>
情况3：</p>
<p>答案为：312或者 321 或者231</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A2 a = new A2();<br>
new Thread(() -&gt; { a.a1(); }).start();<br>
new Thread(() -&gt; { a.a2(); }).start();<br>
new Thread(() -&gt; { a.a3(); }).start();<br>
}<br>
}</p>
<p>@Slf4j<br>
class A2 {<br>
// synchronized 锁住的是this对象<br>
public synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(2);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}</p>
<pre><code>public synchronized void a2() {
    log.info(&quot;222222&quot;);
}
public  void a3() { log.info(&quot;3333&quot;); }
</code></pre>
<p>情况4：</p>
<p>答案为：2 1s 1</p>
<pre><code>public static void main(String[] args) throws InterruptedException {
    A2 a1 = new A2();
    A2 a2 = new A2();
    new Thread(() -&gt; { a1.a1(); }).start();
    new Thread(() -&gt; { a2.a2(); }).start();
}
</code></pre>
<p>}</p>
<p>@Slf4j<br>
class A3 {<br>
// synchronized 锁住的是this对象<br>
public synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}<br>
public synchronized void a2() {<br>
log.info(&quot;222222&quot;);<br>
}<br>
情况5：</p>
<p>答案为：2 1s 1</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A4 a1 = new A4();<br>
new Thread(() -&gt; { a1.a1(); }).start();<br>
new Thread(() -&gt; { a1.a2(); }).start();<br>
}<br>
}</p>
<p>@Slf4j<br>
class A4 {<br>
/**<br>
* desc:synchronized 锁住的是this对象<br>
* static 锁住的是A4 对象<br>
*/<br>
public static synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}<br>
public synchronized void a2() {<br>
log.info(&quot;222222&quot;);<br>
}<br>
情况6：</p>
<p>答案为：2 1s 1 或者1 1s 2</p>
<p>static锁住的对象都是A6</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A6 a1 = new A6();<br>
new Thread(() -&gt; { a1.a1(); }).start();<br>
new Thread(() -&gt; { a1.a2(); }).start();<br>
}<br>
}</p>
<p>@Slf4j<br>
class A6 {<br>
/**<br>
* desc:synchronized 锁住的是this对象<br>
* static 锁住的是A6 对象<br>
*/<br>
public static synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}<br>
public  static synchronized void a2() {<br>
log.info(&quot;222222&quot;);<br>
}<br>
情况7：</p>
<p>答案为：2 1s 1</p>
<p>static锁住的对象都是A7</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A7 a1 = new A7();<br>
A7 a2 = new A7();<br>
new Thread(() -&gt; {<br>
a1.a1();<br>
}).start();<br>
new Thread(() -&gt; {<br>
a2.a2();<br>
}).start();<br>
}<br>
}</p>
<p>@Slf4j<br>
class A7 {<br>
/**<br>
* desc:synchronized 锁住的是this对象<br>
* static 锁住的是A6 对象<br>
*/<br>
public static synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}</p>
<pre><code>public  synchronized void a2() {
    log.info(&quot;222222&quot;);
}
</code></pre>
<p>情况8：</p>
<p>答案为：2 1s 1 或者 1 1s 2</p>
<p>static锁住的对象都是A8</p>
<p>public static void main(String[] args) throws InterruptedException {<br>
A8 a1 = new A8();<br>
A8 a2 = new A8();</p>
<pre><code>    new Thread(() -&gt; {
        a2.a2();
    }).start();
    new Thread(() -&gt; {
        a1.a1();
    }).start();
}
</code></pre>
<p>}</p>
<p>@Slf4j<br>
class A8 {<br>
/**<br>
* desc:synchronized 锁住的是this对象<br>
* static 锁住的是A6 对象<br>
*/<br>
public static synchronized void a1() {<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
log.info(&quot;111111&quot;);<br>
}</p>
<pre><code>public static synchronized void a2() {
    log.info(&quot;222222&quot;);
}
</code></pre>
<p>}<br>
4.3 变量的线程安全分析</p>
<p>成员变量和静态变量是否线程安全？</p>
<p>如果它们没有共享，则线程安全</p>
<p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p>
<p>如果只有读操作，则线程安全</p>
<p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p>
<p>局部变量是否线程安全？</p>
<p>局部变量是线程安全的</p>
<p>但局部变量引用的对象则未必</p>
<p>如果该对象没有逃离方法的作用访问，它是线程安全的</p>
<p>如果该对象逃离方法的作用范围，需要考虑线程安全</p>
<p>public static void main(String[] args) {<br>
ThreadUnsafe threadUnsafe = new ThreadUnsafe();<br>
for (int i = 0; i &lt; 2; i++) {<br>
new Thread(() -&gt; {<br>
threadUnsafe.test();<br>
});</p>
<pre><code>    }
}
</code></pre>
<p>}</p>
<p>class ThreadUnsafe {<br>
public static List<Integer> list = new ArrayList&lt;&gt;();</p>
<pre><code>public void test() {
    add();
    in();
}

public void add() {
    list.add(1);
}

public void in() {
    list.remove(0);
}
</code></pre>
<p>静态变量访问的是在共享内存中的，多个栈帧访问就会出现不安全的情况</p>
<p>image-20210731171800940</p>
<p>局部变量</p>
<p>public static void main(String[] args) {<br>
ThreadSafe threadUnsafe = new ThreadSafe();<br>
for (int i = 0; i &lt; 20; i++) {<br>
new Thread(() -&gt; {<br>
threadUnsafe.test();<br>
});</p>
<pre><code>    }
}
</code></pre>
<p>}</p>
<p>class ThreadSafe {</p>
<pre><code>public void test() {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    add(list);
    in(list);
}

public void add(List&lt;Integer&gt; list) {
    list.add(1);
}

public void in(List&lt;Integer&gt; list) {
    list.remove(0);
}
</code></pre>
<p>局部变量使用的时候，创建实例的时候会单独创建对象，所以线程安全的</p>
<p>image-20210731172201260</p>
<p>如果方法修饰符：是使用privite  那么只能自己去调用，肯定线程安全。如果是final修饰 那么就不能被改变。</p>
<p>常见的线程安全类</p>
<p>String</p>
<p>Integer</p>
<p>StringBuffer</p>
<p>Random</p>
<p>Vector</p>
<p>Hashtable</p>
<p>java.util.concurrent包下的类</p>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为它们的每个方法是原子的</p>
<p>但注意它们多个方法的组合不是原子的，见后面分析</p>
<p>线程安全类的组合</p>
<p>分析以下代码是否安全</p>
<p>public static void main(String[] args) {<br>
Hashtable&lt;String, String&gt; hashtable = new Hashtable&lt;&gt;();<br>
if (Objects.isNull(hashtable.get(&quot;key&quot;))){<br>
hashtable.put(&quot;key&quot;, &quot;a&quot;);<br>
}<br>
}<br>
存在线程1 线程2 同时操作table 但是由于上下文切换，线程1执行到了判断为null 的时候，就把时间片交出去了，然后线程2 判断了为null，然后赋值操作，时间片在交给1，就会存在线程不安全的操作</p>
<p>线程1<br>
线程1<br>
线程2<br>
线程2<br>
table<br>
table<br>
get(&quot;key&quot;)==null<br>
get(&quot;key&quot;)==null<br>
put(&quot;key&quot;,v2)<br>
put(&quot;key&quot;,v1)<br>
不可变类线程安全问题</p>
<p>String、Integer等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的<br>
有同学或许有疑问，String有replace，substring等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p>
<p>实例分析</p>
<p>例1:</p>
<p>public class MyServlet extends HttpServlet {<br>
​<br>
/*<em>线程不安全</em>/<br>
Map&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>
/*<em>线程安全</em>/<br>
String s1 = &quot;a&quot;;<br>
/*<em>线程安全</em>/<br>
final String s2 = &quot;22&quot;;<br>
/*<em>线程不安全</em>/<br>
Date date = new Date();<br>
/*<em>线程不安全</em>/<br>
final Date date2 = new Date();<br>
​<br>
@Override<br>
public void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){<br>
// 使用上面的变量<br>
​<br>
}<br>
}<br>
例2:</p>
<p>线程不安全，会有多个线程调用count</p>
<p>​<br>
public class MyServlet extends HttpServlet {<br>
@Autowired<br>
private UserService userService;<br>
​<br>
@Override<br>
public void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){<br>
// 使用上面的变量<br>
userService.update();<br>
}}<br>
​<br>
public class UserServiceImpl implements UserService {<br>
private int count = 0;<br>
​<br>
@Override<br>
public void update() {<br>
count++;<br>
}<br>
}</p>
<p>例3:</p>
<p>也是线程不安全的，使用了共享变量，模式是单例模式</p>
<p>long l;<br>
​<br>
@Pointcut(&quot;execution(* com.example.heimajuc.<em>.</em>(..))&quot;)<br>
public void pointcut() {<br>
​<br>
}<br>
​<br>
@Before(&quot;pointcut()&quot;)<br>
public void before() {<br>
l = System.nanoTime();<br>
System.out.println(&quot;before&quot;);<br>
}<br>
​<br>
@After(&quot;pointcut()&quot;)<br>
public void after() {<br>
System.out.println(&quot;after&quot;);<br>
System.out.println(&quot;耗时：&quot; + (System.nanoTime() - l));<br>
}<br>
例4:</p>
<p>常规操作写法是线程安全的，因为都是开启了新的栈帧，并且没有引用都是稀有的，只能自己调用。</p>
<p>public class MyServlet extends HttpServlet {<br>
@Autowired<br>
private UserService userService;<br>
​<br>
@Override<br>
public void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){<br>
// 使用上面的变量<br>
userService.update();<br>
}}</p>
<p>@Service<br>
public class UserServiceImpl implements UserService {<br>
​<br>
@Autowired<br>
private UserMapper userMapper;<br>
​<br>
@Override<br>
public void update() {<br>
List<User> userList=  userMapper.SelectList(null);<br>
}<br>
}<br>
例5:</p>
<p>常规操作写法是线程不安全的，UserDaoImpl被多个线程共享，所以conn 被共享了。所以可能存在线程1在获取conn的时候，线程2 已经获取到了并且执行完了，然后conn关闭了 close</p>
<p>public class MyServlet extends HttpServlet {<br>
@Autowired<br>
private UserService userService;<br>
​<br>
@Override<br>
public void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){<br>
// 使用上面的变量<br>
userService.update();<br>
}}</p>
<p>@Service<br>
public class UserServiceImpl implements UserService {<br>
​<br>
@Autowired<br>
private UserDao userDao;<br>
​<br>
​<br>
@Override<br>
public void update() {<br>
userDao.update();<br>
}<br>
}<br>
​<br>
@Mapper<br>
public class UserDaoImpl implements UserService {<br>
​<br>
private Connect conn=null;</p>
<pre><code>@Override
public void update() {
  String sql =&quot;update user set password = ? where username =?&quot;; 
conn = DriverManager.getconnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);
conn.close();
}
</code></pre>
<p>}<br>
​<br>
​<br>
例6:</p>
<p>常规操作写法是线程不安全的，UserServiceImpl每次都是新建立的，私有的栈帧</p>
<p>public class MyServlet extends HttpServlet {<br>
@Autowired<br>
private UserService userService;<br>
​<br>
@Override<br>
public void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){<br>
// 使用上面的变量<br>
userService.update();<br>
}}</p>
<p>@Service<br>
public class UserServiceImpl implements UserService {<br>
​<br>
@Override<br>
public void update() {<br>
UserDao userDao =new UserDaoImpl();</p>
<pre><code>userDao.update();
}
</code></pre>
<p>}<br>
​<br>
@Mapper<br>
public class UserDaoImpl implements UserService {<br>
​<br>
private Connect conn=null;</p>
<pre><code>@Override
public void update() {
  String sql =&quot;update user set password = ? where username =?&quot;; 
conn = DriverManager.getconnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);
conn.close();
}
</code></pre>
<p>}<br>
​<br>
​<br>
例7:</p>
<p>常规操作写法是线程不安全的</p>
<p>String类为什么设置为final ，因为如果不设置成final，string的子类可能覆盖父类的方法，然后可能导致修改或者覆盖掉了父类的一些行为，导致线程不安全。</p>
<p>4.4 练习</p>
<p>卖票练习</p>
<p>线程不安全</p>
<p>临界区：对共享变量有读写操作的区域</p>
<p>public class SellTicketDemo {<br>
​<br>
public static void main(String[] args) {<br>
​<br>
WindowsSell windowsSell = new WindowsSell(1000);<br>
// 线程安全的List<br>
List<Integer> sellCount = new Vector&lt;&gt;();<br>
List<Thread> list = new ArrayList&lt;&gt;();<br>
for (int i = 0; i &lt; 2000; i++) {<br>
Thread thread = new Thread(() -&gt; {<br>
// 开始买票<br>
int sell = windowsSell.sell(getRandom());<br>
sellCount.add(sell);<br>
});<br>
thread.start();<br>
list.add(thread);<br>
}<br>
for (Thread thread : list) {<br>
try {<br>
thread.join();<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
System.out.println(&quot;卖出的总数：&quot; + sellCount.stream().mapToInt(Integer::intValue).sum());<br>
System.out.println(&quot;剩余的总数：&quot; + windowsSell.getCount());<br>
​<br>
}<br>
​<br>
/**<br>
* 生产随机数<br>
*/<br>
private static Integer getRandom() {<br>
return new Random().nextInt(5) + 1;<br>
}<br>
​<br>
}<br>
​<br>
​<br>
class WindowsSell {<br>
private int count;<br>
​<br>
WindowsSell(int ticketCount) {<br>
this.count = ticketCount;<br>
}<br>
​<br>
int getCount() {<br>
return count;<br>
}<br>
​<br>
int sell(int tickerNum) {<br>
if (tickerNum &lt; count) {<br>
this.count -= tickerNum;<br>
return tickerNum;<br>
}<br>
return 0;<br>
}<br>
}<br>
输出：</p>
<p>卖出的总数：1008<br>
剩余的总数：1<br>
解决办法1：加synchronized</p>
<p>synchronized int sell(int tickerNum) {<br>
if (tickerNum &lt; count) {<br>
this.count -= tickerNum;<br>
return tickerNum;<br>
}<br>
return 0;<br>
}<br>
4.5 Monitor概念</p>
<p>Java对象头</p>
<p>以32位虚拟机为例</p>
<p>普通对象：</p>
<p>image-20210801205334561</p>
<p>数组对象：</p>
<p>image-20210801205400575</p>
<p>其中Mark Word结构为：</p>
<p>image-20210801205706101</p>
<p>Monitor(锁)</p>
<p>Monitor被翻译为监视器或管程<br>
每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<p>Monitor结构如下</p>
<p>image-20210801210926521</p>
<p>过程：</p>
<p>刚开始 monitor的Owner是没有主人的</p>
<p>当Thread2获取锁对象的时候，就会成为Monitor的Owner，一个Monitor只有一个Owner</p>
<p>在Thread2执行过程过程中的时候，其他的Thread线程来执行临界区的代码的时候，就会进入到EntryList中变成BLOCKED状态</p>
<p>当Thread2执行完毕后，就不再是是Monitor的主人，Owner的为空，然后就会唤醒EntryList中的线程来竞争锁，竞争的时候是非公平的，就会开始竞争获取Owner</p>
<p>图中Thread2是之前获取到锁的，但是不满足条件进入WAITING状态的线程</p>
<p>注意⚠️：</p>
<p>synchronized必须是进入同一个对象的monitor才有上述的效果</p>
<p>不加synchronized，的对象不会关联监视器，不遵从以上规则</p>
<p>原理之synchronized</p>
<p>重点重点🌟Code</p>
<p>public class MonitorDemo {<br>
static int count = 0;<br>
static final Object OBJECT = new Object();<br>
public static void main(String[] args) {<br>
synchronized (OBJECT.class) {<br>
count++;<br>
}<br>
​<br>
}<br>
}<br>
对应的字节码：</p>
<p>image-20210801220837207</p>
<p>故事：</p>
<p>image-20210801221105163</p>
<p>image-20210801221145300</p>
<p>Synchronized原理进阶</p>
<p>轻量级锁</p>
<p>轻量级锁的使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。<br>
轻量级锁对使用者是透明的，即语法仍然是synchronized</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<p>private static  final Object OBJECT = new Object();<br>
​<br>
private static void method1() {<br>
synchronized (OBJECT){<br>
method();<br>
}<br>
}<br>
private static void method() {<br>
synchronized (OBJECT){<br>
​<br>
}<br>
}<br>
image-20210801231540211</p>
<p>image-20210801231557726</p>
<p>image-20210801231717225</p>
<p>image-20210801231756727</p>
<p>image-20210801232009436</p>
<p>image-20210801232048833</p>
<p>锁膨胀</p>
<p>如果在尝试加轻量级锁的过程中,CAS操作无法成功,这时一种情况就是有其它线程为此对象加上了轻量级锁(有竞争),这时需要进行锁膨胀,将轻量级锁变为重量级锁。</p>
<p>image-20210805214701753</p>
<p>image-20210805214613850</p>
<p>image-20210805214819790</p>
<p>。当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程</p>
<p>自旋优化</p>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>image-20210808124421980</p>
<p>image-20210808124519420</p>
<p>在Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<p>自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势。<br>
Java7之后不能控制是否开启自旋功能</p>
<p>偏向锁</p>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。<br>
Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程D是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</p>
<p>锁重入-- main调用m1,然后m1调用m2,m1、m2加了锁，当进入m2的时候，发生了重入，然后m2方法调用m3的是，又锁重入</p>
<p>private static final Object OBJECT = new Object();</p>
<pre><code>public static void main(String[] args) {
    m1();
}

static void m1() {
    synchronized (OBJECT) {
        m2();
    }
}

static void m2() {
    synchronized (OBJECT) {
        m3();
    }
}

static void m3() {
    synchronized (OBJECT) {
        System.out.println(&quot;1&quot;);
    }
}
</code></pre>
<p>image-20210808125526972</p>
<p>image-20210808125804598</p>
<p>偏向状态</p>
<p>对象头格式</p>
<p>biased_lock：1 表示偏向状态。默认开启</p>
<p>image-20210808172019584</p>
<p>1个对象创建时：<br>
如果开启了偏向锁（默认开启），那么对象创建后，markword值为0x05即最后3位为101，这时它的thread. epoch. age都为0</p>
<p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数- xX：BiasedLockingStartupDelay=0来禁用延迟</p>
<p>如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后3位为001，这时它的hashcode、age 都为0，第一次用到hashcode时才会赋值</p>
<p>image-20210808175029112</p>
<p>3）测试禁用<br>
在上面测试代码运行时在添加VM参数-xX：-UseBiasedLocking禁用偏向锁</p>
<p>4）测试hashCode</p>
<p>public static void main(String[] args) {<br>
Dog dog = new Dog();<br>
// 打印hashcode以后，偏向锁会关闭，因为在开启偏向锁状态的时候 ，没有地方存hashcode，所以只能是未开启偏向状态才能存储hashcode<br>
dog.hashCode();<br>
log.info(&quot;加锁前，{}&quot;, ClassLayout.parseInstance(dog).toPrintable());<br>
4.6 wait/notify</p>
<p>为什么需要wait/notify？</p>
<p>image-20210815111733460</p>
<p>image-20210815111826451</p>
<p>原理之notify/wait</p>
<p>image-20210815111948526</p>
<p>API介绍</p>
<p>所有的前提条件：拿到的都是同一个对象锁</p>
<p>object.wait(); 进入waitset中等待唤醒</p>
<p>object.wait(2); 进入waitset中等待唤醒，如果到了2s中还是没有唤醒，就不再等待，继续执行操作</p>
<p>object.notify();唤醒waitSet中的某一个线程</p>
<p>object.notifyAll();唤醒waitSet中的所有的线程</p>
<p>private static Object object = new Object();</p>
<pre><code>public static void main(String[] args) {
    new Thread(() -&gt; {
        log.info(&quot;t1开始了&quot;);
        synchronized (object) {
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info(&quot;t1开始其他了&quot;);
        }
    }, &quot;t1&quot;).start();


    new Thread(() -&gt; {
        log.info(&quot;t2开始了&quot;);
        synchronized (object) {
            try {
                // 进入等待
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info(&quot;t2开始其他了&quot;);
        }
    }, &quot;t2&quot;).start();

    try {
        TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    synchronized (object) {
        // 唤醒waitSet中的某一个
</code></pre>
<p>//            object.notify();<br>
// 唤醒waitSet中的所有的<br>
object.notifyAll();<br>
}</p>
<pre><code>}
</code></pre>
<p>4.7 wait/notify的正确姿势</p>
<p>sleep和wait的区别</p>
<p>wait是Object的防范，sleep是Thread的静态方法</p>
<p>wait需要和synchronized一起使用，必须要获得对象锁，sleep不需要强制和synchronize一起使用</p>
<p>wait的时候会释放对象锁，sleep在睡眠的时候不会释放对象锁</p>
<p>他们的状态都是TIMED_WAITING</p>
<p>Step1</p>
<p>上述故事开始第一步</p>
<p>static final Object OBJECT = new Object();<br>
static boolean hasCigarette = false;<br>
static boolean hasTokenTime = false;</p>
<pre><code>public static void main(String[] args) {
    new Thread(() -&gt; {
        synchronized (OBJECT){
            log.info(&quot;南开始干活儿&quot;);
            if (!hasCigarette) {
                log.info(&quot;没有烟不干活儿&quot;);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;有烟?，{}&quot;, hasCigarette);
            if (hasCigarette) {
                log.info(&quot;有烟开始干活儿&quot;);
            }
        }
    }, &quot;小南&quot;).start();

    for (int i = 0; i &lt; 5; i++) {
        synchronized (OBJECT){
            new Thread(()-&gt;{
                log.info(&quot;其他人开始干活儿&quot;);
            },&quot;其他人&quot;).start();
        }
    }
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    new Thread(()-&gt;{
        hasCigarette = true;
        log.info(&quot;送烟&quot;);
    },&quot;🚬&quot;).start();
}
</code></pre>
<p>问题：</p>
<p>小南没有烟的时候就会阻塞两秒，不管烟是两秒前送到还有两秒后送到，小南都要休眠2s</p>
<p>小南休息的时候，其他的线程也无法执行</p>
<p>解决办法：使用interrupt打断sleep 或者使用wait/notify</p>
<p>Step2</p>
<p>使用wait/notify</p>
<p>static final Object OBJECT = new Object();<br>
static boolean hasCigarette = false;<br>
static boolean hasTokenTime = false;</p>
<pre><code>public static void main(String[] args) {
    new Thread(() -&gt; {
        synchronized (OBJECT){
            log.info(&quot;南开始干活儿&quot;);
            if (!hasCigarette) {
                log.info(&quot;没有烟不干活儿&quot;);
                try {
                    OBJECT.wait(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;有烟?，{}&quot;, hasCigarette);
            if (hasCigarette) {
                log.info(&quot;有烟开始干活儿&quot;);
            }
        }
    }, &quot;小南&quot;).start();

    for (int i = 0; i &lt; 5; i++) {

        new Thread(()-&gt;{
            synchronized (OBJECT){
                log.info(&quot;其他人开始干活儿&quot;);
            }
        },&quot;其他人&quot;).start();
    }
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    new Thread(()-&gt;{
        synchronized (OBJECT){
            log.info(&quot;送烟&quot;);
            hasCigarette = true;
            OBJECT.notifyAll();
        }
    },&quot;🚬&quot;).start();
}
</code></pre>
<p>输出：</p>
<p>19:55:33.517 [小南] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 南开始干活儿<br>
19:55:33.521 [小南] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 没有烟不干活儿<br>
19:55:33.522 [其他人] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 其他人开始干活儿<br>
19:55:33.523 [其他人] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 其他人开始干活儿<br>
19:55:33.523 [其他人] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 其他人开始干活儿<br>
19:55:33.524 [其他人] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 其他人开始干活儿<br>
19:55:33.524 [其他人] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 其他人开始干活儿<br>
19:55:34.528 [🚬] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 送烟<br>
19:55:34.528 [小南] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 有烟?，true<br>
19:55:34.530 [小南] INFO com.example.heimajuc.demo.demo1UserWaitNotify - 有烟开始干活儿<br>
解决其他干活的线程阻塞问题</p>
<p>但是如果其他线程也有等待条件呢？？</p>
<p>Step3</p>
<p>OBJECT.notify(); 是随机叫醒线程</p>
<p>static final Object OBJECT = new Object();<br>
static boolean hasCigarette = false;<br>
static boolean hasTokenTime = false;</p>
<pre><code>// 虚假唤醒
public static void main(String[] args) {
    new Thread(() -&gt; {
        synchronized (OBJECT){
            log.info(&quot;南开始干活儿&quot;);
            if (!hasCigarette) {
                log.info(&quot;没有烟不干活儿&quot;);
                try {
                    OBJECT.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;有烟?，{}&quot;, hasCigarette);
            if (hasCigarette) {
                log.info(&quot;有烟开始干活儿&quot;);
            }
        }
    }, &quot;小南&quot;).start();
    new Thread(() -&gt; {
        synchronized (OBJECT){
            log.info(&quot;女开始干活儿&quot;);
            if (!hasTokenTime) {
                log.info(&quot;没有外卖不干活儿&quot;);
                try {
                    OBJECT.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;有外卖他？？，{}&quot;, hasTokenTime);
            if (hasTokenTime) {
                log.info(&quot;有外卖开始干活儿&quot;);
            }
        }
    }, &quot;小女&quot;).start();



    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    new Thread(()-&gt;{
        synchronized (OBJECT){
            log.info(&quot;送外卖&quot;);
            hasTokenTime = true;
            OBJECT.notify();
            OBJECT.notifyAll();
        }
    },&quot;🥡&quot;).start();
}
</code></pre>
<p>如何解决虚假唤醒线程？</p>
<p>使用notifyAll可以叫醒所有的wait线程</p>
<p>但是if加wait只有一次机会，如果唤醒的时候，条件没有达到，那么这个线程就结束了，不符合预期，必须是等待状态</p>
<p>Step4</p>
<p>解决办法是用while+wait解决问题，如果条件没有达到，那么就一直等待</p>
<p>new Thread(() -&gt; {<br>
synchronized (OBJECT){<br>
log.info(&quot;南开始干活儿&quot;);<br>
while (!hasCigarette) {<br>
log.info(&quot;没有烟不干活儿&quot;);<br>
try {<br>
OBJECT.wait();<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
log.info(&quot;有烟?，{}&quot;, hasCigarette);<br>
if (hasCigarette) {<br>
log.info(&quot;有烟开始干活儿&quot;);<br>
}<br>
}<br>
}, &quot;小南&quot;).start();<br>
总结：正确姿势</p>
<p>synchronized(LOCK){<br>
// 线程1<br>
while(条件不成立){<br>
LOCK.wait();<br>
}<br>
// 条件成立，去干活儿<br>
}</p>
<p>// 线程2<br>
synchronized(LOCK){<br>
// 条件成立 唤醒操作<br>
LOCK.notifyAll();<br>
}<br>
模式之保护性暂停 -&gt;模式篇md</p>
<p>4.8 Park和UnPark的使用</p>
<p>基本使用</p>
<p>LockSupport.park();<br>
LockSupport.unpark(thread);<br>
Demo</p>
<p>@Slf4j<br>
public class ParkAndUnPark {</p>
<pre><code>public static void main(String[] args) {

    Thread thread = new Thread(() -&gt; {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&quot;开始park&quot;);
        LockSupport.park();
        log.info(&quot;开始resume&quot;);
    }, &quot;线程1&quot;);

    thread.start();

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.info(&quot;开始unpark&quot;);
    LockSupport.unpark(thread);
}
</code></pre>
<p>}<br>
输出：</p>
<p>17:12:34.654 [main] INFO com.example.heimajuc.park2demo.ParkAndUnPark - 开始unpark<br>
17:12:35.645 [线程1] INFO com.example.heimajuc.park2demo.ParkAndUnPark - 开始park<br>
17:12:35.645 [线程1] INFO com.example.heimajuc.park2demo.ParkAndUnPark - 开始resume<br>
特点：与notifyAll、wait的区别</p>
<p>wait，notify和notifyAll必须配合Object Monitor 一起使用，而park，unpark不必</p>
<p>park &amp; unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</p>
<p>park &amp; unpark可以先unpark，而wait &amp; notify不能先notify</p>
<p>原理</p>
<p>每个线程都有自己的一个Parker对象，由三部分组成counter，cond和_mutex打个比喻</p>
<p>线程就像一个旅人，Parker就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter就好比背包中的备用干粮（0为耗尽，1为充足）</p>
<p>调用park就是要看需不需要停下来歇息<br>
1、如果备用干粮耗尽，那么钻进帐篷歇息</p>
<p>2、如果备用干粮充足，那么不需停留，继续前进</p>
<p>调用unpark，就好比令干粮充足<br>
1、如果这时线程还在帐篷，就唤醒让他继续前进<br>
2、如果这时线程还在运行，那么下次他调用park时，仅是消耗掉备用干粮，不需停留继续前进<br>
a、因为背包空间有限，多次调用unpark仅会补充一份备用干粮</p>
<p>图解：</p>
<p>image-20210829172232556</p>
<p>1.当前线程调用Unsafe.park()方法<br>
2.检查counter，本情况为0，这时，获得mutex互斥锁<br>
3.线程进入cond条件变量阻塞<br>
4.设置counter=0</p>
<p>image-20210829223727960</p>
<p>调用Unsafe.unpark（Thread_0）方法，设置_counter为1</p>
<p>唤醒_cond条件变量中的Thread_0</p>
<p>Thread_O恢复运行</p>
<p>设置_counter为0</p>
<p>image-20210829223620343</p>
<p>1.调用Unsafe.unpark（Thread_0）方法，设置counter为1<br>
2.当前线程调用Unsafe.park（）方法<br>
3.检查counter，本情况为1，这时线程无需阻塞，继续运行<br>
4.设置_counter为0</p>
<p>4.10 重新理解线程状态转换</p>
<p>image-20210829224618064</p>
<p>情况1 NEW-&gt;RUNNABLE</p>
<p>new Thread().start();</p>
<p>情况2 RUNNABLE&lt;---&gt;WAITING</p>
<p>t线程 synchronized(obj) 获取了对象锁以后</p>
<p>调用obj.wait(); ,t线程就会从RUNNABLE-&gt;WAITING</p>
<p>当obj.notifyAll(); 会出现两种情况</p>
<p>竞争锁成功，t线程从WAITING-&gt;RUNNING</p>
<p>竞争锁失败，t线程从WAITING-&gt;BLOCKED</p>
<p>image-20210920215318339</p>
<p>image-20210920215532572</p>
<p>代码CODE：</p>
<p>public class TestWaitNotify {</p>
<pre><code>private static Object object = new Object();

public static void main(String[] args) {
    new Thread(() -&gt; {
        log.info(&quot;t1线程开始&quot;);
        try {
            synchronized (object) {
                object.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&quot;t1线程开结束&quot;);
    }, &quot;t1&quot;).start();
    new Thread(() -&gt; {
        log.info(&quot;t2线程开始&quot;);
        try {
            synchronized (object) {
                object.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info(&quot;t2线程开结束&quot;);
    }, &quot;t2&quot;).start();

    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    synchronized (object) {
        // 唤醒waitSet中的某一个
</code></pre>
<p>//            object.notify();<br>
// 唤醒waitSet中的所有的<br>
object.notifyAll();<br>
}<br>
}<br>
}<br>
情况3 RUNNABLE&lt;---&gt;WAITING</p>
<p>当前线程调用 t.join()方法时，当前线程从Runnable--&gt;Waiting</p>
<p>注意是当前线程在t线程对象的监视器上等待</p>
<p>t线程运行结束后，或者调用了当前线程的interrupt()方法的时候，当前线程是从Waiting--&gt;Runnable</p>
<p>情况4 WAITING&lt;---&gt;RUNNABLE</p>
<p>当前线程调用LockSupport.park()方法的时候，当前线程会从RUNNABLE--&gt;WAITING</p>
<p>当前线程调用unpark(目标线程)方法的时候，或者调用了interrupt方法的时候，会让目标线程的状态从WAITING--&gt;RUNNABLE</p>
<p>情况5 RUNNABLE&lt;---&gt;TIME_WAITING</p>
<p>t线程获得对象锁sychronized(obj)的时候</p>
<p>当前线程调用 obj.wait(long n)方法时，当前线程从Runnable--&gt;TIME_Waiting</p>
<p>t线程等待时间超过n秒以后，或者调用了obj.notify(),obj.notifyAll()方法后，或者调用了t.interrupt()方法后</p>
<p>竞争锁成功，t线程从TIME_WAITING---&gt;RUNNABLE</p>
<p>竞争锁失败，t线程从TIME_WAITING---&gt;BLOCKED</p>
<p>情况6 RUNNABLE&lt;---&gt;TIME_WAITING</p>
<p>当前线程调用 t.join(long n)方法时，当前线程从RUNNABLE--&gt;TIME_WAITING</p>
<p>注意是当前线程在t线程对象的监视器上等待</p>
<p>当前线程等待时间超过n毫秒以后，或者t线程验证结束后，或者调用当前线程的interrupt()方法后，当前线程从TIME_WAITING---&gt;RUNNABLE</p>
<p>情况7 RUNNABLE&lt;---&gt;TIME_WAITING</p>
<p>当前线程调用 LockSupport.parkNanos(long nanos)方法时，或者当前线程调用了LockSupport.parkUntil(long deadline)时，当前线程从RUNNABLE--&gt;TIME_WAITING</p>
<p>当前线程等待时间超过n毫秒以后，或者等待超时，或者当前线程调用unpark(目标线程)方法的时候，或者调用了interrupt方法的时候，会让目标线程的状态从TIME_WAITING---&gt;RUNNABLE</p>
<p>情况8 RUNNABLE&lt;---&gt;TIME_WAITING</p>
<p>当前线程调用 Thread.sleep(long ms)方法时，当前线程从RUNNABLE--&gt;TIME_WAITING</p>
<p>当前线程等待时间超过n毫秒以后，或者等待超时，或者当前线程调用unpark(目标线程)方法的时候，或者调用了interrupt方法的时候，会让目标线程的状态从TIME_WAITING---&gt;RUNNABLE</p>
<p>情况9 RUNNABLE&lt;---&gt;BLOCKED</p>
<p>T1线程在使用synchronize(obj)竞争锁的时候，如果竞争锁失败，T1线程就从RUNNABLE--&gt;BLOCKED</p>
<p>持有OBJ锁线程的同步代码块执行完毕后，会唤醒该对象上所有BLOCKED的线程全部重新竞争锁，如果竞争到了，就会从BLOCKED变成RUNNABLE，其他失败的线程依然是BLOCKED状态。</p>
<p>情况10 RUNNABLE&lt;---&gt;TERMINATE</p>
<p>当前线程运行结束以后，当前线程从RUNNABLE--&gt;TERMINATE</p>
<p>4.11 多把锁🔒</p>
<p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低解决方法是准备多个房间（多个对象锁）</p>
<p>@Slf4j<br>
public class MoreLockDemo {</p>
<pre><code>public static void main(String[] args) {
    BigRoom bigRoom = new BigRoom();
    new Thread(() -&gt; {
        bigRoom.sleep();
    }, &quot;线程1&quot;).start();
    new Thread(() -&gt; {
        bigRoom.study();
    }, &quot;线程2&quot;).start();
}
</code></pre>
<p>}</p>
<p>@Slf4j<br>
class BigRoom {<br>
private final Object obj = new Object();</p>
<pre><code>public void sleep() {
    synchronized (obj) {
        log.info(&quot;开始睡觉&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public void study() {
    synchronized (obj) {
        log.info(&quot;开始学习&quot;);
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>}<br>
输出结果，并发不高</p>
<p>15:01:43.777 [线程1] INFO com.example.heimajuc.demo.BigRoom - 开始睡觉<br>
15:01:44.780 [线程2] INFO com.example.heimajuc.demo.BigRoom - 开始学习<br>
采用多把锁，控制，提高并发</p>
<p>@Slf4j<br>
class BigRoom {<br>
private final Object sleep = new Object();<br>
private final Object study = new Object();</p>
<pre><code>public void sleep() {
    synchronized (sleep) {
        log.info(&quot;开始睡觉&quot;);
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public void study() {
    synchronized (study) {
        log.info(&quot;开始学习&quot;);
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>}<br>
输出结果：</p>
<p>15:02:06.507 [线程2] INFO com.example.heimajuc.demo.BigRoom - 开始学习<br>
15:02:06.507 [线程1] INFO com.example.heimajuc.demo.BigRoom - 开始睡觉<br>
将锁的粒度细分：</p>
<p>好处，会增加并发度</p>
<p>好处，如果一个线程需要同时获得多把锁，就容易发生死锁</p>
<p>4.12 活跃度</p>
<p>死锁</p>
<p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<p>t1线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2线程获得B对象锁，接下来想获取A对象的锁</p>
<p>demo：</p>
<p>public static void main(String[] args) {<br>
Object o1 = new Object();<br>
Object o2 = new Object();<br>
new Thread(() -&gt; {<br>
synchronized (o1) {<br>
log.info(&quot;t1---info&quot;);<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
synchronized (o2) {<br>
log.info(&quot;111&quot;);<br>
}<br>
}<br>
}, &quot;t1&quot;).start();</p>
<pre><code>    new Thread(() -&gt; {
        synchronized (o2) {
            log.info(&quot;t2---info&quot;);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1) {
                log.info(&quot;222&quot;);
            }
        }
    }, &quot;t2&quot;).start();

}
</code></pre>
<p>定位死锁</p>
<p>检测死锁可以使用jconsole工具，或者使用jps定位进程id，再用jstack定位死锁：</p>
<p>jps定位进程id:</p>
<p>➜  heima-juc git:(master) ✗ jps<br>
90551 RemoteMavenServer36<br>
91065 TestDeadLock<br>
91064 Launcher<br>
17806 IptiqLixApp<br>
23167<br>
91102 Jps<br>
用jstack定位死锁:</p>
<p>➜  heima-juc git:(master) ✗ jstack 91065</p>
<p>&quot;t2&quot; #11 prio=5 os_prio=31 tid=0x00007fbd730fe000 nid=0x3a03 waiting for monitor entry [0x00007000088ff000]<br>
java.lang.Thread.State: BLOCKED (on object monitor)<br>
at com.example.heimajuc.demo.TestDeadLock.lambda$main<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>(</mo><mi>T</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>L</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mo>:</mo><mn>42</mn><mo>)</mo><mo>−</mo><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo>&lt;</mo><mn>0</mn><mi>x</mi><mn>000000076</mn><mi>b</mi><mn>3753</mn><mi>a</mi><mn>8</mn><mo>&gt;</mo><mo>(</mo><mi>a</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>d</mi><mo>&lt;</mo><mn>0</mn><mi>x</mi><mn>000000076</mn><mi>b</mi><mn>3753</mn><mi>b</mi><mn>8</mn><mo>&gt;</mo><mo>(</mo><mi>a</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mi>a</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>e</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>j</mi><mi>u</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>T</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>L</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1(TestDeadLock.java:42)
        - waiting to lock &lt;0x000000076b3753a8&gt; (a java.lang.Object)
        - locked &lt;0x000000076b3753b8&gt; (a java.lang.Object)
        at com.example.heimajuc.demo.TestDeadLock</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mord">7</span><span class="mord">5</span><span class="mord">3</span><span class="mord mathdefault">a</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mord">7</span><span class="mord">5</span><span class="mord">3</span><span class="mord mathdefault">b</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>$Lambda$2/2110121908.run(Unknown Source)<br>
at java.lang.Thread.run(Thread.java:748)</p>
<p>&quot;t1&quot; #10 prio=5 os_prio=31 tid=0x00007fbd730ae800 nid=0x3903 waiting for monitor entry [0x00007000087fc000]<br>
java.lang.Thread.State: BLOCKED (on object monitor)<br>
at com.example.heimajuc.demo.TestDeadLock.lambda$main<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>(</mo><mi>T</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>L</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mo>:</mo><mn>28</mn><mo>)</mo><mo>−</mo><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo>&lt;</mo><mn>0</mn><mi>x</mi><mn>000000076</mn><mi>b</mi><mn>3753</mn><mi>b</mi><mn>8</mn><mo>&gt;</mo><mo>(</mo><mi>a</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>d</mi><mo>&lt;</mo><mn>0</mn><mi>x</mi><mn>000000076</mn><mi>b</mi><mn>3753</mn><mi>a</mi><mn>8</mn><mo>&gt;</mo><mo>(</mo><mi>a</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mi>a</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>e</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>j</mi><mi>u</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi mathvariant="normal">.</mi><mi>T</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>L</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">0(TestDeadLock.java:28)
        - waiting to lock &lt;0x000000076b3753b8&gt; (a java.lang.Object)
        - locked &lt;0x000000076b3753a8&gt; (a java.lang.Object)
        at com.example.heimajuc.demo.TestDeadLock</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mord">7</span><span class="mord">5</span><span class="mord">3</span><span class="mord mathdefault">b</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mord">6</span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mord">7</span><span class="mord">5</span><span class="mord">3</span><span class="mord mathdefault">a</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>$Lambda$1/231685785.run(Unknown Source)<br>
at java.lang.Thread.run(Thread.java:748)<br>
使用jconsole检测死锁以及定位死锁</p>
<p>image-20211031115537515</p>
<p>image-20211031115605879</p>
<p>哲学家就餐问题</p>
<p>image-20211031115720369</p>
<p>有五位哲学家，围坐在圆桌旁。</p>
<p>■他们只做两件事，思考和吃饭，思考一-会吃口饭，吃完饭后接着思考。</p>
<p>■吃饭时要用两根筷子吃，桌上共有5根筷子，每位哲学家左右手边各有一根筷子。</p>
<p>■如果筷子被身边的人拿着，自己就得等待</p>
<p>问题：如果每个人都拿起了一个筷子，那么就是死锁了，所有人都在等待</p>
<p>Code:</p>
<p>@Slf4j<br>
public class PhilosophersEatProblem {</p>
<pre><code>public static void main(String[] args) {

    Chopsticks chopsticks1 = new Chopsticks(&quot;1&quot;);
    Chopsticks chopsticks2 = new Chopsticks(&quot;2&quot;);
    Chopsticks chopsticks3 = new Chopsticks(&quot;3&quot;);
    Chopsticks chopsticks4 = new Chopsticks(&quot;4&quot;);
    Chopsticks chopsticks5 = new Chopsticks(&quot;5&quot;);
    new Philosophers(&quot;苏格拉底&quot;, chopsticks1, chopsticks2).start();
    new Philosophers(&quot;柏拉图&quot;, chopsticks2, chopsticks3).start();
    new Philosophers(&quot;亚里士多德&quot;, chopsticks3, chopsticks4).start();
    new Philosophers(&quot;张三&quot;, chopsticks4, chopsticks5).start();
    new Philosophers(&quot;里斯&quot;, chopsticks5, chopsticks1).start();

}
</code></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>
<p>@author JackGao</p>
</li>
<li>
<p>@since 2021/10/31</p>
</li>
<li>
<p>desc: 哲学家类<br>
*/<br>
@EqualsAndHashCode(callSuper = true)<br>
@Data<br>
@Slf4j<br>
class Philosophers extends Thread {</p>
<p>Chopsticks left;<br>
Chopsticks right;</p>
<p>public Philosophers(String name, Chopsticks left, Chopsticks right) {<br>
super(name);<br>
this.left = left;<br>
this.right = right;<br>
}</p>
<p>@Override<br>
public void run() {<br>
while (true) {<br>
synchronized (left) {<br>
synchronized (right) {<br>
eat();<br>
}<br>
}<br>
}</p>
<p>}</p>
<p>private void eat() {<br>
log.info(&quot;eating...&quot;);<br>
// 思考问题。。。。。。<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>@author JackGao</li>
<li>@since 2021/10/31</li>
<li>
<p>
</li>
<li>desc:筷子</li>
<li>
</p>
</li>
</ul>
<p>*/<br>
@Data<br>
class Chopsticks {</p>
<pre><code>String name;

public Chopsticks(String name) {
    this.name = name;
}

@Override
public String toString() {
    return &quot;Chopsticks{&quot; +
            &quot;name='&quot; + name + '\'' +
            '}';
}
</code></pre>
<p>}</p>
<p>console result：</p>
<p>14:26:20.360 [亚里士多德] INFO com.example.heimajuc.demo.Philosophers - eating...<br>
14:26:21.361 [柏拉图] INFO com.example.heimajuc.demo.Philosophers - eating...<br>
14:26:22.362 [柏拉图] INFO com.example.heimajuc.demo.Philosophers - eating...<br>
14:26:23.366 [柏拉图] INFO com.example.heimajuc.demo.Philosophers - eating...<br>
14:26:24.366 [柏拉图] INFO com.example.heimajuc.demo.Philosophers - eating...<br>
使用jconsole查看结果：发现产生了死锁</p>
<p>image-20211101143339725</p>
<p>活锁</p>
<p>活锁出现在两个线程互相改变了对方的结束条件，最后谁也无法结束，例如</p>
<p>code：</p>
<p>@Slf4j<br>
public class LiveLockDemo {<br>
static volatile int COUNT = 10;<br>
static final Object OBJECT = new Object();</p>
<pre><code>public static void main(String[] args) {
    new Thread(() -&gt; {
        while (COUNT &gt; 0) {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            COUNT--;
            log.info(&quot;count,{}&quot;, COUNT);
        }
    }, &quot;t1&quot;).start();

    new Thread(() -&gt; {
        while (COUNT &lt; 20) {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            COUNT++;
            log.info(&quot;count,{}&quot;, COUNT);
        }
    }, &quot;t2&quot;).start();
}
</code></pre>
<p>}<br>
console result：</p>
<p>14:59:17.514 [t1] INFO com.example.heimajuc.demo.LiveLockDemo - count,10<br>
14:59:18.520 [t1] INFO com.example.heimajuc.demo.LiveLockDemo - count,10<br>
14:59:18.520 [t2] INFO com.example.heimajuc.demo.LiveLockDemo - count,10<br>
14:59:19.520 [t2] INFO com.example.heimajuc.demo.LiveLockDemo - count,10<br>
14:59:19.520 [t1] INFO com.example.heimajuc.demo.LiveLockDemo - count,9<br>
14:59:20.524 [t2] INFO com.example.heimajuc.demo.LiveLockDemo - count,11<br>
14:59:20.524 [t1] INFO com.example.heimajuc.demo.LiveLockDemo - count,11<br>
解决办法：使两个线程的执行时间有交错，就可以避免或者增加随机睡眠时间</p>
<p>饥饿</p>
<p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到CPU调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题<br>
下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题</p>
<p>image-20211101150501490</p>
<p>顺序加锁的解决方案：</p>
<p>image-20211101150523056</p>
<p>4.13 ReentrantLock</p>
<p>reentrant 重入  reentrantLock 可以重入锁<br>
相对于synchronized它具备如下特点，</p>
<p>可中断</p>
<p>可以设置超时时间</p>
<p>可以设置为公平锁</p>
<p>支持多个条件变量</p>
<p>与synchronized一样，都支持可重入</p>
<p>基本语法：</p>
<p>// 获取锁<br>
reentrantLock.lock();<br>
try {<br>
// 临界区<br>
}finally {<br>
reentrantLock.unlock();<br>
}<br>
可重入锁</p>
<p>可重入：是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁<br>
如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<p>code：</p>
<p>@Slf4j<br>
public class ReentrantLockDemo {<br>
private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();</p>
<pre><code>public static void main(String[] args) {

    REENTRANT_LOCK.lock();
    try {
        // 临界区
        log.info(&quot;main&quot;);
        m1();
    } finally {
        REENTRANT_LOCK.unlock();
    }

}

private static void m1() {
    REENTRANT_LOCK.lock();
    try {
        // 临界区
        log.info(&quot;m1&quot;);
        m2();
    } finally {
        REENTRANT_LOCK.unlock();
    }
}

private static void m2() {
    REENTRANT_LOCK.lock();
    try {
        // 临界区
        log.info(&quot;m2&quot;);
    } finally {
        REENTRANT_LOCK.unlock();
    }
}
</code></pre>
<p>}<br>
console result：</p>
<p>15:50:51.472 [main] INFO com.example.heimajuc.demo.ReentrantLockDemo - main<br>
15:50:51.479 [main] INFO com.example.heimajuc.demo.ReentrantLockDemo - m1<br>
15:50:51.479 [main] INFO com.example.heimajuc.demo.ReentrantLockDemo - m2<br>
可打断</p>
<p>synchronize不能被打断，获取到锁了，就是获取到锁了，但是reentrantLock可以被打断</p>
<p>code：</p>
<p>@Slf4j<br>
public class ReentrantLock_interruptDemo {<br>
private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();</p>
<pre><code>public static void main(String[] args) {

    Thread thread = new Thread(() -&gt; {
        try {
            log.info(&quot;尝试获取锁&quot;);
            REENTRANT_LOCK.lockInterruptibly();
        } catch (InterruptedException e) {
            log.info(&quot;被打断&quot;);
            e.printStackTrace();
            // 如果被打断  没有return返回 那么会继续往下走 重
            log.info(&quot;1、解锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
            return;
        }
        try {
            log.info(&quot;获取到锁&quot;);
            log.info(&quot;2、解锁了吗?，{}&quot;, REENTRANT_LOCK.isLocked());
        } finally {
            REENTRANT_LOCK.unlock();
            log.info(&quot;3、解锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
        }
    });

    REENTRANT_LOCK.lock();
    thread.start();
    log.info(&quot;打断thread线程&quot;);
    thread.interrupt();
    log.info(&quot;4、解锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
</code></pre>
<p>//        REENTRANT_LOCK.unlock();<br>
//        log.info(&quot;5、解锁了吗？，{}&quot;,REENTRANT_LOCK.isLocked());<br>
}<br>
}<br>
？？？如果线程执行完毕，没有释放锁。。咋办？？</p>
<p>锁超时</p>
<p>立即释放锁，如果获取不到锁就结束</p>
<p>REENTRANT_LOCK.tryLock()<br>
demo：</p>
<p>@Slf4j<br>
public class ReentrantLock_TimeOutDemo {<br>
private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();</p>
<pre><code>public static void main(String[] args) {

    Thread thread = new Thread(() -&gt; {
        log.info(&quot;尝试获取到锁&quot;);
        if (!REENTRANT_LOCK.tryLock()) {
            log.info(&quot;获取不到锁&quot;);
            log.info(&quot;1、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
            // 结束
            return;
        }
        try {
            log.info(&quot;获取到了锁&quot;);
        } finally {
            REENTRANT_LOCK.unlock();
            log.info(&quot;3、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
        }
    });
    REENTRANT_LOCK.lock();
    thread.start();
    log.info(&quot;2、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
}
</code></pre>
<p>}<br>
特定时间拿不到锁后，就结束</p>
<p>REENTRANT_LOCK.tryLock(2, TimeUnit.SECONDS)<br>
demo：</p>
<p>@Slf4j<br>
public class ReentrantLock_HasTimeOutDemo {<br>
private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();</p>
<pre><code>public static void main(String[] args) {

    Thread thread = new Thread(() -&gt; {
        log.info(&quot;尝试获取到锁&quot;);
        try {
            if (!REENTRANT_LOCK.tryLock(2, TimeUnit.SECONDS)) {
                log.info(&quot;获取不到锁&quot;);
                log.info(&quot;1、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
                // 结束
                return;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
            log.info(&quot;获取到了锁&quot;);
        } finally {
            log.info(&quot;3、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
            REENTRANT_LOCK.unlock();
        }
    },&quot;t1&quot;);
    REENTRANT_LOCK.lock();
    thread.start();
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.info(&quot;主线程释放锁&quot;);
    REENTRANT_LOCK.unlock();
    log.info(&quot;2、被锁了吗？，{}&quot;, REENTRANT_LOCK.isLocked());
}
</code></pre>
<p>}<br>
锁公平</p>
<p>ReentrantLock默认是不公平的</p>
<p>源码：是不公平的</p>
<pre><code>/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p>公平锁一般没必要设置，使用公平锁一般会降低并发。</p>
<p>条件变量</p>
<p>synchronized中也有条件变量，就是我们讲原理时那个waitSet休息室，当条件不满足时进入waitSet等待<br>
ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的，这就好比：</p>
<p>synchronized是那些不满足条件的线程都在一间休息室等消息。</p>
<p>而ReentrantLock支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</p>
<p>使用流程：</p>
<p>await前需要获得锁</p>
<p>await执行后，会释放锁，进入conditionObject等待</p>
<p>await的线程被唤醒（或打断、或超时）取重新竞争lock锁</p>
<p>竞争lock锁成功后，从await后继续执行</p>
<p>Code template:</p>
<p>送验送外卖案例：</p>
<p>@Slf4j<br>
public class ReentrantLock_ConditionDemo1 {<br>
private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();<br>
static boolean HAS_CIGARETTE_WAIT = false;<br>
static boolean HAS_TAKEOUT_WAIT = false;<br>
static Condition waitCigaretteRoom = REENTRANT_LOCK.newCondition();<br>
static Condition waitTakeoutRoom = REENTRANT_LOCK.newCondition();</p>
<pre><code>public static void main(String[] args) throws InterruptedException {


    new Thread(() -&gt; {
        REENTRANT_LOCK.lock();
        try {
            while (!HAS_CIGARETTE_WAIT) {
                log.info(&quot;没有烟，休息一会儿&quot;);
                // 去等烟休息室内等会儿
                try {
                    waitCigaretteRoom.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;有烟了，开始i干活活儿&quot;);
        } finally {
            REENTRANT_LOCK.unlock();
        }
    }, &quot;t1&quot;).start();


    new Thread(() -&gt; {
        REENTRANT_LOCK.lock();
        try {
            while (!HAS_TAKEOUT_WAIT) {
                log.info(&quot;没有🥡 外卖，休息一会儿&quot;);
                // 去等外卖室内等会儿
                try {
                    waitTakeoutRoom.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.info(&quot;外卖了，开始i干活活儿&quot;);
        } finally {
            REENTRANT_LOCK.unlock();
        }
    }, &quot;t2&quot;).start();


    TimeUnit.SECONDS.sleep(1);
    new Thread(() -&gt; {
        REENTRANT_LOCK.lock();
        try {
            log.info(&quot;开始之前送烟&quot;);
            HAS_CIGARETTE_WAIT = true;
            waitCigaretteRoom.signal();
        } finally {
            REENTRANT_LOCK.unlock();
        }
    }, &quot;t3&quot;).start();

    TimeUnit.SECONDS.sleep(1);
    new Thread(() -&gt; {
        REENTRANT_LOCK.lock();
        try {
            log.info(&quot;开始之前送外卖&quot;);
            HAS_TAKEOUT_WAIT = true;
            waitTakeoutRoom.signal();
        } finally {
            REENTRANT_LOCK.unlock();
        }
    }, &quot;t4&quot;).start();
}
</code></pre>
<p>}<br>
第四章总结</p>
<p>本章我们需要重点掌握的是：</p>
<p>分析多线程访问和共享资源时，哪些代码片段属于临界区</p>
<p>使用synchronized 互斥解决临界区的线程安全问题</p>
<p>掌握sychronized锁对象语法</p>
<p>掌握sychronized加载成员方法（this）和静态方法（class）语法</p>
<p>掌握wait/notify同步方法</p>
<p>使用lock互斥解决临界区的线程安全问题</p>
<p>掌握lock的使用细节：可打断、锁超时（超时释放）、公平锁、条件变量</p>
<p>学会分析变量的线程安全问题、掌握常见线程安全类的使用</p>
<p>了解线程活跃性问题：死锁、活锁、饥饿</p>
<p>应用方面</p>
<p>互斥：使用stnchronized或Lock达到共享资源互斥效果</p>
<p>同步：使用wait/notify或者Lock的条件变量来达到线程间通信问题</p>
<p>原理方面</p>
<p>monitor、sychronized、wait/notify原理</p>
<p>sychronized进阶原理</p>
<p>park &amp; unpark原理</p>
<p>模式方面</p>
<p>同步模式之保护性暂停</p>
<p>异步模式之生产者消费者</p>
<p>同步模式之顺序控制</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇淫技巧之IDEA]]></title>
        <id>https://WheatJack.github.io/post/idea-kuai-jie-jian-qi-yin-ji-qiao/</id>
        <link href="https://WheatJack.github.io/post/idea-kuai-jie-jian-qi-yin-ji-qiao/">
        </link>
        <updated>2022-01-05T06:29:35.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>Windows</th>
<th>Mac</th>
</tr>
</thead>
<tbody>
<tr>
<td>跳回上一个操作</td>
<td></td>
<td>common +[</td>
</tr>
<tr>
<td>跳回下一个操作</td>
<td></td>
<td>common +]</td>
</tr>
<tr>
<td>Go to implentation</td>
<td></td>
<td>command+option+B</td>
</tr>
<tr>
<td>File Structure</td>
<td></td>
<td>command +F12</td>
</tr>
<tr>
<td>Class</td>
<td></td>
<td>command+ option + U</td>
</tr>
<tr>
<td>Jump  to Source</td>
<td></td>
<td>F4</td>
</tr>
<tr>
<td>抽取var</td>
<td></td>
<td>ctrl+alt+v</td>
</tr>
<tr>
<td>find all structure</td>
<td></td>
<td>command+ F12</td>
</tr>
<tr>
<td>生成trycatch if 等等等</td>
<td></td>
<td>Ctrl+alt +t</td>
</tr>
<tr>
<td>查看对应的方法参数实现 (例如需要填写哪些参数)</td>
<td></td>
<td>Ctrl+P</td>
</tr>
</tbody>
</table>
<h1 id="好用的idea插件">好用的idea插件</h1>
<h3 id="1-codeglance-代码迷你缩放图插件"><strong>1、CodeGlance 代码迷你缩放图插件</strong></h3>
<h3 id="2-codota">2、<strong>Codota</strong></h3>
<h3 id="3-alibaba-cloud-toolkit快速部署到服务器">3、<strong>Alibaba Cloud Toolkit</strong>快速部署到服务器</h3>
<h3 id="4-jrebel-热加载插件">4、<strong>JRebel 热加载插件</strong></h3>
<h3 id="5-junitgenerator-自动生成测试代码">5、<strong>JUnitGenerator</strong>。自动生成测试代码。</h3>
<h3 id="6-mybatis-log-plugin-神级-根据执行sql-替换掉-显示完整-sql-直接复制粘贴到数据库-就可以执行">6、<strong>MyBatis Log Plugin 神级</strong> 根据执行sql 替换掉， 显示完整 sql, 直接复制粘贴到数据库 就可以执行</h3>
<h3 id="7-mybatiscodehelperpro-超级牛逼神级">7 、<strong>MyBatisCodeHelperPro 超级牛逼神级</strong></h3>
<h3 id="8-restfultoolkit-根据url-查找controller">8、<strong>RESTfultoolkit 根据url 查找controller</strong></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubernetes Note]]></title>
        <id>https://WheatJack.github.io/post/kubernetes-note/</id>
        <link href="https://WheatJack.github.io/post/kubernetes-note/">
        </link>
        <updated>2022-01-03T06:37:48.000Z</updated>
        <content type="html"><![CDATA[<p>Kubernetes</p>
<h1 id="1-kubernetes介绍">1. Kubernetes介绍</h1>
<h2 id="11-应用部署方式演变">1.1 应用部署方式演变</h2>
<p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li>
<p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li>
<p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li>
<p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gx13o92j30uw0bm0ui.jpg" alt="image-20200505183738289" loading="lazy"></figure>
<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gx67bbbj30gh07kjrg.jpg" alt="image-20200524150339551" loading="lazy"></figure>
<h2 id="12-kubernetes简介">1.2 kubernetes简介</h2>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gxa886fj30f107tt8y.jpg" alt="image-20200406232838722" loading="lazy"></figure>
<p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器----Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>
<p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<figure data-type="image" tabindex="4"><img src="Kubenetes.assets/image-20200526203726071-1626780706899.png" alt="image-20200526203726071" loading="lazy"></figure>
<h2 id="13-kubernetes组件">1.3 kubernetes组件</h2>
<p>一个kubernetes集群主要是由<strong>控制节点(master)</strong>、**工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gxcqsfij313w0kpwhr.jpg" alt="image-20200406184656917" loading="lazy"></figure>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li>
<p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li>
<p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li>
<p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li>
<p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li>
<p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li>
<p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>这样，外界用户就可以访问集群中的nginx服务了</p>
<h2 id="14-kubernetes概念">1.4 kubernetes概念</h2>
<p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>
<h1 id="2-kubernetes集群环境搭建">2. kubernetes集群环境搭建</h1>
<h2 id="21-前置知识点">2.1 前置知识点</h2>
<p>目前生产部署Kubernetes 集群主要有两种方式：</p>
<p><strong>kubeadm</strong></p>
<p>Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。</p>
<p>官方地址：https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</p>
<p><strong>二进制包</strong></p>
<p>从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。</p>
<p>Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gxhkbmzj30zv0e9wfx.jpg" alt="image-20200404094800622" loading="lazy"></figure>
<h2 id="22-kubeadm-部署方式介绍">2.2 kubeadm 部署方式介绍</h2>
<p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p>
<ul>
<li>创建一个Master 节点kubeadm init</li>
<li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li>
</ul>
<h2 id="23-安装要求">2.3 安装要求</h2>
<p>在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：</p>
<ul>
<li>一台或多台机器，操作系统CentOS7.x-86_x64</li>
<li>硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像</li>
<li>禁止swap 分区</li>
</ul>
<h2 id="24-最终目标">2.4 最终目标</h2>
<ul>
<li>在所有节点上安装Docker 和kubeadm</li>
<li>部署Kubernetes Master</li>
<li>部署容器网络插件</li>
<li>部署Kubernetes Node，将节点加入Kubernetes 集群中</li>
<li>部署Dashboard Web 页面，可视化查看Kubernetes 资源</li>
</ul>
<h2 id="25-准备环境">2.5 准备环境</h2>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gxkd984j30ie0cngmx.jpg" alt="image-20210609000002940" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">角色</th>
<th style="text-align:left">IP地址</th>
<th style="text-align:left">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">k8s-master01</td>
<td style="text-align:left">192.168.5.3</td>
<td style="text-align:left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td style="text-align:left">k8s-node01</td>
<td style="text-align:left">192.168.5.4</td>
<td style="text-align:left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td style="text-align:left">k8s-node02</td>
<td style="text-align:left">192.168.5.5</td>
<td style="text-align:left">docker，kubectl，kubeadm，kubelet</td>
</tr>
</tbody>
</table>
<h2 id="26-系统初始化">2.6 系统初始化</h2>
<h3 id="261-设置系统主机名以及-host-文件的相互解析">2.6.1 设置系统主机名以及 Host 文件的相互解析</h3>
<pre><code class="language-shell">hostnamectl set-hostname k8s-master01 &amp;&amp; bash
hostnamectl set-hostname k8s-node01 &amp;&amp; bash
hostnamectl set-hostname k8s-node02 &amp;&amp; bash
</code></pre>
<pre><code class="language-shell">cat &lt;&lt;EOF&gt;&gt; /etc/hosts
192.168.5.3     k8s-master01
192.168.5.4     k8s-node01
192.168.5.5     k8s-node02
EOF
</code></pre>
<pre><code class="language-shell">scp /etc/hosts root@192.168.5.4:/etc/hosts 
scp /etc/hosts root@192.168.5.5:/etc/hosts 
</code></pre>
<h3 id="262-安装依赖文件所有节点都要操作">2.6.2 安装依赖文件（所有节点都要操作）</h3>
<pre><code class="language-shell">yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git
</code></pre>
<h3 id="263-设置防火墙为-iptables-并设置空规则所有节点都要操作">2.6.3 设置防火墙为 Iptables 并设置空规则（所有节点都要操作）</h3>
<pre><code class="language-shell">systemctl stop firewalld &amp;&amp; systemctl disable firewalld

yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save
</code></pre>
<h3 id="264-关闭-selinux所有节点都要操作">2.6.4 关闭 SELINUX（所有节点都要操作）</h3>
<pre><code class="language-shell">swapoff -a &amp;&amp; sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

setenforce 0 &amp;&amp; sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config
</code></pre>
<h3 id="265-调整内核参数对于-k8s所有节点都要操作">2.6.5 调整内核参数，对于 K8S（所有节点都要操作）</h3>
<pre><code class="language-shell">modprobe br_netfilter

cat &lt;&lt;EOF&gt; kubernetes.conf 
net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
net.ipv4.tcp_tw_recycle=0
vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它
vm.overcommit_memory=1 # 不检查物理内存是否够用
vm.panic_on_oom=0 # 开启 OOM
fs.inotify.max_user_instances=8192
fs.inotify.max_user_watches=1048576
fs.file-max=52706963
fs.nr_open=52706963
net.ipv6.conf.all.disable_ipv6=1
net.netfilter.nf_conntrack_max=2310720
EOF

cp kubernetes.conf /etc/sysctl.d/kubernetes.conf

sysctl -p /etc/sysctl.d/kubernetes.conf
</code></pre>
<h3 id="266-调整系统时区所有节点都要操作">2.6.6 调整系统时区（所有节点都要操作）</h3>
<pre><code class="language-shell"># 设置系统时区为 中国/上海
timedatectl set-timezone Asia/Shanghai
# 将当前的 UTC 时间写入硬件时钟
timedatectl set-local-rtc 0
# 重启依赖于系统时间的服务
systemctl restart rsyslog
systemctl restart crond
</code></pre>
<h3 id="267-设置-rsyslogd-和-systemd-journald所有节点都要操作">2.6.7 设置 rsyslogd 和 systemd journald（所有节点都要操作）</h3>
<pre><code class="language-shell"># 持久化保存日志的目录
mkdir /var/log/journal 
mkdir /etc/systemd/journald.conf.d
cat &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;EOF
[Journal]
# 持久化保存到磁盘
Storage=persistent

# 压缩历史日志
Compress=yes

SyncIntervalSec=5m
RateLimitInterval=30s
RateLimitBurst=1000

# 最大占用空间 10G
SystemMaxUse=10G

# 单日志文件最大 200M
SystemMaxFileSize=200M

# 日志保存时间 2 周
MaxRetentionSec=2week

# 不将日志转发到 syslog
ForwardToSyslog=no
EOF

systemctl restart systemd-journald
</code></pre>
<h3 id="268-kube-proxy开启ipvs的前置条件所有节点都要操作">2.6.8 kube-proxy开启ipvs的前置条件（所有节点都要操作）</h3>
<pre><code class="language-shell">cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules 
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
EOF

chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4
</code></pre>
<h3 id="269-安装-docker-软件所有节点都要操作">2.6.9 安装 Docker 软件（所有节点都要操作）</h3>
<pre><code class="language-shell">yum install -y yum-utils device-mapper-persistent-data lvm2

yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

yum install -y docker-ce

## 创建 /etc/docker 目录
mkdir /etc/docker

cat &gt; /etc/docker/daemon.json &lt;&lt;EOF
{
&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],
&quot;log-driver&quot;: &quot;json-file&quot;,
&quot;log-opts&quot;: {
&quot;max-size&quot;: &quot;100m&quot;
}
}
EOF
mkdir -p /etc/systemd/system/docker.service.d
# 重启docker服务
systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker
</code></pre>
<p>上传文件到<code>/etc/yum.repos.d/</code>目录下，也可以 代替 <code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code> 命令</p>
<p>docker-ce.repo</p>
<pre><code class="language-shell">[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-stable-debuginfo]
name=Docker CE Stable - Debuginfo $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/stable
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-stable-source]
name=Docker CE Stable - Sources
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/stable
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-test]
name=Docker CE Test - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/test
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-test-debuginfo]
name=Docker CE Test - Debuginfo $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/test
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-test-source]
name=Docker CE Test - Sources
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/test
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-nightly]
name=Docker CE Nightly - $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/nightly
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-nightly-debuginfo]
name=Docker CE Nightly - Debuginfo $basearch
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/nightly
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg

[docker-ce-nightly-source]
name=Docker CE Nightly - Sources
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/nightly
enabled=0
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg
</code></pre>
<h3 id="2610-安装-kubeadm-所有节点都要操作">2.6.10 安装 Kubeadm （所有节点都要操作）</h3>
<pre><code class="language-shell">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF

yum install -y kubelet kubeadm kubectl &amp;&amp; systemctl enable kubelet
</code></pre>
<h2 id="27-部署kubernetes-master">2.7 部署Kubernetes Master</h2>
<h3 id="271-初始化主节点主节点操作">2.7.1 初始化主节点（主节点操作）</h3>
<pre><code class="language-shell">kubeadm init --apiserver-advertise-address=192.168.5.3 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.21.1 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16

mkdir -p $HOME/.kube

sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="272-加入主节点以及其余工作节点">2.7.2 加入主节点以及其余工作节点</h3>
<pre><code class="language-shell">kubeadm join 192.168.5.3:6443 --token h0uelc.l46qp29nxscke7f7 \
        --discovery-token-ca-cert-hash sha256:abc807778e24bff73362ceeb783cc7f6feec96f20b4fd707c3f8e8312294e28f 
</code></pre>
<h3 id="273-部署网络">2.7.3 部署网络</h3>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<p>下边是文件</p>
<pre><code class="language-yaml">---
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default
spec:
  privileged: false
  volumes:
  - configMap
  - secret
  - emptyDir
  - hostPath
  allowedHostPaths:
  - pathPrefix: &quot;/etc/cni/net.d&quot;
  - pathPrefix: &quot;/etc/kube-flannel&quot;
  - pathPrefix: &quot;/run/flannel&quot;
  readOnlyRootFilesystem: false
  # Users and groups
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: false
  defaultAllowPrivilegeEscalation: false
  # Capabilities
  allowedCapabilities: ['NET_ADMIN', 'NET_RAW']
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: false
  hostIPC: false
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  # SELinux
  seLinux:
    # SELinux is unused in CaaSP
    rule: 'RunAsAny'
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: flannel
rules:
- apiGroups: ['extensions']
  resources: ['podsecuritypolicies']
  verbs: ['use']
  resourceNames: ['psp.flannel.unprivileged']
- apiGroups:
  - &quot;&quot;
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - &quot;&quot;
  resources:
  - nodes
  verbs:
  - list
  - watch
- apiGroups:
  - &quot;&quot;
  resources:
  - nodes/status
  verbs:
  - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-system
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      &quot;name&quot;: &quot;cbr0&quot;,
      &quot;cniVersion&quot;: &quot;0.3.1&quot;,
      &quot;plugins&quot;: [
        {
          &quot;type&quot;: &quot;flannel&quot;,
          &quot;delegate&quot;: {
            &quot;hairpinMode&quot;: true,
            &quot;isDefaultGateway&quot;: true
          }
        },
        {
          &quot;type&quot;: &quot;portmap&quot;,
          &quot;capabilities&quot;: {
            &quot;portMappings&quot;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,
      &quot;Backend&quot;: {
        &quot;Type&quot;: &quot;vxlan&quot;
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds
  namespace: kube-system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/os
                operator: In
                values:
                - linux
      hostNetwork: true
      priorityClassName: system-node-critical
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni
        image: quay.io/coreos/flannel:v0.14.0
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.14.0
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
          limits:
            cpu: &quot;100m&quot;
            memory: &quot;50Mi&quot;
        securityContext:
          privileged: false
          capabilities:
            add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      volumes:
      - name: run
        hostPath:
          path: /run/flannel
      - name: cni
        hostPath:
          path: /etc/cni/net.d
      - name: flannel-cfg
        configMap:
          name: kube-flannel-cfg
</code></pre>
<h2 id="28-测试kubernetes-集群">2.8 测试kubernetes 集群</h2>
<h3 id="281-部署nginx-测试">2.8.1 部署nginx 测试</h3>
<pre><code class="language-shell">kubectl create deployment nginx --image=nginx

kubectl expose deployment nginx --port=80 --type=NodePort

kubectl get pod,svc
</code></pre>
<h1 id="3-资源管理">3. 资源管理</h1>
<h2 id="31-资源管理介绍">3.1 资源管理介绍</h2>
<p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p>
<blockquote>
<p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
<p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p>
<p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p>
<p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gxt7q4ij30xn0iewh5.jpg" alt="image-20200406225334627" loading="lazy"></figure>
<blockquote>
<p>学习kubernetes的核心，就是学习如何对集群上的<code>Pod、Pod控制器、Service、存储</code>等各种资源进行操作</p>
</blockquote>
<h2 id="32-yaml语言介绍">3.2 YAML语言介绍</h2>
<p>YAML是一个类似 XML、JSON 的标记性语言。它强调以<strong>数据</strong>为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称&quot;一种人性化的数据格式语言&quot;。</p>
<pre><code>&lt;heima&gt;
    &lt;age&gt;15&lt;/age&gt;
    &lt;address&gt;Beijing&lt;/address&gt;
&lt;/heima&gt;
</code></pre>
<pre><code>heima:
  age: 15
  address: Beijing
</code></pre>
<p>YAML的语法比较简单，主要有下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格( 低版本限制 )</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>'#'表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
</ul>
<pre><code># 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期
# 1 布尔类型
c1: true (或者True)
# 2 整型
c2: 234
# 3 浮点型
c3: 3.14
# 4 null类型 
c4: ~  # 使用~表示null
# 5 日期类型
c5: 2018-02-17    # 日期必须使用ISO 8601格式，即yyyy-MM-dd
# 6 时间类型
c6: 2018-02-17T15:02:31+08:00  # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区
# 7 字符串类型
c7: heima     # 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 
c8: line1
    line2     # 字符串过多的情况可以拆成多行，每一行会被转化成一个空格
</code></pre>
<pre><code># 对象
# 形式一(推荐):
heima:
  age: 15
  address: Beijing
# 形式二(了解):
heima: {age: 15,address: Beijing}
</code></pre>
<pre><code># 数组
# 形式一(推荐):
address:
  - 顺义
  - 昌平  
# 形式二(了解):
address: [顺义,昌平]
</code></pre>
<blockquote>
<p>小提示：</p>
<p>1 书写yaml切记<code>:</code> 后面要加一个空格</p>
<p>2 如果需要将多段yaml配置放在一个文件中，中间要使用<code>---</code>分隔</p>
<p>3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确</p>
<p>https://www.json2yaml.com/convert-yaml-to-json</p>
</blockquote>
<h2 id="33-资源管理方式">3.3 资源管理方式</h2>
<ul>
<li>
<p>命令式对象管理：直接使用命令去操作kubernetes资源</p>
<p><code>kubectl run nginx-pod --image=nginx:1.17.1 --port=80</code></p>
</li>
<li>
<p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</p>
<p><code>kubectl create/patch -f nginx-pod.yaml</code></p>
</li>
<li>
<p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</p>
<p><code>kubectl apply -f nginx-pod.yaml</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">操作对象</th>
<th style="text-align:left">适用环境</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">命令式对象管理</td>
<td style="text-align:left">对象</td>
<td style="text-align:left">测试</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td style="text-align:left">命令式对象配置</td>
<td style="text-align:left">文件</td>
<td style="text-align:left">开发</td>
<td style="text-align:left">可以审计、跟踪</td>
<td style="text-align:left">项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td style="text-align:left">声明式对象配置</td>
<td style="text-align:left">目录</td>
<td style="text-align:left">开发</td>
<td style="text-align:left">支持目录操作</td>
<td style="text-align:left">意外情况下难以调试</td>
</tr>
</tbody>
</table>
<h3 id="331-命令式对象管理">3.3.1 命令式对象管理</h3>
<p><strong>kubectl命令</strong></p>
<p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<pre><code>kubectl [command] [type] [name] [flags]
</code></pre>
<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p>
<p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p>
<p><strong>name</strong>：指定资源的名称，名称大小写敏感</p>
<p><strong>flags</strong>：指定额外的可选参数</p>
<pre><code class="language-shell"># 查看所有pod
kubectl get pod 

# 查看某个pod
kubectl get pod pod_name

# 查看某个pod,以yaml格式展示结果
kubectl get pod pod_name -o yaml
</code></pre>
<p><strong>资源类型</strong></p>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>
<pre><code>kubectl api-resources
</code></pre>
<p>经常使用的资源有下面这些：</p>
<table>
<thead>
<tr>
<th style="text-align:left">资源分类</th>
<th style="text-align:left">资源名称</th>
<th style="text-align:left">缩写</th>
<th style="text-align:left">资源作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">集群级别资源</td>
<td style="text-align:left">nodes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">集群组成部分</td>
</tr>
<tr>
<td style="text-align:left">namespaces</td>
<td style="text-align:left">ns</td>
<td style="text-align:left">隔离Pod</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">pod资源</td>
<td style="text-align:left">pods</td>
<td style="text-align:left">po</td>
<td style="text-align:left">装载容器</td>
</tr>
<tr>
<td style="text-align:left">pod资源控制器</td>
<td style="text-align:left">replicationcontrollers</td>
<td style="text-align:left">rc</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">replicasets</td>
<td style="text-align:left">rs</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">deployments</td>
<td style="text-align:left">deploy</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">daemonsets</td>
<td style="text-align:left">ds</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">jobs</td>
<td style="text-align:left"></td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cronjobs</td>
<td style="text-align:left">cj</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">horizontalpodautoscalers</td>
<td style="text-align:left">hpa</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">statefulsets</td>
<td style="text-align:left">sts</td>
<td style="text-align:left">控制pod资源</td>
</tr>
<tr>
<td style="text-align:left">服务发现资源</td>
<td style="text-align:left">services</td>
<td style="text-align:left">svc</td>
<td style="text-align:left">统一pod对外接口</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">ingress</td>
<td style="text-align:left">ing</td>
<td style="text-align:left">统一pod对外接口</td>
</tr>
<tr>
<td style="text-align:left">存储资源</td>
<td style="text-align:left">volumeattachments</td>
<td style="text-align:left"></td>
<td style="text-align:left">存储</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">persistentvolumes</td>
<td style="text-align:left">pv</td>
<td style="text-align:left">存储</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">persistentvolumeclaims</td>
<td style="text-align:left">pvc</td>
<td style="text-align:left">存储</td>
</tr>
<tr>
<td style="text-align:left">配置资源</td>
<td style="text-align:left">configmaps</td>
<td style="text-align:left">cm</td>
<td style="text-align:left">配置</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">secrets</td>
<td style="text-align:left"></td>
<td style="text-align:left">配置</td>
</tr>
</tbody>
</table>
<p><strong>操作</strong></p>
<p>kubernetes允许对资源进行多种操作，可以通过--help查看详细的操作命令</p>
<pre><code>kubectl --help
</code></pre>
<p>经常使用的操作有下面这些：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令分类</th>
<th style="text-align:left">命令</th>
<th style="text-align:left">翻译</th>
<th style="text-align:left">命令作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">基本命令</td>
<td style="text-align:left">create</td>
<td style="text-align:left">创建</td>
<td style="text-align:left">创建一个资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">edit</td>
<td style="text-align:left">编辑</td>
<td style="text-align:left">编辑一个资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">get</td>
<td style="text-align:left">获取</td>
<td style="text-align:left">获取一个资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">patch</td>
<td style="text-align:left">更新</td>
<td style="text-align:left">更新一个资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">delete</td>
<td style="text-align:left">删除</td>
<td style="text-align:left">删除一个资源</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">explain</td>
<td style="text-align:left">解释</td>
<td style="text-align:left">展示资源文档</td>
</tr>
<tr>
<td style="text-align:left">运行和调试</td>
<td style="text-align:left">run</td>
<td style="text-align:left">运行</td>
<td style="text-align:left">在集群中运行一个指定的镜像</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">expose</td>
<td style="text-align:left">暴露</td>
<td style="text-align:left">暴露资源为Service</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">describe</td>
<td style="text-align:left">描述</td>
<td style="text-align:left">显示资源内部信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">logs</td>
<td style="text-align:left">日志输出容器在 pod 中的日志</td>
<td style="text-align:left">输出容器在 pod 中的日志</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">attach</td>
<td style="text-align:left">缠绕进入运行中的容器</td>
<td style="text-align:left">进入运行中的容器</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">exec</td>
<td style="text-align:left">执行容器中的一个命令</td>
<td style="text-align:left">执行容器中的一个命令</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cp</td>
<td style="text-align:left">复制</td>
<td style="text-align:left">在Pod内外复制文件</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">rollout</td>
<td style="text-align:left">首次展示</td>
<td style="text-align:left">管理资源的发布</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">scale</td>
<td style="text-align:left">规模</td>
<td style="text-align:left">扩(缩)容Pod的数量</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">autoscale</td>
<td style="text-align:left">自动调整</td>
<td style="text-align:left">自动调整Pod的数量</td>
</tr>
<tr>
<td style="text-align:left">高级命令</td>
<td style="text-align:left">apply</td>
<td style="text-align:left">rc</td>
<td style="text-align:left">通过文件对资源进行配置</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">label</td>
<td style="text-align:left">标签</td>
<td style="text-align:left">更新资源上的标签</td>
</tr>
<tr>
<td style="text-align:left">其他命令</td>
<td style="text-align:left">cluster-info</td>
<td style="text-align:left">集群信息</td>
<td style="text-align:left">显示集群信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">version</td>
<td style="text-align:left">版本</td>
<td style="text-align:left">显示当前Server和Client的版本</td>
</tr>
</tbody>
</table>
<p>下面以一个namespace / pod的创建和删除简单演示下命令的使用：</p>
<pre><code class="language-shell"># 创建一个namespace
[root@master ~]# kubectl create namespace dev
namespace/dev created

# 获取namespace
[root@master ~]# kubectl get ns
NAME              STATUS   AGE
default           Active   21h
dev               Active   21s
kube-node-lease   Active   21h
kube-public       Active   21h
kube-system       Active   21h

# 在此namespace下创建并运行一个nginx的Pod
[root@master ~]# kubectl run pod --image=nginx:latest -n dev
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/pod created

# 查看新创建的pod
[root@master ~]# kubectl get pod -n dev
NAME  READY   STATUS    RESTARTS   AGE
pod   1/1     Running   0          21s

# 删除指定的pod
[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x
pod &quot;pod&quot; deleted

# 删除指定的namespace
[root@master ~]# kubectl delete ns dev
namespace &quot;dev&quot; deleted
</code></pre>
<h3 id="332-命令式对象配置">3.3.2 命令式对象配置</h3>
<p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1） 创建一个nginxpod.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: dev

---

apiVersion: v1
kind: Pod
metadata:
  name: nginxpod
  namespace: dev
spec:
  containers:
  - name: nginx-containers
    image: nginx:latest
</code></pre>
<p>2）执行create命令，创建资源：</p>
<pre><code class="language-yaml">[root@master ~]# kubectl create -f nginxpod.yaml
namespace/dev created
pod/nginxpod created
</code></pre>
<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<pre><code class="language-shell">[root@master ~]#  kubectl get -f nginxpod.yaml
NAME            STATUS   AGE
namespace/dev   Active   18s

NAME            READY   STATUS    RESTARTS   AGE
pod/nginxpod    1/1     Running   0          17s
</code></pre>
<p>这样就显示了两个资源对象的信息</p>
<p>4）执行delete命令，删除资源：</p>
<pre><code class="language-shell">[root@master ~]# kubectl delete -f nginxpod.yaml
namespace &quot;dev&quot; deleted
pod &quot;nginxpod&quot; deleted
</code></pre>
<p>此时发现两个资源对象被删除了</p>
<pre><code>总结:
    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）
</code></pre>
<h3 id="333-声明式对象配置">3.3.3 声明式对象配置</h3>
<p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<pre><code class="language-shell"># 首先执行一次kubectl apply -f yaml文件，发现创建了资源
[root@master ~]#  kubectl apply -f nginxpod.yaml
namespace/dev created
pod/nginxpod created

# 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动
[root@master ~]#  kubectl apply -f nginxpod.yaml
namespace/dev unchanged
pod/nginxpod unchanged
</code></pre>
<pre><code>总结:
    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）
    使用apply操作资源：
        如果资源不存在，就创建，相当于 kubectl create
        如果资源已存在，就更新，相当于 kubectl patch
</code></pre>
<blockquote>
<p>扩展：kubectl可以在node节点上运行吗 ?</p>
</blockquote>
<p>kubectl的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：</p>
<pre><code class="language-shell">scp  -r  HOME/.kube   node1: HOME/
</code></pre>
<blockquote>
<p>使用推荐: 三种方式应该怎么用 ?</p>
</blockquote>
<p>创建/更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml</p>
<p>删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml</p>
<p>查询资源 使用命令式对象管理 kubectl get(describe) 资源名称</p>
<h1 id="4-实战入门">4. 实战入门</h1>
<p>本章节将介绍如何在kubernetes集群中部署一个nginx服务，并且能够对其进行访问。</p>
<h2 id="41-namespace">4.1 Namespace</h2>
<p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的&quot;组&quot;，以方便不同的组的资源进行隔离使用和管理。</p>
<p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gy0nfeoj30uh0fwabe.jpg" alt="image-20200407100850484" loading="lazy"></figure>
<p>kubernetes在集群启动之后，会默认创建几个namespace</p>
<pre><code class="language-shell">[root@master ~]# kubectl  get namespace
NAME              STATUS   AGE
default           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间
kube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入
kube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）
kube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间
</code></pre>
<p>下面来看namespace资源的具体操作：</p>
<p><strong>查看</strong></p>
<pre><code class="language-shell"># 1 查看所有的ns  命令：kubectl get ns
[root@master ~]# kubectl get ns
NAME              STATUS   AGE
default           Active   45h
kube-node-lease   Active   45h
kube-public       Active   45h     
kube-system       Active   45h     

# 2 查看指定的ns   命令：kubectl get ns ns名称
[root@master ~]# kubectl get ns default
NAME      STATUS   AGE
default   Active   45h

# 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数
# kubernetes支持的格式有很多，比较常见的是wide、json、yaml
[root@master ~]# kubectl get ns default -o yaml
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: &quot;2021-05-08T04:44:16Z&quot;
  name: default
  resourceVersion: &quot;151&quot;
  selfLink: /api/v1/namespaces/default
  uid: 7405f73a-e486-43d4-9db6-145f1409f090
spec:
  finalizers:
  - kubernetes
status:
  phase: Active
  
# 4 查看ns详情  命令：kubectl describe ns ns名称
[root@master ~]# kubectl describe ns default
Name:         default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Status:       Active  # Active 命名空间正在使用中  Terminating 正在删除命名空间

# ResourceQuota 针对namespace做的资源限制
# LimitRange针对namespace中的每个组件做的资源限制
No resource quota.
No LimitRange resource.
</code></pre>
<p><strong>创建</strong></p>
<pre><code class="language-shell"># 创建namespace
[root@master ~]# kubectl create ns dev
namespace/dev created
</code></pre>
<p><strong>删除</strong></p>
<pre><code class="language-shell"># 删除namespace
[root@master ~]# kubectl delete ns dev
namespace &quot;dev&quot; deleted
</code></pre>
<p><strong>配置方式</strong></p>
<p>首先准备一个yaml文件：ns-dev.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: dev
</code></pre>
<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f ns-dev.yaml</p>
<p>删除：kubectl delete -f ns-dev.yaml</p>
<h2 id="42-pod">4.2 Pod</h2>
<p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gy51oh8j30hl0cw0te.jpg" alt="image-20200407121501907" loading="lazy"></figure>
<p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p>
<pre><code class="language-shell">[root@master ~]# kubectl get pod -n kube-system
NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE
kube-system   coredns-6955765f44-68g6v         1/1     Running   0          2d1h
kube-system   coredns-6955765f44-cs5r8         1/1     Running   0          2d1h
kube-system   etcd-master                      1/1     Running   0          2d1h
kube-system   kube-apiserver-master            1/1     Running   0          2d1h
kube-system   kube-controller-manager-master   1/1     Running   0          2d1h
kube-system   kube-flannel-ds-amd64-47r25      1/1     Running   0          2d1h
kube-system   kube-flannel-ds-amd64-ls5lh      1/1     Running   0          2d1h
kube-system   kube-proxy-685tk                 1/1     Running   0          2d1h
kube-system   kube-proxy-87spt                 1/1     Running   0          2d1h
kube-system   kube-scheduler-master            1/1     Running   0          2d1h
</code></pre>
<p><strong>创建并运行</strong></p>
<p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p>
<pre><code class="language-shell"># 命令格式： kubectl run (pod控制器名称) [参数] 
# --image  指定Pod的镜像
# --port   指定端口
# --namespace  指定namespace
[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev 
deployment.apps/nginx created
</code></pre>
<p><strong>查看pod信息</strong></p>
<pre><code class="language-shell"># 查看Pod基本信息
[root@master ~]# kubectl get pods -n dev
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          43s

# 查看Pod的详细信息
[root@master ~]# kubectl describe pod nginx -n dev
Name:         nginx
Namespace:    dev
Priority:     0
Node:         node1/192.168.5.4
Start Time:   Wed, 08 May 2021 09:29:24 +0800
Labels:       pod-template-hash=5ff7956ff6
              run=nginx
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.244.1.23
IPs:
  IP:           10.244.1.23
Controlled By:  ReplicaSet/nginx
Containers:
  nginx:
    Container ID:   docker://4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c
    Image:          nginx:latest
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Wed, 08 May 2021 09:30:01 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hwvvw (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  default-token-hwvvw:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-hwvvw
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &lt;none&gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age        From               Message
  ----    ------     ----       ----               -------
  Normal  Scheduled  &lt;unknown&gt;  default-scheduler  Successfully assigned dev/nginx-5ff7956ff6-fg2db to node1
  Normal  Pulling    4m11s      kubelet, node1     Pulling image &quot;nginx:latest&quot;
  Normal  Pulled     3m36s      kubelet, node1     Successfully pulled image &quot;nginx:latest&quot;
  Normal  Created    3m36s      kubelet, node1     Created container nginx
  Normal  Started    3m36s      kubelet, node1     Started container nginx
</code></pre>
<p><strong>访问Pod</strong></p>
<pre><code class="language-shell"># 获取podIP
[root@master ~]# kubectl get pods -n dev -o wide
NAME    READY   STATUS    RESTARTS   AGE    IP             NODE    ... 
nginx   1/1     Running   0          190s   10.244.1.23   node1   ...

#访问POD
[root@master ~]# curl http://10.244.1.23:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>删除指定Pod</strong></p>
<pre><code class="language-shell"># 删除指定Pod
[root@master ~]# kubectl delete pod nginx -n dev
pod &quot;nginx&quot; deleted

# 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 
[root@master ~]# kubectl get pods -n dev
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          21s

# 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建
# 此时要想删除Pod，必须删除Pod控制器

# 先来查询一下当前namespace下的Pod控制器
[root@master ~]# kubectl get deploy -n  dev
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   1/1     1            1           9m7s

# 接下来，删除此PodPod控制器
[root@master ~]# kubectl delete deploy nginx -n dev
deployment.apps &quot;nginx&quot; deleted

# 稍等片刻，再查询Pod，发现Pod被删除了
[root@master ~]# kubectl get pods -n dev
No resources found in dev namespace.
</code></pre>
<p><strong>配置操作</strong></p>
<p>创建一个pod-nginx.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: dev
spec:
  containers:
  - image: nginx:latest
    name: pod
    ports:
    - name: nginx-port
      containerPort: 80
      protocol: TCP
</code></pre>
<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f pod-nginx.yaml</p>
<p>删除：kubectl delete -f pod-nginx.yaml</p>
<h2 id="43-label">4.3 Label</h2>
<p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点：</p>
<ul>
<li>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li>
<li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>一些常用的Label 示例如下：</p>
<ul>
<li>版本标签：&quot;version&quot;:&quot;release&quot;, &quot;version&quot;:&quot;stable&quot;......</li>
<li>环境标签：&quot;environment&quot;:&quot;dev&quot;，&quot;environment&quot;:&quot;test&quot;，&quot;environment&quot;:&quot;pro&quot;</li>
<li>架构标签：&quot;tier&quot;:&quot;frontend&quot;，&quot;tier&quot;:&quot;backend&quot;</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>Label用于给某个资源对象定义标识</p>
<p>Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li>
<p>基于等式的Label Selector</p>
<p>name = slave: 选择所有包含Label中key=&quot;name&quot;且value=&quot;slave&quot;的对象</p>
<p>env != production: 选择所有包括Label中的key=&quot;env&quot;且value不等于&quot;production&quot;的对象</p>
</li>
<li>
<p>基于集合的Label Selector</p>
<p>name in (master, slave): 选择所有包含Label中的key=&quot;name&quot;且value=&quot;master&quot;或&quot;slave&quot;的对象</p>
<p>name not in (frontend): 选择所有包含Label中的key=&quot;name&quot;且value不等于&quot;frontend&quot;的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号&quot;,&quot;进行分隔即可。例如：</p>
<p>name=slave，env!=production</p>
<p>name not in (frontend)，env!=production</p>
<p><strong>命令方式</strong></p>
<pre><code class="language-shell"># 为pod资源打标签
[root@master ~]# kubectl label pod nginx-pod version=1.0 -n dev
pod/nginx-pod labeled

# 为pod资源更新标签
[root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwrite
pod/nginx-pod labeled

# 查看标签
[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod   1/1     Running   0          10m   version=2.0

# 筛选标签
[root@master ~]# kubectl get pod -n dev -l version=2.0  --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod   1/1     Running   0          17m   version=2.0
[root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labels
No resources found in dev namespace.

#删除标签
[root@master ~]# kubectl label pod nginx-pod version- -n dev
pod/nginx-pod labeled
</code></pre>
<p><strong>配置方式</strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: dev
  labels:
    version: &quot;3.0&quot; 
    env: &quot;test&quot;
spec:
  containers:
  - image: nginx:latest
    name: pod
    ports:
    - name: nginx-port
      containerPort: 80
      protocol: TCP
</code></pre>
<p>然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml</p>
<h2 id="44-deployment">4.4 Deployment</h2>
<p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gya55fjj30l90bm3zh.jpg" alt="image-20200408193950807" loading="lazy"></figure>
<p><strong>命令操作</strong></p>
<pre><code class="language-shell"># 命令格式: kubectl create deployment 名称  [参数] 
# --image  指定pod的镜像
# --port   指定端口
# --replicas  指定创建pod数量
# --namespace  指定namespace
[root@master ~]# kubectl create deploy nginx --image=nginx:latest --port=80 --replicas=3 -n dev
deployment.apps/nginx created

# 查看创建的Pod
[root@master ~]# kubectl get pods -n dev
NAME                     READY   STATUS    RESTARTS   AGE
nginx-5ff7956ff6-6k8cb   1/1     Running   0          19s
nginx-5ff7956ff6-jxfjt   1/1     Running   0          19s
nginx-5ff7956ff6-v6jqw   1/1     Running   0          19s

# 查看deployment的信息
[root@master ~]# kubectl get deploy -n dev
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   3/3     3            3           2m42s

# UP-TO-DATE：成功升级的副本数量
# AVAILABLE：可用副本的数量
[root@master ~]# kubectl get deploy -n dev -o wide
NAME    READY UP-TO-DATE  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR
nginx   3/3     3         3           2m51s   nginx        nginx:latest        run=nginx

# 查看deployment的详细信息
[root@master ~]# kubectl describe deploy nginx -n dev
Name:                   nginx
Namespace:              dev
CreationTimestamp:      Wed, 08 May 2021 11:14:14 +0800
Labels:                 run=nginx
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               run=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  run=nginx
  Containers:
   nginx:
    Image:        nginx:latest
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-5ff7956ff6 (3/3 replicas created)
Events:
  Type    Reason             Age    From                   Message
  ----    ------             ----   ----                   -------
  Normal  ScalingReplicaSet  5m43s  deployment-controller  Scaled up replicaset nginx-5ff7956ff6 to 3
  
# 删除 
[root@master ~]# kubectl delete deploy nginx -n dev
deployment.apps &quot;nginx&quot; deleted
</code></pre>
<p><strong>配置操作</strong></p>
<p>创建一个deploy-nginx.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: dev
spec:
  replicas: 3
  selector:
    matchLabels:
      run: nginx
  template:
    metadata:
      labels:
        run: nginx
    spec:
      containers:
      - image: nginx:latest
        name: nginx
        ports:
        - containerPort: 80
          protocol: TCP
</code></pre>
<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f deploy-nginx.yaml</p>
<p>删除：kubectl delete -f deploy-nginx.yaml</p>
<h2 id="45-service">4.5 Service</h2>
<p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p>
<p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p>
<ul>
<li>Pod IP 会随着Pod的重建产生变化</li>
<li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gydwoj8j30tt0dtq4q.jpg" alt="image-20200408194716912" loading="lazy"></figure>
<p><strong>操作一：创建集群内部可访问的Service</strong></p>
<pre><code class="language-shell"># 暴露Service
[root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev
service/svc-nginx1 exposed

# 查看service
[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR
svc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80/TCP    3m51s   run=nginx

# 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的
# 可以通过这个IP访问当前service对应的POD
[root@master ~]# curl 10.109.179.231:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
.......
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>操作二：创建集群外部也可访问的Service</strong></p>
<pre><code class="language-shell"># 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问
# 如果需要创建外部也可以访问的Service，需要修改type为NodePort
[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev
service/svc-nginx2 exposed

# 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）
[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wide
NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTOR
svc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928/TCP   9s     run=nginx

# 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了
# 例如在的电脑主机上通过浏览器访问下面的地址
http://192.168.5.4:31928/
</code></pre>
<p><strong>删除Service</strong></p>
<pre><code class="language-shell">[root@master ~]# kubectl delete svc svc-nginx-1 -n dev service &quot;svc-nginx-1&quot; deleted
</code></pre>
<p><strong>配置方式</strong></p>
<p>创建一个svc-nginx.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: svc-nginx
  namespace: dev
spec:
  clusterIP: 10.109.179.231 #固定svc的内网ip
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: nginx
  type: ClusterIP
</code></pre>
<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f svc-nginx.yaml</p>
<p>删除：kubectl delete -f svc-nginx.yaml</p>
<blockquote>
<p><strong>小结</strong></p>
<p>至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。</p>
</blockquote>
<h1 id="5-pod详解">5. Pod详解</h1>
<h2 id="51-pod介绍">5.1 Pod介绍</h2>
<h3 id="511-pod结构">5.1.1 Pod结构</h3>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gyi2hikj30hl0cw0te.jpg" alt="image-20200407121501907" loading="lazy"></figure>
<p>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p>
<ul>
<li>
<p>用户程序所在的容器，数量可多可少</p>
</li>
<li>
<p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个：</p>
<ul>
<li>
<p>可以以它为依据，评估整个Pod的健康状态</p>
</li>
<li>
<p>可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信</p>
<pre><code>这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="512-pod定义">5.1.2 Pod定义</h3>
<p>下面是Pod的资源清单：</p>
<pre><code class="language-shell">apiVersion: v1     #必选，版本号，例如v1
kind: Pod       　 #必选，资源类型，例如 Pod
metadata:       　 #必选，元数据
  name: string     #必选，Pod名称
  namespace: string  #Pod所属的命名空间,默认为&quot;default&quot;
  labels:       　　  #自定义标签列表
    - name: string      　          
spec:  #必选，Pod中容器的详细定义
  containers:  #必选，Pod中容器列表
  - name: string   #必选，容器名称
    image: string  #必选，容器的镜像名称
    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 
    command: [string]   #容器的启动命令列表，如不指定，使用打包时使用的启动命令
    args: [string]      #容器的启动命令参数列表
    workingDir: string  #容器的工作目录
    volumeMounts:       #挂载到容器内部的存储卷配置
    - name: string      #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名
      mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符
      readOnly: boolean #是否为只读模式
    ports: #需要暴露的端口库号列表
    - name: string        #端口的名称
      containerPort: int  #容器需要监听的端口号
      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同
      protocol: string    #端口协议，支持TCP和UDP，默认TCP
    env:   #容器运行前需设置的环境变量列表
    - name: string  #环境变量名称
      value: string #环境变量的值
    resources: #资源限制和请求的设置
      limits:  #资源限制的设置
        cpu: string     #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数
        memory: string  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数
      requests: #资源请求的设置
        cpu: string    #Cpu请求，容器启动的初始可用数量
        memory: string #内存请求,容器启动的初始可用数量
    lifecycle: #生命周期钩子
        postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启
        preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止
    livenessProbe:  #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器
      exec:       　 #对Pod容器内检查方式设置为exec方式
        command: [string]  #exec方式需要制定的命令或脚本
      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port
        path: string
        port: number
        host: string
        scheme: string
        HttpHeaders:
        - name: string
          value: string
      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式
         port: number
       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒
       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒
       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次
       successThreshold: 0
       failureThreshold: 0
       securityContext:
         privileged: false
  restartPolicy: [Always | Never | OnFailure]  #Pod的重启策略
  nodeName: &lt;string&gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上
  nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上
  imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定
  - name: string
  hostNetwork: false   #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络
  volumes:   #在该pod上定义共享存储卷列表
  - name: string    #共享存储卷名称 （volumes类型有很多种）
    emptyDir: {}       #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值
    hostPath: string   #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录
      path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录
    secret:       　　　#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部
      scretname: string  
      items:     
      - key: string
        path: string
    configMap:         #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部
      name: string
      items:
      - key: string
        path: string
</code></pre>
<pre><code class="language-shell">#小提示：
#   在这里，可通过一个命令来查看每种资源的可配置项
#   kubectl explain 资源类型         查看某种资源可以配置的一级属性
#   kubectl explain 资源类型.属性     查看属性的子属性
[root@k8s-master01 ~]# kubectl explain pod
KIND:     Pod
VERSION:  v1
FIELDS:
   apiVersion   &lt;string&gt;
   kind &lt;string&gt;
   metadata     &lt;Object&gt;
   spec &lt;Object&gt;
   status       &lt;Object&gt;

[root@k8s-master01 ~]# kubectl explain pod.metadata
KIND:     Pod
VERSION:  v1
RESOURCE: metadata &lt;Object&gt;
FIELDS:
   annotations  &lt;map[string]string&gt;
   clusterName  &lt;string&gt;
   creationTimestamp    &lt;string&gt;
   deletionGracePeriodSeconds   &lt;integer&gt;
   deletionTimestamp    &lt;string&gt;
   finalizers   &lt;[]string&gt;
   generateName &lt;string&gt;
   generation   &lt;integer&gt;
   labels       &lt;map[string]string&gt;
   managedFields        &lt;[]Object&gt;
   name &lt;string&gt;
   namespace    &lt;string&gt;
   ownerReferences      &lt;[]Object&gt;
   resourceVersion      &lt;string&gt;
   selfLink     &lt;string&gt;
   uid  &lt;string&gt;
</code></pre>
<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li>apiVersion <string> 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</li>
<li>kind <string> 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</li>
<li>metadata <Object> 元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li>
<li>spec <Object> 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li>status <Object> 状态信息，里面的内容不需要定义，由kubernetes自动生成</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li>
<li>nodeName <String> 根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork <boolean> 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li>
<li>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h2 id="52-pod配置">5.2 Pod配置</h2>
<p>本小节主要来研究<code>pod.spec.containers</code>属性，这也是pod配置中最为关键的一项配置。</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl explain pod.spec.containers
KIND:     Pod
VERSION:  v1
RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器
FIELDS:
   name  &lt;string&gt;     # 容器名称
   image &lt;string&gt;     # 容器需要的镜像地址
   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 
   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令
   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表
   env      &lt;[]Object&gt; # 容器环境变量的配置
   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表
   resources &lt;Object&gt;      # 资源限制和资源请求的设置
</code></pre>
<h3 id="521-基本配置">5.2.1 基本配置</h3>
<p>创建pod-base.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-base
  namespace: dev
  labels:
    user: heima
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  - name: busybox
    image: busybox:1.30
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gynp00kj30bx01uaa6.jpg" alt="image-20210617223823675" loading="lazy"></figure>
<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 pod]# kubectl apply -f pod-base.yaml
pod/pod-base created

# 查看Pod状况
# READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪
# RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它
[root@k8s-master01 pod]# kubectl get pod -n dev
NAME       READY   STATUS    RESTARTS   AGE
pod-base   1/2     Running   4          95s

# 可以通过describe查看内部的详情
# 此时已经运行起来了一个基本的Pod，虽然它暂时有问题
[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev
</code></pre>
<h3 id="522-镜像拉取">5.2.2 镜像拉取</h3>
<p>创建pod-imagepullpolicy.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-imagepullpolicy
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    imagePullPolicy: Never # 用于设置镜像拉取策略
  - name: busybox
    image: busybox:1.30
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gyrrlwzj30dr027t8y.jpg" alt="image-20210617223923659" loading="lazy"></figure>
<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p>默认值说明：</p>
<p>如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p>
<p>如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yaml
pod/pod-imagepullpolicy created

# 查看Pod详情
# 此时明显可以看到nginx镜像有一步Pulling image &quot;nginx:1.17.1&quot;的过程
[root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev
......
Events:
  Type     Reason     Age               From               Message
  ----     ------     ----              ----               -------
  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-imagePullPolicy to node1
  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;
  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;
  Normal   Created    26s               kubelet, node1     Created container nginx
  Normal   Started    25s               kubelet, node1     Started container nginx
  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine
  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox
  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox
</code></pre>
<h3 id="523-启动命令">5.2.3 启动命令</h3>
<p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-command
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;]
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gywjczij30dt02paae.jpg" alt="image-20210617224457945" loading="lazy"></figure>
<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：</p>
<p>&quot;/bin/sh&quot;,&quot;-c&quot;, 使用sh执行命令</p>
<p>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</p>
<p>while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p>
</blockquote>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 pod]# kubectl create  -f pod-command.yaml
pod/pod-command created

# 查看Pod状态
# 此时发现两个pod都正常运行了
[root@k8s-master01 pod]# kubectl get pods pod-command -n dev
NAME          READY   STATUS   RESTARTS   AGE
pod-command   2/2     Runing   0          2s

# 进入pod中的busybox容器，查看文件内容
# 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令
# 使用这个命令就可以进入某个容器的内部，然后进行相关操作了
# 比如，可以查看txt文件的内容
[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh
/ # tail -f /tmp/hello.txt
14:44:19
14:44:22
14:44:25
</code></pre>
<pre><code>特别说明：
    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。
 1 如果command和args均没有写，那么用Dockerfile的配置。
 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command
 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数
 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数
</code></pre>
<h3 id="524-环境变量">5.2.4 环境变量</h3>
<p>创建pod-env.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-env
  namespace: dev
spec:
  containers:
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;]
    env: # 设置环境变量列表
    - name: &quot;username&quot;
      value: &quot;admin&quot;
    - name: &quot;password&quot;
      value: &quot;123456&quot;
</code></pre>
<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-env.yaml
pod/pod-env created

# 进入容器，输出环境变量
[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh
/ # echo $username
admin
/ # echo $password
123456
</code></pre>
<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h3 id="525-端口设置">5.2.5 端口设置</h3>
<p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.ports
KIND:     Pod
VERSION:  v1
RESOURCE: ports &lt;[]Object&gt;
FIELDS:
   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的		
   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)
   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) 
   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)
   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。
</code></pre>
<p>接下来，编写一个测试案例，创建pod-ports.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-ports
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports: # 设置容器暴露的端口列表
    - name: nginx-port
      containerPort: 80
      protocol: TCP
</code></pre>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-ports.yaml
pod/pod-ports created

# 查看pod
# 在下面可以明显看到配置信息
[root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml
......
spec:
  containers:
  - image: nginx:1.17.1
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
    - containerPort: 80
      name: nginx-port
      protocol: TCP
......
</code></pre>
<p>访问容器中的程序需要使用的是<code>Podip:containerPort</code></p>
<h3 id="526-资源配额">5.2.6 资源配额</h3>
<p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li>
<li>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建pod-resources.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-resources
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    resources: # 资源配额
      limits:  # 限制资源（上限）
        cpu: &quot;2&quot; # CPU限制，单位是core数
        memory: &quot;10Gi&quot; # 内存限制
      requests: # 请求资源（下限）
        cpu: &quot;1&quot;  # CPU限制，单位是core数
        memory: &quot;10Mi&quot;  # 内存限制
</code></pre>
<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li>cpu：core数，可以为整数或小数</li>
<li>memory： 内存大小，可以使用Gi、Mi、G、M等形式</li>
</ul>
<pre><code class="language-shell"># 运行Pod
[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml
pod/pod-resources created

# 查看发现pod运行正常
[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev
NAME            READY   STATUS    RESTARTS   AGE  
pod-resources   1/1     Running   0          39s   

# 接下来，停止Pod
[root@k8s-master01 ~]# kubectl delete  -f pod-resources.yaml
pod &quot;pod-resources&quot; deleted

# 编辑pod，修改resources.requests.memory的值为10Gi
[root@k8s-master01 ~]# vim pod-resources.yaml

# 再次启动pod
[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml
pod/pod-resources created

# 查看Pod状态，发现Pod启动失败
[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide
NAME            READY   STATUS    RESTARTS   AGE          
pod-resources   0/1     Pending   0          20s    

# 查看pod详情会发现，如下提示
[root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev
......
Warning  FailedScheduling  35s   default-scheduler  0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate, 2 Insufficient memory.(内存不足)
</code></pre>
<h2 id="53-pod生命周期">5.3 Pod生命周期</h2>
<p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li>pod创建过程</li>
<li>运行初始化容器（init container）过程</li>
<li>运行主容器（main container）
<ul>
<li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li>
<li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li>
</ul>
</li>
<li>pod终止过程</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gz1qxumj30t90f8abr.jpg" alt="image-20200412111402706" loading="lazy"></figure>
<p>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<h3 id="531-创建和终止">5.3.1 创建和终止</h3>
<p><strong>pod的创建过程</strong></p>
<ol>
<li>
<p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
</li>
<li>
<p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
</li>
<li>
<p>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</p>
</li>
<li>
<p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</p>
</li>
<li>
<p>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
</li>
<li>
<p>apiServer将接收到的pod状态信息存入etcd中</p>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gz5mu0ej313w0kpwhr.jpg" alt="image-20200406184656917" loading="lazy"></figure>
</li>
</ol>
<p><strong>pod的终止过程</strong></p>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
<h3 id="532-初始化容器">5.3.2 初始化容器</h3>
<p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li>
</ol>
<p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p>
<ul>
<li>提供主容器镜像中不具备的工具程序或自定义代码</li>
<li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p>
<p>为了简化测试，事先规定好mysql<code>(192.168.5.4)</code>和redis<code>(192.168.5.5)</code>服务器的地址</p>
<p>创建pod-initcontainer.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-initcontainer
  namespace: dev
spec:
  containers:
  - name: main-container
    image: nginx:1.17.1
    ports: 
    - name: nginx-port
      containerPort: 80
  initContainers:
  - name: test-mysql
    image: busybox:1.30
    command: ['sh', '-c', 'until ping 192.168.5.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;']
  - name: test-redis
    image: busybox:1.30
    command: ['sh', '-c', 'until ping 192.168.5.15 -c 1 ; do echo waiting for reids...; sleep 2; done;']
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yaml
pod/pod-initcontainer created

# 查看pod状态
# 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行
root@k8s-master01 ~]# kubectl describe pod  pod-initcontainer -n dev
........
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  49s   default-scheduler  Successfully assigned dev/pod-initcontainer to node1
  Normal  Pulled     48s   kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine
  Normal  Created    48s   kubelet, node1     Created container test-mysql
  Normal  Started    48s   kubelet, node1     Started container test-mysql

# 动态查看pod
[root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -w
NAME                             READY   STATUS     RESTARTS   AGE
pod-initcontainer                0/1     Init:0/2   0          15s
pod-initcontainer                0/1     Init:1/2   0          52s
pod-initcontainer                0/1     Init:1/2   0          53s
pod-initcontainer                0/1     PodInitializing   0          89s
pod-initcontainer                1/1     Running           0          90s

# 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化
[root@k8s-master01 ~]# ifconfig ens33:1 192.168.5.14 netmask 255.255.255.0 up
[root@k8s-master01 ~]# ifconfig ens33:2 192.168.5.15 netmask 255.255.255.0 up
</code></pre>
<h3 id="533-钩子函数">5.3.3 钩子函数</h3>
<p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器</li>
<li>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ul>
<p>钩子处理器支持使用下面三种方式定义动作：</p>
<ul>
<li>
<p>Exec命令：在容器内执行一次命令</p>
<pre><code class="language-yaml">……
  lifecycle:
    postStart: 
      exec:
        command:
        - cat
        - /tmp/healthy
……
</code></pre>
</li>
<li>
<p>TCPSocket：在当前容器尝试访问指定的socket</p>
<pre><code class="language-yaml">……      
  lifecycle:
    postStart:
      tcpSocket:
        port: 8080
……
</code></pre>
</li>
<li>
<p>HTTPGet：在当前容器中向某url发起http请求</p>
<pre><code class="language-yaml">……
  lifecycle:
    postStart:
      httpGet:
        path: / #URI地址
        port: 80 #端口号
        host: 192.168.5.3 #主机地址
        scheme: HTTP #支持的协议，http或者https
……
</code></pre>
</li>
</ul>
<p>接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-hook-exec
  namespace: dev
spec:
  containers:
  - name: main-container
    image: nginx:1.17.1
    ports:
    - name: nginx-port
      containerPort: 80
    lifecycle:
      postStart: 
        exec: # 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容
          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;]
      preStop:
        exec: # 在容器停止之前停止nginx服务
          command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yaml
pod/pod-hook-exec created

# 查看pod
[root@k8s-master01 ~]# kubectl get pods  pod-hook-exec -n dev -o wide
NAME           READY   STATUS     RESTARTS   AGE    IP            NODE    
pod-hook-exec  1/1     Running    0          29s    10.244.2.48   node2   

# 访问pod
[root@k8s-master01 ~]# curl 10.244.2.48
postStart...
</code></pre>
<h3 id="534-容器探测">5.3.4 容器探测</h3>
<p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例&quot; 摘除 &quot;，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li>
<li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li>
</ul>
<blockquote>
<p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li>
<p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p>
<pre><code class="language-yaml">……
  livenessProbe:
    exec:
      command:
      - cat
      - /tmp/healthy
……
</code></pre>
</li>
<li>
<p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p>
<pre><code class="language-yaml">……      
  livenessProbe:
    tcpSocket:
      port: 8080
……
</code></pre>
</li>
<li>
<p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p>
<pre><code class="language-yaml">……
  livenessProbe:
    httpGet:
      path: / #URI地址
      port: 80 #端口号
      host: 127.0.0.1 #主机地址
      scheme: HTTP #支持的协议，http或者https
……
</code></pre>
</li>
</ul>
<p>下面以liveness probes为例，做几个演示：</p>
<p><strong>方式一：Exec</strong></p>
<p>创建pod-liveness-exec.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-liveness-exec
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports: 
    - name: nginx-port
      containerPort: 80
    livenessProbe:
      exec:
        command: [&quot;/bin/cat&quot;,&quot;/tmp/hello.txt&quot;] # 执行一个查看文件的命令
</code></pre>
<p>创建pod，观察效果</p>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yaml
pod/pod-liveness-exec created

# 查看Pod详情
[root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev
......
  Normal   Created    20s (x2 over 50s)  kubelet, node1     Created container nginx
  Normal   Started    20s (x2 over 50s)  kubelet, node1     Started container nginx
  Normal   Killing    20s                kubelet, node1     Container nginx failed liveness probe, will be restarted
  Warning  Unhealthy  0s (x5 over 40s)   kubelet, node1     Liveness probe failed: cat: can't open '/tmp/hello11.txt': No such file or directory
  
# 观察上面的信息就会发现nginx容器启动之后就进行了健康检查
# 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解）
# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长
[root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n dev
NAME                READY   STATUS             RESTARTS   AGE
pod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s

# 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......
</code></pre>
<p><strong>方式二：TCPSocket</strong></p>
<p>创建pod-liveness-tcpsocket.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-liveness-tcpsocket
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports: 
    - name: nginx-port
      containerPort: 80
    livenessProbe:
      tcpSocket:
        port: 8080 # 尝试访问8080端口
</code></pre>
<p>创建pod，观察效果</p>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yaml
pod/pod-liveness-tcpsocket created

# 查看Pod详情
[root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev
......
  Normal   Scheduled  31s                            default-scheduler  Successfully assigned dev/pod-liveness-tcpsocket to node2
  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine
  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx
  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx
  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused
  
# 观察上面的信息，发现尝试访问8080端口,但是失败了
# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长
[root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket  -n dev
NAME                     READY   STATUS             RESTARTS   AGE
pod-liveness-tcpsocket   0/1     CrashLoopBackOff   2          3m19s

# 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......
</code></pre>
<p><strong>方式三：HTTPGet</strong></p>
<p>创建pod-liveness-httpget.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-liveness-httpget
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - name: nginx-port
      containerPort: 80
    livenessProbe:
      httpGet:  # 其实就是访问http://127.0.0.1:80/hello  
        scheme: HTTP #支持的协议，http或者https
        port: 80 #端口号
        path: /hello #URI地址
</code></pre>
<p>创建pod，观察效果</p>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yaml
pod/pod-liveness-httpget created

# 查看Pod详情
[root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev
.......
  Normal   Pulled     6s (x3 over 64s)  kubelet, node1     Container image &quot;nginx:1.17.1&quot; already present on machine
  Normal   Created    6s (x3 over 64s)  kubelet, node1     Created container nginx
  Normal   Started    6s (x3 over 63s)  kubelet, node1     Started container nginx
  Warning  Unhealthy  6s (x6 over 56s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404
  Normal   Killing    6s (x2 over 36s)  kubelet, node1     Container nginx failed liveness probe, will be restarted
  
# 观察上面信息，尝试访问路径，但是未找到,出现404错误
# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长
[root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n dev
NAME                   READY   STATUS    RESTARTS   AGE
pod-liveness-httpget   1/1     Running   5          3m17s

# 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......
</code></pre>
<p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbe
FIELDS:
   exec &lt;Object&gt;  
   tcpSocket    &lt;Object&gt;
   httpGet      &lt;Object&gt;
   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测
   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒
   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒
   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1
   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1
</code></pre>
<p>下面稍微配置两个，演示下效果即可：</p>
<pre><code class="language-yaml">[root@k8s-master01 ~]# more pod-liveness-httpget.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-liveness-httpget
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - name: nginx-port
      containerPort: 80
    livenessProbe:
      httpGet:
        scheme: HTTP
        port: 80 
        path: /
      initialDelaySeconds: 30 # 容器启动后30s开始探测
      timeoutSeconds: 5 # 探测超时时间为5s
</code></pre>
<h3 id="535-重启策略">5.3.5 重启策略</h3>
<p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li>Always ：容器失效时，自动重启该容器，这也是默认值。</li>
<li>OnFailure ： 容器终止运行且退出码不为0时重启</li>
<li>Never ： 不论状态为何，都不重启该容器</li>
</ul>
<p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<p>创建pod-restartpolicy.yaml：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-restartpolicy
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - name: nginx-port
      containerPort: 80
    livenessProbe:
      httpGet:
        scheme: HTTP
        port: 80
        path: /hello
  restartPolicy: Never # 设置重启策略为Never
</code></pre>
<p>运行Pod测试</p>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yaml
pod/pod-restartpolicy created

# 查看Pod详情，发现nginx容器失败
[root@k8s-master01 ~]# kubectl  describe pods pod-restartpolicy  -n dev
......
  Warning  Unhealthy  15s (x3 over 35s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404
  Normal   Killing    15s                kubelet, node1     Container nginx failed liveness probe
  
# 多等一会，再观察pod的重启次数，发现一直是0，并未重启   
[root@k8s-master01 ~]# kubectl  get pods pod-restartpolicy -n dev
NAME                   READY   STATUS    RESTARTS   AGE
pod-restartpolicy      0/1     Running   0          5min42s
</code></pre>
<h2 id="54-pod调度">5.4 Pod调度</h2>
<p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p>
<ul>
<li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li>
<li>定向调度：NodeName、NodeSelector</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li>
<li>污点（容忍）调度：Taints、Toleration</li>
</ul>
<h3 id="541-定向调度">5.4.1 定向调度</h3>
<p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p>
<p><strong>NodeName</strong></p>
<p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>接下来，实验一下：创建一个pod-nodename.yaml文件</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-nodename
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  nodeName: node1 # 指定调度到node1节点上
</code></pre>
<pre><code class="language-shell">#创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml
pod/pod-nodename created

#查看Pod调度到NODE属性，确实是调度到了node1节点上
[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......
pod-nodename   1/1     Running   0          56s   10.244.1.87   node1     ......   

# 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）
[root@k8s-master01 ~]# kubectl delete -f pod-nodename.yaml
pod &quot;pod-nodename&quot; deleted
[root@k8s-master01 ~]# vim pod-nodename.yaml
[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml
pod/pod-nodename created

#再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行
[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......
pod-nodename   0/1     Pending   0          6s    &lt;none&gt;   node3   ......           
</code></pre>
<p><strong>NodeSelector</strong></p>
<p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p>
<p>接下来，实验一下：</p>
<p>1 首先分别为node节点添加标签</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv=pro
node/node2 labeled
[root@k8s-master01 ~]# kubectl label nodes node2 nodeenv=test
node/node2 labeled
</code></pre>
<p>2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeselector
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  nodeSelector: 
    nodeenv: pro # 指定调度到具有nodeenv=pro标签的节点上
</code></pre>
<pre><code class="language-shell">#创建Pod
[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml
pod/pod-nodeselector created

#查看Pod调度到NODE属性，确实是调度到了node1节点上
[root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wide
NAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......
pod-nodeselector   1/1     Running   0          47s   10.244.1.87   node1   ......

# 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）
[root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yaml
pod &quot;pod-nodeselector&quot; deleted
[root@k8s-master01 ~]# vim pod-nodeselector.yaml
[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml
pod/pod-nodeselector created

#再次查看，发现pod无法正常运行,Node的值为none
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME               READY   STATUS    RESTARTS   AGE     IP       NODE    
pod-nodeselector   0/1     Pending   0          2m20s   &lt;none&gt;   &lt;none&gt;

# 查看详情,发现node selector匹配失败的提示
[root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev
.......
Events:
  Type     Reason            Age        From               Message
  ----     ------            ----       ----               -------
  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn't match node selector.
</code></pre>
<h3 id="542-亲和性调度">5.4.2 亲和性调度</h3>
<p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p>
<p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>Affinity主要分为三类：</p>
<ul>
<li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li>
<li>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li>
<li>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li>
</ul>
<blockquote>
<p>关于亲和性(反亲和性)使用场景的说明：</p>
<p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p>
<p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p>
</blockquote>
<p><strong>NodeAffinity</strong></p>
<p>首先来看一下<code>NodeAffinity</code>的可配置项：</p>
<pre><code class="language-shell">pod.spec.affinity.nodeAffinity
  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制
    nodeSelectorTerms  节点选择列表
      matchFields   按节点字段列出的节点选择器要求列表
      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)
        key    键
        values 值
        operator 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt
  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)
    preference   一个节点选择器项，与相应的权重相关联
      matchFields   按节点字段列出的节点选择器要求列表
      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)
        key    键
        values 值
        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt
	weight 倾向权重，在范围1-100。
</code></pre>
<pre><code class="language-shell">关系符的使用说明:

- matchExpressions:
  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点
    operator: Exists
  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点
    operator: In
    values: [&quot;xxx&quot;,&quot;yyy&quot;]
  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点
    operator: Gt
    values: &quot;xxx&quot;
</code></pre>
<p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-required.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeaffinity-required
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  affinity:  #亲和性设置
    nodeAffinity: #设置node亲和性
      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制
        nodeSelectorTerms:
        - matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签
          - key: nodeenv
            operator: In
            values: [&quot;xxx&quot;,&quot;yyy&quot;]
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml
pod/pod-nodeaffinity-required created

# 查看pod状态 （运行失败）
[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... 
pod-nodeaffinity-required   0/1     Pending   0          16s   &lt;none&gt;   &lt;none&gt;  ......

# 查看Pod的详情
# 发现调度失败，提示node选择失败
[root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev
......
  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn't match node selector.
  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn't match node selector.

#接下来，停止pod
[root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yaml
pod &quot;pod-nodeaffinity-required&quot; deleted

# 修改文件，将values: [&quot;xxx&quot;,&quot;yyy&quot;]------&gt; [&quot;pro&quot;,&quot;yyy&quot;]
[root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml

# 再次启动
[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml
pod/pod-nodeaffinity-required created

# 此时查看，发现调度成功，已经将pod调度到了node1上
[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... 
pod-nodeaffinity-required   1/1     Running   0          11s   10.244.1.89   node1 ......
</code></pre>
<p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-preferred.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeaffinity-preferred
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  affinity:  #亲和性设置
    nodeAffinity: #设置node亲和性
      preferredDuringSchedulingIgnoredDuringExecution: # 软限制
      - weight: 1
        preference:
          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)
          - key: nodeenv
            operator: In
            values: [&quot;xxx&quot;,&quot;yyy&quot;]
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yaml
pod/pod-nodeaffinity-preferred created

# 查看pod状态 （运行成功）
[root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n dev
NAME                         READY   STATUS    RESTARTS   AGE
pod-nodeaffinity-preferred   1/1     Running   0          40s
</code></pre>
<pre><code>NodeAffinity规则设置的注意事项：
    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上
    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可
    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功
    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化
</code></pre>
<p><strong>PodAffinity</strong></p>
<p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p>
<p>首先来看一下<code>PodAffinity</code>的可配置项：</p>
<pre><code class="language-shell">pod.spec.affinity.podAffinity
  requiredDuringSchedulingIgnoredDuringExecution  硬限制
    namespaces       指定参照pod的namespace
    topologyKey      指定调度作用域
    labelSelector    标签选择器
      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)
        key    键
        values 值
        operator 关系符 支持In, NotIn, Exists, DoesNotExist.
      matchLabels    指多个matchExpressions映射的内容
  preferredDuringSchedulingIgnoredDuringExecution 软限制
    podAffinityTerm  选项
      namespaces      
      topologyKey
      labelSelector
        matchExpressions  
          key    键
          values 值
          operator
        matchLabels 
    weight 倾向权重，在范围1-100
</code></pre>
<pre><code>topologyKey用于指定调度时作用域,例如:
    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围
	如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分
</code></pre>
<p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p>
<p>1）首先创建一个参照Pod，pod-podaffinity-target.yaml：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-podaffinity-target
  namespace: dev
  labels:
    podenv: pro #设置标签
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  nodeName: node1 # 将目标pod名确指定到node1上
</code></pre>
<pre><code class="language-shell"># 启动目标pod
[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yaml
pod/pod-podaffinity-target created

# 查看pod状况
[root@k8s-master01 ~]# kubectl get pods  pod-podaffinity-target -n dev
NAME                     READY   STATUS    RESTARTS   AGE
pod-podaffinity-target   1/1     Running   0          4s
</code></pre>
<p>2）创建pod-podaffinity-required.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-podaffinity-required
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  affinity:  #亲和性设置
    podAffinity: #设置pod亲和性
      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制
      - labelSelector:
          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签
          - key: podenv
            operator: In
            values: [&quot;xxx&quot;,&quot;yyy&quot;]
        topologyKey: kubernetes.io/hostname
</code></pre>
<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p>
<pre><code class="language-shell"># 启动pod
[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml
pod/pod-podaffinity-required created

# 查看pod状态，发现未运行
[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev
NAME                       READY   STATUS    RESTARTS   AGE
pod-podaffinity-required   0/1     Pending   0          9s

# 查看详细信息
[root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required  -n dev
......
Events:
  Type     Reason            Age        From               Message
  ----     ------            ----       ----               -------
  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 2 node(s) didn't match pod affinity rules, 1 node(s) had taints that the pod didn't tolerate.

# 接下来修改  values: [&quot;xxx&quot;,&quot;yyy&quot;]-----&gt;values:[&quot;pro&quot;,&quot;yyy&quot;]
# 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上
[root@k8s-master01 ~]# vim pod-podaffinity-required.yaml

# 然后重新创建pod，查看效果
[root@k8s-master01 ~]# kubectl delete -f  pod-podaffinity-required.yaml
pod &quot;pod-podaffinity-required&quot; deleted
[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml
pod/pod-podaffinity-required created

# 发现此时Pod运行正常
[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev
NAME                       READY   STATUS    RESTARTS   AGE   LABELS
pod-podaffinity-required   1/1     Running   0          6s    &lt;none&gt;
</code></pre>
<p>关于<code>PodAffinity</code>的 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，这里不再演示。</p>
<p><strong>PodAntiAffinity</strong></p>
<p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p>
<p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p>
<p>1）继续使用上个案例中目标pod</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels
NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS
pod-podaffinity-required 1/1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     
pod-podaffinity-target   1/1     Running   0          9m25s   10.244.1.37   node1   podenv=pro
</code></pre>
<p>2）创建pod-podantiaffinity-required.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-podantiaffinity-required
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  affinity:  #亲和性设置
    podAntiAffinity: #设置pod亲和性
      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制
      - labelSelector:
          matchExpressions: # 匹配podenv的值在[&quot;pro&quot;]中的标签
          - key: podenv
            operator: In
            values: [&quot;pro&quot;]
        topologyKey: kubernetes.io/hostname
</code></pre>
<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=pro的pod不在同一Node上，运行测试一下。</p>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yaml
pod/pod-podantiaffinity-required created

# 查看pod
# 发现调度到了node2上
[root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide
NAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. 
pod-podantiaffinity-required   1/1     Running   0          30s   10.244.1.96   node2  ..
</code></pre>
<h3 id="543-污点和容忍">5.4.3 污点和容忍</h3>
<p><strong>污点（Taints）</strong></p>
<p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gzkgqbjj30j8043q3c.jpg" alt="image-20200605021606508" loading="lazy"></figure>
<p>使用kubectl设置和去除污点的命令示例如下：</p>
<pre><code class="language-shell"># 设置污点
kubectl taint nodes node1 key=value:effect

# 去除污点
kubectl taint nodes node1 key:effect-

# 去除所有污点
kubectl taint nodes node1 key-
</code></pre>
<p>接下来，演示下污点的效果：</p>
<ol>
<li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li>
<li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常 pod2 失败 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li>
</ol>
<pre><code class="language-shell"># 为node1设置污点(PreferNoSchedule)
[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:PreferNoSchedule

# 创建pod1
[root@k8s-master01 ~]# kubectl run taint1 --image=nginx:1.17.1 -n dev
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   
taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1    

# 为node1设置污点(取消PreferNoSchedule，设置NoSchedule)
[root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule-
[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoSchedule

# 创建pod2
[root@k8s-master01 ~]# kubectl run taint2 --image=nginx:1.17.1 -n dev
[root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide
NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE
taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1 
taint2-544694789-6zmlf    0/1     Pending   0          21s     &lt;none&gt;        &lt;none&gt;   

# 为node1设置污点(取消NoSchedule，设置NoExecute)
[root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule-
[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoExecute

# 创建pod3
[root@k8s-master01 ~]# kubectl run taint3 --image=nginx:1.17.1 -n dev
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED 
taint1-7665f7fd85-htkmp   0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    
taint2-544694789-bn7wb    0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     
taint3-6d78dbd749-tktkq   0/1     Pending   0          6s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     
</code></pre>
<pre><code>小提示：
    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.
</code></pre>
<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p>
<figure data-type="image" tabindex="20"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gzpiycoj30sb09cwff.jpg" alt="image-20200514095913741" loading="lazy"></figure>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p>
</blockquote>
<p>下面先通过一个案例看下效果：</p>
<ol>
<li>上一小节，已经在node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li>
<li>本小节，可以通过给pod添加容忍，然后将其调度上去</li>
</ol>
<p>创建pod-toleration.yaml,内容如下</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-toleration
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
  tolerations:      # 添加容忍
  - key: &quot;tag&quot;        # 要容忍的污点的key
    operator: &quot;Equal&quot; # 操作符
    value: &quot;heima&quot;    # 容忍的污点的value
    effect: &quot;NoExecute&quot;   # 添加容忍的规则，这里必须和标记的污点规则相同
</code></pre>
<pre><code class="language-shell"># 添加容忍之前的pod
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED 
pod-toleration   0/1     Pending   0          3s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           

# 添加容忍之后的pod
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED
pod-toleration   1/1     Running   0          3s    10.244.1.62   node1   &lt;none&gt;        
</code></pre>
<p>下面看一下容忍的详细配置:</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations
......
FIELDS:
   key       # 对应着要容忍的污点的键，空意味着匹配所有的键
   value     # 对应着要容忍的污点的值
   operator  # key-value的运算符，支持Equal和Exists（默认）
   effect    # 对应污点的effect，空意味着匹配所有影响
   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间
</code></pre>
<h1 id="6-pod控制器详解">6. Pod控制器详解</h1>
<h2 id="61-pod控制器介绍">6.1 Pod控制器介绍</h2>
<p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p>
<ul>
<li>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</li>
<li>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</li>
</ul>
<blockquote>
<p><strong><code>什么是Pod控制器</code></strong></p>
<p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p>
</blockquote>
<p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</li>
<li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li>
<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li>
<li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li>
<li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li>
<li>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</li>
<li>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</li>
<li>StatefulSet：管理有状态应用</li>
</ul>
<h2 id="62-replicasetrs">6.2 ReplicaSet(RS)</h2>
<p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gztv5ppj30go055aab.jpg" alt="img" loading="lazy"></figure>
<p>ReplicaSet的资源清单文件：</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # 版本号
kind: ReplicaSet # 类型       
metadata: # 元数据
  name: # rs名称 
  namespace: # 所属命名空间 
  labels: #标签
    controller: rs
spec: # 详情描述
  replicas: 3 # 副本数量
  selector: # 选择器，通过它指定该控制器管理哪些pod
    matchLabels:      # Labels匹配规则
      app: nginx-pod
    matchExpressions: # Expressions匹配规则
      - {key: app, operator: In, values: [nginx-pod]}
  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
</code></pre>
<p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p>
<ul>
<li>
<p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p>
</li>
<li>
<p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制</p>
<p>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p>
</li>
<li>
<p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</p>
</li>
</ul>
<p><strong>创建ReplicaSet</strong></p>
<p>创建pc-replicaset.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: ReplicaSet   
metadata:
  name: pc-replicaset
  namespace: dev
spec:
  replicas: 3
  selector: 
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
</code></pre>
<pre><code class="language-shell"># 创建rs
[root@k8s-master01 ~]# kubectl create -f pc-replicaset.yaml
replicaset.apps/pc-replicaset created

# 查看rs
# DESIRED:期望副本数量  
# CURRENT:当前副本数量  
# READY:已经准备好提供服务的副本数量
[root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wide
NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR
pc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app=nginx-pod

# 查看当前控制器创建出来的pod
# 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码
[root@k8s-master01 ~]# kubectl get pod -n dev
NAME                          READY   STATUS    RESTARTS   AGE
pc-replicaset-6vmvt   1/1     Running   0          54s
pc-replicaset-fmb8f   1/1     Running   0          54s
pc-replicaset-snrk2   1/1     Running   0          54s
</code></pre>
<p><strong>扩缩容</strong></p>
<pre><code class="language-shell"># 编辑rs的副本数量，修改spec:replicas: 6即可
[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev
replicaset.apps/pc-replicaset edited

# 查看pod
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                          READY   STATUS    RESTARTS   AGE
pc-replicaset-6vmvt   1/1     Running   0          114m
pc-replicaset-cftnp   1/1     Running   0          10s
pc-replicaset-fjlm6   1/1     Running   0          10s
pc-replicaset-fmb8f   1/1     Running   0          114m
pc-replicaset-s2whj   1/1     Running   0          10s
pc-replicaset-snrk2   1/1     Running   0          114m

# 当然也可以直接使用命令实现
# 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可
[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n dev
replicaset.apps/pc-replicaset scaled

# 命令运行完毕，立即查看，发现已经有4个开始准备退出了
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                       READY   STATUS        RESTARTS   AGE
pc-replicaset-6vmvt   0/1     Terminating   0          118m
pc-replicaset-cftnp   0/1     Terminating   0          4m17s
pc-replicaset-fjlm6   0/1     Terminating   0          4m17s
pc-replicaset-fmb8f   1/1     Running       0          118m
pc-replicaset-s2whj   0/1     Terminating   0          4m17s
pc-replicaset-snrk2   1/1     Running       0          118m

#稍等片刻，就只剩下2个了
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                       READY   STATUS    RESTARTS   AGE
pc-replicaset-fmb8f   1/1     Running   0          119m
pc-replicaset-snrk2   1/1     Running   0          119m
</code></pre>
<p><strong>镜像升级</strong></p>
<pre><code class="language-shell"># 编辑rs的容器镜像 - image: nginx:1.17.2
[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev
replicaset.apps/pc-replicaset edited

# 再次查看，发现镜像版本已经变更了
[root@k8s-master01 ~]# kubectl get rs -n dev -o wide
NAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...
pc-replicaset       2        2         2       140m   nginx         nginx:1.17.2  ...

# 同样的道理，也可以使用命令完成这个工作
# kubectl set image rs rs名称 容器=镜像版本 -n namespace
[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n dev
replicaset.apps/pc-replicaset image updated

# 再次查看，发现镜像版本已经变更了
[root@k8s-master01 ~]# kubectl get rs -n dev -o wide
NAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...
pc-replicaset        2        2         2       145m   nginx        nginx:1.17.1 ... 
</code></pre>
<p><strong>删除ReplicaSet</strong></p>
<pre><code class="language-shell"># 使用kubectl delete命令会删除此RS以及它管理的Pod
# 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除
[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev
replicaset.apps &quot;pc-replicaset&quot; deleted
[root@k8s-master01 ~]# kubectl get pod -n dev -o wide
No resources found in dev namespace.

# 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。
[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=false
replicaset.apps &quot;pc-replicaset&quot; deleted
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                  READY   STATUS    RESTARTS   AGE
pc-replicaset-cl82j   1/1     Running   0          75s
pc-replicaset-dslhb   1/1     Running   0          75s

# 也可以使用yaml直接删除(推荐)
[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml
replicaset.apps &quot;pc-replicaset&quot; deleted
</code></pre>
<h2 id="63-deploymentdeploy">6.3 Deployment(Deploy)</h2>
<p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0gzyelmqj30gw05q3yv.jpg" alt="img" loading="lazy"></figure>
<p>Deployment主要功能有下面几个：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持滚动升级和回滚版本</li>
</ul>
<p>Deployment的资源清单文件：</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # 版本号
kind: Deployment # 类型       
metadata: # 元数据
  name: # rs名称 
  namespace: # 所属命名空间 
  labels: #标签
    controller: deploy
spec: # 详情描述
  replicas: 3 # 副本数量
  revisionHistoryLimit: 3 # 保留历史版本
  paused: false # 暂停部署，默认是false
  progressDeadlineSeconds: 600 # 部署超时时间（s），默认是600
  strategy: # 策略
    type: RollingUpdate # 滚动更新策略
    rollingUpdate: # 滚动更新
      maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数
      maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数
  selector: # 选择器，通过它指定该控制器管理哪些pod
    matchLabels:      # Labels匹配规则
      app: nginx-pod
    matchExpressions: # Expressions匹配规则
      - {key: app, operator: In, values: [nginx-pod]}
  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
</code></pre>
<p><strong>创建deployment</strong></p>
<p>创建pc-deployment.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment      
metadata:
  name: pc-deployment
  namespace: dev
spec: 
  replicas: 3
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
</code></pre>
<pre><code class="language-shell"># 创建deployment
[root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record=true
deployment.apps/pc-deployment created

# 查看deployment
# UP-TO-DATE 最新版本的pod的数量
# AVAILABLE  当前可用的pod的数量
[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev
NAME            READY   UP-TO-DATE   AVAILABLE   AGE
pc-deployment   3/3     3            3           15s

# 查看rs
# 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串
[root@k8s-master01 ~]# kubectl get rs -n dev
NAME                       DESIRED   CURRENT   READY   AGE
pc-deployment-6696798b78   3         3         3       23s

# 查看pod
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-6696798b78-d2c8n   1/1     Running   0          107s
pc-deployment-6696798b78-smpvp   1/1     Running   0          107s
pc-deployment-6696798b78-wvjd8   1/1     Running   0          107s
</code></pre>
<p><strong>扩缩容</strong></p>
<pre><code class="language-shell"># 变更副本数量为5个
[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5  -n dev
deployment.apps/pc-deployment scaled

# 查看deployment
[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev
NAME            READY   UP-TO-DATE   AVAILABLE   AGE
pc-deployment   5/5     5            5           2m

# 查看pod
[root@k8s-master01 ~]#  kubectl get pods -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-6696798b78-d2c8n   1/1     Running   0          4m19s
pc-deployment-6696798b78-jxmdq   1/1     Running   0          94s
pc-deployment-6696798b78-mktqv   1/1     Running   0          93s
pc-deployment-6696798b78-smpvp   1/1     Running   0          4m19s
pc-deployment-6696798b78-wvjd8   1/1     Running   0          4m19s

# 编辑deployment的副本数量，修改spec:replicas: 4即可
[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev
deployment.apps/pc-deployment edited

# 查看pod
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-6696798b78-d2c8n   1/1     Running   0          5m23s
pc-deployment-6696798b78-jxmdq   1/1     Running   0          2m38s
pc-deployment-6696798b78-smpvp   1/1     Running   0          5m23s
pc-deployment-6696798b78-wvjd8   1/1     Running   0          5m23s
</code></pre>
<p><strong>镜像更新</strong></p>
<p>deployment支持两种更新策略:<code>重建更新</code>和<code>滚动更新</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p>
<pre><code class="language-yaml">strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：
  type：指定策略类型，支持两种策略
    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod
    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod
  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：
    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。
    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。
</code></pre>
<p>重建更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<pre><code class="language-yaml">spec:
  strategy: # 策略
    type: Recreate # 重建更新
</code></pre>
<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<pre><code class="language-shell"># 变更镜像
[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev
deployment.apps/pc-deployment image updated

# 观察升级过程
[root@k8s-master01 ~]#  kubectl get pods -n dev -w
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-5d89bdfbf9-65qcw   1/1     Running   0          31s
pc-deployment-5d89bdfbf9-w5nzv   1/1     Running   0          31s
pc-deployment-5d89bdfbf9-xpt7w   1/1     Running   0          31s

pc-deployment-5d89bdfbf9-xpt7w   1/1     Terminating   0          41s
pc-deployment-5d89bdfbf9-65qcw   1/1     Terminating   0          41s
pc-deployment-5d89bdfbf9-w5nzv   1/1     Terminating   0          41s

pc-deployment-675d469f8b-grn8z   0/1     Pending       0          0s
pc-deployment-675d469f8b-hbl4v   0/1     Pending       0          0s
pc-deployment-675d469f8b-67nz2   0/1     Pending       0          0s

pc-deployment-675d469f8b-grn8z   0/1     ContainerCreating   0          0s
pc-deployment-675d469f8b-hbl4v   0/1     ContainerCreating   0          0s
pc-deployment-675d469f8b-67nz2   0/1     ContainerCreating   0          0s

pc-deployment-675d469f8b-grn8z   1/1     Running             0          1s
pc-deployment-675d469f8b-67nz2   1/1     Running             0          1s
pc-deployment-675d469f8b-hbl4v   1/1     Running             0          2s
</code></pre>
<p>滚动更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<pre><code class="language-yaml">spec:
  strategy: # 策略
    type: RollingUpdate # 滚动更新策略
    rollingUpdate:
      maxSurge: 25% 
      maxUnavailable: 25%
</code></pre>
<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<pre><code class="language-shell"># 变更镜像
[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev 
deployment.apps/pc-deployment image updated

# 观察升级过程
[root@k8s-master01 ~]# kubectl get pods -n dev -w
NAME                           READY   STATUS    RESTARTS   AGE
pc-deployment-c848d767-8rbzt   1/1     Running   0          31m
pc-deployment-c848d767-h4p68   1/1     Running   0          31m
pc-deployment-c848d767-hlmz4   1/1     Running   0          31m
pc-deployment-c848d767-rrqcn   1/1     Running   0          31m

pc-deployment-966bf7f44-226rx   0/1     Pending             0          0s
pc-deployment-966bf7f44-226rx   0/1     ContainerCreating   0          0s
pc-deployment-966bf7f44-226rx   1/1     Running             0          1s
pc-deployment-c848d767-h4p68    0/1     Terminating         0          34m

pc-deployment-966bf7f44-cnd44   0/1     Pending             0          0s
pc-deployment-966bf7f44-cnd44   0/1     ContainerCreating   0          0s
pc-deployment-966bf7f44-cnd44   1/1     Running             0          2s
pc-deployment-c848d767-hlmz4    0/1     Terminating         0          34m

pc-deployment-966bf7f44-px48p   0/1     Pending             0          0s
pc-deployment-966bf7f44-px48p   0/1     ContainerCreating   0          0s
pc-deployment-966bf7f44-px48p   1/1     Running             0          0s
pc-deployment-c848d767-8rbzt    0/1     Terminating         0          34m

pc-deployment-966bf7f44-dkmqp   0/1     Pending             0          0s
pc-deployment-966bf7f44-dkmqp   0/1     ContainerCreating   0          0s
pc-deployment-966bf7f44-dkmqp   1/1     Running             0          2s
pc-deployment-c848d767-rrqcn    0/1     Terminating         0          34m

# 至此，新版本的pod创建完毕，就版本的pod销毁完毕
# 中间过程是滚动进行的，也就是边销毁边创建
</code></pre>
<p>滚动更新的过程：</p>
<figure data-type="image" tabindex="23"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h04059vj30v20enju0.jpg" alt="img" loading="lazy"></figure>
<p>镜像更新中rs的变化</p>
<pre><code class="language-shell"># 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4
# 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释
[root@k8s-master01 ~]# kubectl get rs -n dev
NAME                       DESIRED   CURRENT   READY   AGE
pc-deployment-6696798b78   0         0         0       7m37s
pc-deployment-6696798b11   0         0         0       5m37s
pc-deployment-c848d76789   4         4         4       72s
</code></pre>
<p><strong>版本回退</strong></p>
<p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p>
<p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p>
<ul>
<li>status 显示当前升级状态</li>
<li>history 显示 升级历史记录</li>
<li>pause 暂停版本升级过程</li>
<li>resume 继续已经暂停的版本升级过程</li>
<li>restart 重启版本升级过程</li>
<li>undo 回滚到上一级版本（可以使用--to-revision回滚到指定版本）</li>
</ul>
<pre><code class="language-shell"># 查看当前升级版本的状态
[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev
deployment &quot;pc-deployment&quot; successfully rolled out

# 查看升级历史记录
[root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev
deployment.apps/pc-deployment
REVISION  CHANGE-CAUSE
1         kubectl create --filename=pc-deployment.yaml --record=true
2         kubectl create --filename=pc-deployment.yaml --record=true
3         kubectl create --filename=pc-deployment.yaml --record=true
# 可以发现有三次版本记录，说明完成过两次升级

# 版本回滚
# 这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本
[root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev
deployment.apps/pc-deployment rolled back

# 查看发现，通过nginx镜像版本可以发现到了第一版
[root@k8s-master01 ~]# kubectl get deploy -n dev -o wide
NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         
pc-deployment   4/4     4            4           74m   nginx        nginx:1.17.1   

# 查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行
# 其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，
# 一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了
[root@k8s-master01 ~]# kubectl get rs -n dev
NAME                       DESIRED   CURRENT   READY   AGE
pc-deployment-6696798b78   4         4         4       78m
pc-deployment-966bf7f44    0         0         0       37m
pc-deployment-c848d767     0         0         0       71m
</code></pre>
<p><strong>金丝雀发布</strong></p>
<p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p>
<p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p>
<pre><code class="language-shell"># 更新deployment的版本，并配置暂停deployment
[root@k8s-master01 ~]#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev
deployment.apps/pc-deployment image updated
deployment.apps/pc-deployment paused

#观察更新状态
[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　
Waiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...

# 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令

[root@k8s-master01 ~]# kubectl get rs -n dev -o wide
NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         
pc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   
pc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   
pc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   
[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-5d89bdfbf9-rj8sq   1/1     Running   0          7m33s
pc-deployment-5d89bdfbf9-ttwgg   1/1     Running   0          7m35s
pc-deployment-5d89bdfbf9-v4wvc   1/1     Running   0          7m34s
pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          3m31s
pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          3m31s

# 确保更新的pod没问题了，继续更新
[root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n dev
deployment.apps/pc-deployment resumed

# 查看最后的更新情况
[root@k8s-master01 ~]# kubectl get rs -n dev -o wide
NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         
pc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   
pc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   
pc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   

[root@k8s-master01 ~]# kubectl get pods -n dev
NAME                             READY   STATUS    RESTARTS   AGE
pc-deployment-6c9f56fcfb-7bfwh   1/1     Running   0          37s
pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          5m27s
pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          5m27s
pc-deployment-6c9f56fcfb-rf84v   1/1     Running   0          37s
</code></pre>
<p><strong>删除Deployment</strong></p>
<pre><code class="language-shell"># 删除deployment，其下的rs和pod也将被删除
[root@k8s-master01 ~]# kubectl delete -f pc-deployment.yaml
deployment.apps &quot;pc-deployment&quot; deleted
</code></pre>
<h2 id="64-horizontal-pod-autoscalerhpa">6.4 Horizontal Pod Autoscaler(HPA)</h2>
<p>在前面的课程中，我们已经可以实现通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标--自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p>
<p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p>
<figure data-type="image" tabindex="24"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h08uypfj30ha0ae3z2.jpg" alt="img" loading="lazy"></figure>
<p>接下来，我们来做一个实验</p>
<p><strong>1 安装metrics-server</strong></p>
<p>metrics-server可以用来收集集群中的资源使用情况</p>
<pre><code class="language-shell"># 安装git
[root@k8s-master01 ~]# yum install git -y
# 获取metrics-server, 注意使用的版本
[root@k8s-master01 ~]# git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server
# 修改deployment, 注意修改的是镜像和初始化参数
[root@k8s-master01 ~]# cd /root/metrics-server/deploy/1.8+/
[root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml
按图中添加下面选项
hostNetwork: true
image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6
args:
- --kubelet-insecure-tls
- --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h0dzzk2j314i0bmjv0.jpg" alt="image-20200608163326496" loading="lazy"></figure>
<pre><code class="language-shell"># 安装metrics-server
[root@k8s-master01 1.8+]# kubectl apply -f ./

# 查看pod运行情况
[root@k8s-master01 1.8+]# kubectl get pod -n kube-system
metrics-server-6b976979db-2xwbj   1/1     Running   0          90s

# 使用kubectl top node 查看资源使用情况
[root@k8s-master01 1.8+]# kubectl top node
NAME           CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%
k8s-master01   289m         14%    1582Mi          54%       
k8s-node01     81m          4%     1195Mi          40%       
k8s-node02     72m          3%     1211Mi          41%  
[root@k8s-master01 1.8+]# kubectl top pod -n kube-system
NAME                              CPU(cores)   MEMORY(bytes)
coredns-6955765f44-7ptsb          3m           9Mi
coredns-6955765f44-vcwr5          3m           8Mi
etcd-master                       14m          145Mi
...
# 至此,metrics-server安装完成
</code></pre>
<p><strong>2 准备deployment和servie</strong></p>
<p>创建pc-hpa-pod.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: dev
spec:
  strategy: # 策略
    type: RollingUpdate # 滚动更新策略
  replicas: 1
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        resources: # 资源配额
          limits:  # 限制资源（上限）
            cpu: &quot;1&quot; # CPU限制，单位是core数
          requests: # 请求资源（下限）
            cpu: &quot;100m&quot;  # CPU限制，单位是core数
</code></pre>
<pre><code class="language-shell"># 创建service
[root@k8s-master01 1.8+]# kubectl expose deployment nginx --type=NodePort --port=80 -n dev
</code></pre>
<pre><code class="language-shell"># 查看
[root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n dev
NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx   1/1     1            1           47s

NAME                         READY   STATUS    RESTARTS   AGE
pod/nginx-7df9756ccc-bh8dr   1/1     Running   0          47s

NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
service/nginx   NodePort   10.101.18.29   &lt;none&gt;        80:31830/TCP   35s
</code></pre>
<p><strong>3 部署HPA</strong></p>
<p>创建pc-hpa.yaml文件，内容如下：</p>
<pre><code class="language-yaml">apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: pc-hpa
  namespace: dev
spec:
  minReplicas: 1  #最小pod数量
  maxReplicas: 10 #最大pod数量
  targetCPUUtilizationPercentage: 3 # CPU使用率指标
  scaleTargetRef:   # 指定要控制的nginx信息
    apiVersion: apps/v1
    kind: Deployment
    name: nginx
</code></pre>
<pre><code class="language-shell"># 创建hpa
[root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yaml
horizontalpodautoscaler.autoscaling/pc-hpa created

# 查看hpa
    [root@k8s-master01 1.8+]# kubectl get hpa -n dev
NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
pc-hpa   Deployment/nginx   0%/3%     1         10        1          62s
</code></pre>
<p><strong>4 测试</strong></p>
<p>使用压测工具对service地址<code>192.168.5.4:31830</code>进行压测，然后通过控制台查看hpa和pod的变化</p>
<p>hpa变化</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl get hpa -n dev -w
NAME   REFERENCE      TARGETS  MINPODS  MAXPODS  REPLICAS  AGE
pc-hpa  Deployment/nginx  0%/3%   1     10     1      4m11s
pc-hpa  Deployment/nginx  0%/3%   1     10     1      5m19s
pc-hpa  Deployment/nginx  22%/3%   1     10     1      6m50s
pc-hpa  Deployment/nginx  22%/3%   1     10     4      7m5s
pc-hpa  Deployment/nginx  22%/3%   1     10     8      7m21s
pc-hpa  Deployment/nginx  6%/3%   1     10     8      7m51s
pc-hpa  Deployment/nginx  0%/3%   1     10     8      9m6s
pc-hpa  Deployment/nginx  0%/3%   1     10     8      13m
pc-hpa  Deployment/nginx  0%/3%   1     10     1      14m
</code></pre>
<p>deployment变化</p>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl get deployment -n dev -w
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   1/1     1            1           11m
nginx   1/4     1            1           13m
nginx   1/4     1            1           13m
nginx   1/4     1            1           13m
nginx   1/4     4            1           13m
nginx   1/8     4            1           14m
nginx   1/8     4            1           14m
nginx   1/8     4            1           14m
nginx   1/8     8            1           14m
nginx   2/8     8            2           14m
nginx   3/8     8            3           14m
nginx   4/8     8            4           14m
nginx   5/8     8            5           14m
nginx   6/8     8            6           14m
nginx   7/8     8            7           14m
nginx   8/8     8            8           15m
nginx   8/1     8            8           20m
nginx   8/1     8            8           20m
nginx   1/1     1            1           20m
</code></pre>
<p>pod变化</p>
<pre><code>[root@k8s-master01 ~]# kubectl get pods -n dev -w
NAME                     READY   STATUS    RESTARTS   AGE
nginx-7df9756ccc-bh8dr   1/1     Running   0          11m
nginx-7df9756ccc-cpgrv   0/1     Pending   0          0s
nginx-7df9756ccc-8zhwk   0/1     Pending   0          0s
nginx-7df9756ccc-rr9bn   0/1     Pending   0          0s
nginx-7df9756ccc-cpgrv   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-8zhwk   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-rr9bn   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-m9gsj   0/1     Pending             0          0s
nginx-7df9756ccc-g56qb   0/1     Pending             0          0s
nginx-7df9756ccc-sl9c6   0/1     Pending             0          0s
nginx-7df9756ccc-fgst7   0/1     Pending             0          0s
nginx-7df9756ccc-g56qb   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-m9gsj   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-sl9c6   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-fgst7   0/1     ContainerCreating   0          0s
nginx-7df9756ccc-8zhwk   1/1     Running             0          19s
nginx-7df9756ccc-rr9bn   1/1     Running             0          30s
nginx-7df9756ccc-m9gsj   1/1     Running             0          21s
nginx-7df9756ccc-cpgrv   1/1     Running             0          47s
nginx-7df9756ccc-sl9c6   1/1     Running             0          33s
nginx-7df9756ccc-g56qb   1/1     Running             0          48s
nginx-7df9756ccc-fgst7   1/1     Running             0          66s
nginx-7df9756ccc-fgst7   1/1     Terminating         0          6m50s
nginx-7df9756ccc-8zhwk   1/1     Terminating         0          7m5s
nginx-7df9756ccc-cpgrv   1/1     Terminating         0          7m5s
nginx-7df9756ccc-g56qb   1/1     Terminating         0          6m50s
nginx-7df9756ccc-rr9bn   1/1     Terminating         0          7m5s
nginx-7df9756ccc-m9gsj   1/1     Terminating         0          6m50s
nginx-7df9756ccc-sl9c6   1/1     Terminating         0          6m50s
</code></pre>
<h2 id="65-daemonsetds">6.5 DaemonSet(DS)</h2>
<p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<figure data-type="image" tabindex="26"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h0kzoppj30j107fmxu.jpg" alt="img" loading="lazy"></figure>
<p>DaemonSet控制器的特点：</p>
<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
</ul>
<p>下面先来看下DaemonSet的资源清单文件</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # 版本号
kind: DaemonSet # 类型       
metadata: # 元数据
  name: # rs名称 
  namespace: # 所属命名空间 
  labels: #标签
    controller: daemonset
spec: # 详情描述
  revisionHistoryLimit: 3 # 保留历史版本
  updateStrategy: # 更新策略
    type: RollingUpdate # 滚动更新策略
    rollingUpdate: # 滚动更新
      maxUnavailable: 1 # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数
  selector: # 选择器，通过它指定该控制器管理哪些pod
    matchLabels:      # Labels匹配规则
      app: nginx-pod
    matchExpressions: # Expressions匹配规则
      - {key: app, operator: In, values: [nginx-pod]}
  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
</code></pre>
<p>创建pc-daemonset.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: DaemonSet      
metadata:
  name: pc-daemonset
  namespace: dev
spec: 
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
</code></pre>
<pre><code class="language-shell"># 创建daemonset
[root@k8s-master01 ~]# kubectl create -f  pc-daemonset.yaml
daemonset.apps/pc-daemonset created

# 查看daemonset
[root@k8s-master01 ~]#  kubectl get ds -n dev -o wide
NAME        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE   AGE   CONTAINERS   IMAGES         
pc-daemonset   2        2        2      2           2        24s   nginx        nginx:1.17.1   

# 查看pod,发现在每个Node上都运行一个pod
[root@k8s-master01 ~]#  kubectl get pods -n dev -o wide
NAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    
pc-daemonset-9bck8   1/1     Running   0          37s   10.244.1.43   node1     
pc-daemonset-k224w   1/1     Running   0          37s   10.244.2.74   node2      

# 删除daemonset
[root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yaml
daemonset.apps &quot;pc-daemonset&quot; deleted
</code></pre>
<h2 id="66-job">6.6 Job</h2>
<p>Job，主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务。Job特点如下：</p>
<ul>
<li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li>
<li>当成功结束的pod达到指定的数量时，Job将完成执行</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h0p7fasj30m9072aah.jpg" alt="img" loading="lazy"></figure>
<p>Job的资源清单文件：</p>
<pre><code class="language-yaml">apiVersion: batch/v1 # 版本号
kind: Job # 类型       
metadata: # 元数据
  name: # rs名称 
  namespace: # 所属命名空间 
  labels: #标签
    controller: job
spec: # 详情描述
  completions: 1 # 指定job需要成功运行Pods的次数。默认值: 1
  parallelism: 1 # 指定job在任一时刻应该并发运行Pods的数量。默认值: 1
  activeDeadlineSeconds: 30 # 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。
  backoffLimit: 6 # 指定job失败后进行重试的次数。默认是6
  manualSelector: true # 是否可以使用selector选择器选择pod，默认是false
  selector: # 选择器，通过它指定该控制器管理哪些pod
    matchLabels:      # Labels匹配规则
      app: counter-pod
    matchExpressions: # Expressions匹配规则
      - {key: app, operator: In, values: [counter-pod]}
  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本
    metadata:
      labels:
        app: counter-pod
    spec:
      restartPolicy: Never # 重启策略只能设置为Never或者OnFailure
      containers:
      - name: counter
        image: busybox:1.30
        command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;]
</code></pre>
<pre><code>关于重启策略设置的说明：
    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变
    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1
    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always
</code></pre>
<p>创建pc-job.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job      
metadata:
  name: pc-job
  namespace: dev
spec:
  manualSelector: true
  selector:
    matchLabels:
      app: counter-pod
  template:
    metadata:
      labels:
        app: counter-pod
    spec:
      restartPolicy: Never
      containers:
      - name: counter
        image: busybox:1.30
        command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]
</code></pre>
<pre><code class="language-shell"># 创建job
[root@k8s-master01 ~]# kubectl create -f pc-job.yaml
job.batch/pc-job created

# 查看job
[root@k8s-master01 ~]# kubectl get job -n dev -o wide  -w
NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR
pc-job   0/1           21s        21s   counter      busybox:1.30   app=counter-pod
pc-job   1/1           31s        79s   counter      busybox:1.30   app=counter-pod

# 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态
[root@k8s-master01 ~]# kubectl get pods -n dev -w
NAME           READY   STATUS     RESTARTS      AGE
pc-job-rxg96   1/1     Running     0            29s
pc-job-rxg96   0/1     Completed   0            33s

# 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项
#  completions: 6 # 指定job需要成功运行Pods的次数为6
#  parallelism: 3 # 指定job并发运行Pods的数量为3
#  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod
[root@k8s-master01 ~]# kubectl get pods -n dev -w
NAME           READY   STATUS    RESTARTS   AGE
pc-job-684ft   1/1     Running   0          5s
pc-job-jhj49   1/1     Running   0          5s
pc-job-pfcvh   1/1     Running   0          5s
pc-job-684ft   0/1     Completed   0          11s
pc-job-v7rhr   0/1     Pending     0          0s
pc-job-v7rhr   0/1     Pending     0          0s
pc-job-v7rhr   0/1     ContainerCreating   0          0s
pc-job-jhj49   0/1     Completed           0          11s
pc-job-fhwf7   0/1     Pending             0          0s
pc-job-fhwf7   0/1     Pending             0          0s
pc-job-pfcvh   0/1     Completed           0          11s
pc-job-5vg2j   0/1     Pending             0          0s
pc-job-fhwf7   0/1     ContainerCreating   0          0s
pc-job-5vg2j   0/1     Pending             0          0s
pc-job-5vg2j   0/1     ContainerCreating   0          0s
pc-job-fhwf7   1/1     Running             0          2s
pc-job-v7rhr   1/1     Running             0          2s
pc-job-5vg2j   1/1     Running             0          3s
pc-job-fhwf7   0/1     Completed           0          12s
pc-job-v7rhr   0/1     Completed           0          12s
pc-job-5vg2j   0/1     Completed           0          12s

# 删除job
[root@k8s-master01 ~]# kubectl delete -f pc-job.yaml
job.batch &quot;pc-job&quot; deleted
</code></pre>
<h2 id="67-cronjobcj">6.7 CronJob(CJ)</h2>
<p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<figure data-type="image" tabindex="28"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h0uuni4j30n208d74v.jpg" alt="img" loading="lazy"></figure>
<p>CronJob的资源清单文件：</p>
<pre><code class="language-yaml">apiVersion: batch/v1beta1 # 版本号
kind: CronJob # 类型       
metadata: # 元数据
  name: # rs名称 
  namespace: # 所属命名空间 
  labels: #标签
    controller: cronjob
spec: # 详情描述
  schedule: # cron格式的作业调度运行时间点,用于控制任务在什么时间执行
  concurrencyPolicy: # 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业
  failedJobHistoryLimit: # 为失败的任务执行保留的历史记录数，默认为1
  successfulJobHistoryLimit: # 为成功的任务执行保留的历史记录数，默认为3
  startingDeadlineSeconds: # 启动作业错误的超时时长
  jobTemplate: # job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义
    metadata:
    spec:
      completions: 1
      parallelism: 1
      activeDeadlineSeconds: 30
      backoffLimit: 6
      manualSelector: true
      selector:
        matchLabels:
          app: counter-pod
        matchExpressions: 规则
          - {key: app, operator: In, values: [counter-pod]}
      template:
        metadata:
          labels:
            app: counter-pod
        spec:
          restartPolicy: Never 
          containers:
          - name: counter
            image: busybox:1.30
            command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;]
</code></pre>
<pre><code class="language-yaml">需要重点解释的几个选项：
schedule: cron表达式，用于指定任务的执行时间
    */1    *      *    *     *
    &lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;

    分钟 值从 0 到 59.
    小时 值从 0 到 23.
    日 值从 1 到 31.
    月 值从 1 到 12.
    星期 值从 0 到 6, 0 代表星期日
    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...
concurrencyPolicy:
    Allow:   允许Jobs并发运行(默认)
    Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行
    Replace: 替换，取消当前正在运行的作业并用新作业替换它
</code></pre>
<p>创建pc-cronjob.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: pc-cronjob
  namespace: dev
  labels:
    controller: cronjob
spec:
  schedule: &quot;*/1 * * * *&quot;
  jobTemplate:
    metadata:
    spec:
      template:
        spec:
          restartPolicy: Never
          containers:
          - name: counter
            image: busybox:1.30
            command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]
</code></pre>
<pre><code class="language-shell"># 创建cronjob
[root@k8s-master01 ~]# kubectl create -f pc-cronjob.yaml
cronjob.batch/pc-cronjob created

# 查看cronjob
[root@k8s-master01 ~]# kubectl get cronjobs -n dev
NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
pc-cronjob   */1 * * * *   False     0        &lt;none&gt;          6s

# 查看job
[root@k8s-master01 ~]# kubectl get jobs -n dev
NAME                    COMPLETIONS   DURATION   AGE
pc-cronjob-1592587800   1/1           28s        3m26s
pc-cronjob-1592587860   1/1           28s        2m26s
pc-cronjob-1592587920   1/1           28s        86s

# 查看pod
[root@k8s-master01 ~]# kubectl get pods -n dev
pc-cronjob-1592587800-x4tsm   0/1     Completed   0          2m24s
pc-cronjob-1592587860-r5gv4   0/1     Completed   0          84s
pc-cronjob-1592587920-9dxxq   1/1     Running     0          24s


# 删除cronjob
[root@k8s-master01 ~]# kubectl  delete -f pc-cronjob.yaml
cronjob.batch &quot;pc-cronjob&quot; deleted
</code></pre>
<h1 id="7-service详解">7. Service详解</h1>
<h2 id="71-service介绍">7.1 Service介绍</h2>
<p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p>
<figure data-type="image" tabindex="29"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h0z1vlgj30tt0dtq4q.jpg" alt="img" loading="lazy"></figure>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<figure data-type="image" tabindex="30"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h136a0gj30t409qq3v.jpg" alt="img" loading="lazy"></figure>
<pre><code># 10.97.97.97:80 是service提供的访问入口
# 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，
# kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去
# 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。
[root@node1 ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.97.97.97:80 rr
  -&gt; 10.244.1.39:80               Masq    1      0          0
  -&gt; 10.244.1.40:80               Masq    1      0          0
  -&gt; 10.244.2.33:80               Masq    1      0          0
</code></pre>
<p>kube-proxy目前支持三种工作模式:</p>
<p><strong>userspace 模式</strong></p>
<p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。  该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<figure data-type="image" tabindex="31"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h162n35j30nn0ek75z.jpg" alt="img" loading="lazy"></figure>
<p><strong>iptables 模式</strong></p>
<p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<figure data-type="image" tabindex="32"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h19cj8nj30n90hu40b.jpg" alt="img" loading="lazy"></figure>
<p><strong>ipvs 模式</strong></p>
<p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<figure data-type="image" tabindex="33"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h1d2wx1j30ms0hltad.jpg" alt="img" loading="lazy"></figure>
<pre><code class="language-shell"># 此模式必须安装ipvs内核模块，否则会降级为iptables
# 开启ipvs
[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system
# 修改mode: &quot;ipvs&quot;
[root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system
[root@node1 ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.97.97.97:80 rr
  -&gt; 10.244.1.39:80               Masq    1      0          0
  -&gt; 10.244.1.40:80               Masq    1      0          0
  -&gt; 10.244.2.33:80               Masq    1      0          0
</code></pre>
<h2 id="72-service类型">7.2 Service类型</h2>
<p>Service的资源清单文件：</p>
<pre><code class="language-yaml">kind: Service  # 资源类型
apiVersion: v1  # 资源版本
metadata: # 元数据
  name: service # 资源名称
  namespace: dev # 命名空间
spec: # 描述
  selector: # 标签选择器，用于确定当前service代理哪些pod
    app: nginx
  type: # Service类型，指定service的访问方式
  clusterIP:  # 虚拟服务的ip地址
  sessionAffinity: # session亲和性，支持ClientIP、None两个选项
  ports: # 端口信息
    - protocol: TCP 
      port: 3017  # service端口
      targetPort: 5003 # pod端口
      nodePort: 31122 # 主机端口
</code></pre>
<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h2 id="73-service使用">7.3 Service使用</h2>
<h3 id="731-实验环境准备">7.3.1 实验环境准备</h3>
<p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建deployment.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment      
metadata:
  name: pc-deployment
  namespace: dev
spec: 
  replicas: 3
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
</code></pre>
<pre><code class="language-shell">[root@k8s-master01 ~]# kubectl create -f deployment.yaml
deployment.apps/pc-deployment created

# 查看pod详情
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels
NAME                             READY   STATUS     IP            NODE     LABELS
pc-deployment-66cb59b984-8p84h   1/1     Running    10.244.1.39   node1    app=nginx-pod
pc-deployment-66cb59b984-vx8vx   1/1     Running    10.244.2.33   node2    app=nginx-pod
pc-deployment-66cb59b984-wnncx   1/1     Running    10.244.1.40   node1    app=nginx-pod

# 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）
# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh
# echo &quot;10.244.1.39&quot; &gt; /usr/share/nginx/html/index.html

#修改完毕之后，访问测试
[root@k8s-master01 ~]# curl 10.244.1.39
10.244.1.39
[root@k8s-master01 ~]# curl 10.244.2.33
10.244.2.33
[root@k8s-master01 ~]# curl 10.244.1.40
10.244.1.40
</code></pre>
<h3 id="732-clusterip类型的service">7.3.2 ClusterIP类型的Service</h3>
<p>创建service-clusterip.yaml文件</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: service-clusterip
  namespace: dev
spec:
  selector:
    app: nginx-pod
  clusterIP: 10.97.97.97 # service的ip地址，如果不写，默认会生成一个
  type: ClusterIP
  ports:
  - port: 80  # Service端口       
    targetPort: 80 # pod端口
</code></pre>
<pre><code class="language-shell"># 创建service
[root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml
service/service-clusterip created

# 查看service
[root@k8s-master01 ~]# kubectl get svc -n dev -o wide
NAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR
service-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80/TCP    13s   app=nginx-pod

# 查看service的详细信息
# 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口
[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev
Name:              service-clusterip
Namespace:         dev
Labels:            &lt;none&gt;
Annotations:       &lt;none&gt;
Selector:          app=nginx-pod
Type:              ClusterIP
IP:                10.97.97.97
Port:              &lt;unset&gt;  80/TCP
TargetPort:        80/TCP
Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80
Session Affinity:  None
Events:            &lt;none&gt;

# 查看ipvs的映射规则
[root@k8s-master01 ~]# ipvsadm -Ln
TCP  10.97.97.97:80 rr
  -&gt; 10.244.1.39:80               Masq    1      0          0
  -&gt; 10.244.1.40:80               Masq    1      0          0
  -&gt; 10.244.2.33:80               Masq    1      0          0

# 访问10.97.97.97:80观察效果
[root@k8s-master01 ~]# curl 10.97.97.97:80
10.244.2.33
</code></pre>
<p><strong>Endpoint</strong></p>
<p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p>
<p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p>
<figure data-type="image" tabindex="34"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h1iorf4j30u70c0jts.jpg" alt="image-20200509191917069" loading="lazy"></figure>
<p><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li>
<p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li>
<p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</p>
<p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<pre><code class="language-shell"># 查看ipvs的映射规则【rr 轮询】
[root@k8s-master01 ~]# ipvsadm -Ln
TCP  10.97.97.97:80 rr
  -&gt; 10.244.1.39:80               Masq    1      0          0
  -&gt; 10.244.1.40:80               Masq    1      0          0
  -&gt; 10.244.2.33:80               Masq    1      0          0

# 循环访问测试
[root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done;
10.244.1.40
10.244.1.39
10.244.2.33
10.244.1.40
10.244.1.39
10.244.2.33

# 修改分发策略----sessionAffinity:ClientIP

# 查看ipvs规则【persistent 代表持久】
[root@k8s-master01 ~]# ipvsadm -Ln
TCP  10.97.97.97:80 rr persistent 10800
  -&gt; 10.244.1.39:80               Masq    1      0          0
  -&gt; 10.244.1.40:80               Masq    1      0          0
  -&gt; 10.244.2.33:80               Masq    1      0          0

# 循环访问测试
[root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done;
10.244.2.33
10.244.2.33
10.244.2.33
  
# 删除service
[root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml
service &quot;service-clusterip&quot; deleted
</code></pre>
<h3 id="733-headliness类型的service">7.3.3 HeadLiness类型的Service</h3>
<p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建service-headliness.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: service-headliness
  namespace: dev
spec:
  selector:
    app: nginx-pod
  clusterIP: None # 将clusterIP设置为None，即可创建headliness Service
  type: ClusterIP
  ports:
  - port: 80    
    targetPort: 80
</code></pre>
<pre><code class="language-shell"># 创建service
[root@k8s-master01 ~]# kubectl create -f service-headliness.yaml
service/service-headliness created

# 获取service， 发现CLUSTER-IP未分配
[root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wide
NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR
service-headliness   ClusterIP   None         &lt;none&gt;        80/TCP    11s   app=nginx-pod

# 查看service详情
[root@k8s-master01 ~]# kubectl describe svc service-headliness  -n dev
Name:              service-headliness
Namespace:         dev
Labels:            &lt;none&gt;
Annotations:       &lt;none&gt;
Selector:          app=nginx-pod
Type:              ClusterIP
IP:                None
Port:              &lt;unset&gt;  80/TCP
TargetPort:        80/TCP
Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80
Session Affinity:  None
Events:            &lt;none&gt;

# 查看域名的解析情况
[root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh
/ # cat /etc/resolv.conf
nameserver 10.96.0.10
search dev.svc.cluster.local svc.cluster.local cluster.local

[root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.local
service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40
service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39
service-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33
</code></pre>
<h3 id="734-nodeport类型的service">7.3.4 NodePort类型的Service</h3>
<p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<figure data-type="image" tabindex="35"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h1odu2ij30f307agly.jpg" alt="img" loading="lazy"></figure>
<p>创建service-nodeport.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: service-nodeport
  namespace: dev
spec:
  selector:
    app: nginx-pod
  type: NodePort # service类型
  ports:
  - port: 80
    nodePort: 30002 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配
    targetPort: 80
</code></pre>
<pre><code class="language-shell"># 创建service
[root@k8s-master01 ~]# kubectl create -f service-nodeport.yaml
service/service-nodeport created

# 查看service
[root@k8s-master01 ~]# kubectl get svc -n dev -o wide
NAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)       SELECTOR
service-nodeport   NodePort   10.105.64.191   &lt;none&gt;        80:30002/TCP  app=nginx-pod

# 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod
</code></pre>
<h3 id="735-loadbalancer类型的service">7.3.5 LoadBalancer类型的Service</h3>
<p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<figure data-type="image" tabindex="36"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h1t0wesj30ul0bn400.jpg" alt="img" loading="lazy"></figure>
<h3 id="736-externalname类型的service">7.3.6 ExternalName类型的Service</h3>
<p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<figure data-type="image" tabindex="37"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h1wt3pkj30ln08g0t7.jpg" alt="img" loading="lazy"></figure>
<pre><code class="language-shell">apiVersion: v1
kind: Service
metadata:
  name: service-externalname
  namespace: dev
spec:
  type: ExternalName # service类型
  externalName: www.baidu.com  #改成ip地址也可以
</code></pre>
<pre><code class="language-shell"># 创建service
[root@k8s-master01 ~]# kubectl  create -f service-externalname.yaml
service/service-externalname created

# 域名解析
[root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.local
service-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com.
www.baidu.com.          30      IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       30      IN      A       39.156.66.18
www.a.shifen.com.       30      IN      A       39.156.66.14
</code></pre>
<h2 id="74-ingress介绍">7.4 Ingress介绍</h2>
<p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li>
<li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li>
</ul>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
<figure data-type="image" tabindex="38"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h201ge9j30rk0bqq4x.jpg" alt="img" loading="lazy"></figure>
<p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<figure data-type="image" tabindex="39"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h23q6f0j30p60c1ta3.jpg" alt="img" loading="lazy"></figure>
<h2 id="75-ingress使用">7.5 Ingress使用</h2>
<h3 id="751-环境准备">7.5.1 环境准备</h3>
<p><strong>搭建ingress环境</strong></p>
<pre><code># 创建文件夹
[root@k8s-master01 ~]# mkdir ingress-controller
[root@k8s-master01 ~]# cd ingress-controller/

# 获取ingress-nginx，本次案例使用的是0.30版本
[root@k8s-master01 ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml
[root@k8s-master01 ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml

# 修改mandatory.yaml文件中的仓库
# 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0
# 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0
# 创建ingress-nginx
[root@k8s-master01 ingress-controller]# kubectl apply -f ./

# 查看ingress-nginx
[root@k8s-master01 ingress-controller]# kubectl get pod -n ingress-nginx
NAME                                           READY   STATUS    RESTARTS   AGE
pod/nginx-ingress-controller-fbf967dd5-4qpbp   1/1     Running   0          12h

# 查看service
[root@k8s-master01 ingress-controller]# kubectl get svc -n ingress-nginx
NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240/TCP,443:31335/TCP   11h
</code></pre>
<p><strong>准备service和pod</strong></p>
<p>为了后面的实验比较方便，创建如下图所示的模型</p>
<figure data-type="image" tabindex="40"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h27i7xij30pa09yjsp.jpg" alt="img" loading="lazy"></figure>
<p>创建tomcat-nginx.yaml</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: dev
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-deployment
  namespace: dev
spec:
  replicas: 3
  selector:
    matchLabels:
      app: tomcat-pod
  template:
    metadata:
      labels:
        app: tomcat-pod
    spec:
      containers:
      - name: tomcat
        image: tomcat:8.5-jre10-slim
        ports:
        - containerPort: 8080

---

apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  namespace: dev
spec:
  selector:
    app: nginx-pod
  clusterIP: None
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80

---

apiVersion: v1
kind: Service
metadata:
  name: tomcat-service
  namespace: dev
spec:
  selector:
    app: tomcat-pod
  clusterIP: None
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
</code></pre>
<pre><code class="language-shell"># 创建
[root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml

# 查看
[root@k8s-master01 ~]# kubectl get svc -n dev
NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
nginx-service    ClusterIP   None         &lt;none&gt;        80/TCP     48s
tomcat-service   ClusterIP   None         &lt;none&gt;        8080/TCP   48s
</code></pre>
<h3 id="752-http代理">7.5.2 Http代理</h3>
<p>创建ingress-http.yaml</p>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-http
  namespace: dev
spec:
  rules:
  - host: nginx.itheima.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-service
          servicePort: 80
  - host: tomcat.itheima.com
    http:
      paths:
      - path: /
        backend:
          serviceName: tomcat-service
          servicePort: 8080
</code></pre>
<pre><code class="language-shell"># 创建
[root@k8s-master01 ~]# kubectl create -f ingress-http.yaml
ingress.extensions/ingress-http created

# 查看
[root@k8s-master01 ~]# kubectl get ing ingress-http -n dev
NAME           HOSTS                                  ADDRESS   PORTS   AGE
ingress-http   nginx.itheima.com,tomcat.itheima.com             80      22s

# 查看详情
[root@k8s-master01 ~]# kubectl describe ing ingress-http  -n dev
...
Rules:
Host                Path  Backends
----                ----  --------
nginx.itheima.com   / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)
tomcat.itheima.com  / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)
...

# 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上
# 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了
</code></pre>
<h3 id="753-https代理">7.5.3 Https代理</h3>
<p>创建证书</p>
<pre><code class="language-shell"># 生成证书
openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;

# 创建密钥
kubectl create secret tls tls-secret --key tls.key --cert tls.crt
</code></pre>
<p>创建ingress-https.yaml</p>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-https
  namespace: dev
spec:
  tls:
    - hosts:
      - nginx.itheima.com
      - tomcat.itheima.com
      secretName: tls-secret # 指定秘钥
  rules:
  - host: nginx.itheima.com
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-service
          servicePort: 80
  - host: tomcat.itheima.com
    http:
      paths:
      - path: /
        backend:
          serviceName: tomcat-service
          servicePort: 8080
</code></pre>
<pre><code class="language-shell"># 创建
[root@k8s-master01 ~]# kubectl create -f ingress-https.yaml
ingress.extensions/ingress-https created

# 查看
[root@k8s-master01 ~]# kubectl get ing ingress-https -n dev
NAME            HOSTS                                  ADDRESS         PORTS     AGE
ingress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s

# 查看详情
[root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev
...
TLS:
  tls-secret terminates nginx.itheima.com,tomcat.itheima.com
Rules:
Host              Path Backends
----              ---- --------
nginx.itheima.com  /  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)
tomcat.itheima.com /  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)
...

# 下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了
</code></pre>
<h1 id="8-数据存储">8. 数据存储</h1>
<p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h2 id="81-基本存储">8.1 基本存储</h2>
<h3 id="811-emptydir">8.1.1 EmptyDir</h3>
<p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li>
<li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<figure data-type="image" tabindex="41"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h2dm06ej30qz0bmwfi.jpg" alt="img" loading="lazy"></figure>
<p>创建一个volume-emptydir.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: volume-emptydir
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - containerPort: 80
    volumeMounts:  # 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx
    - name: logs-volume
      mountPath: /var/log/nginx
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;] # 初始命令，动态读取指定文件中内容
    volumeMounts:  # 将logs-volume 挂在到busybox容器中，对应的目录为 /logs
    - name: logs-volume
      mountPath: /logs
  volumes: # 声明volume， name为logs-volume，类型为emptyDir
  - name: logs-volume
    emptyDir: {}
</code></pre>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f volume-emptydir.yaml
pod/volume-emptydir created

# 查看pod
[root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wide
NAME                  READY   STATUS    RESTARTS   AGE      IP       NODE   ...... 
volume-emptydir       2/2     Running   0          97s   10.42.2.9   node1  ......

# 通过podIp访问nginx
[root@k8s-master01 ~]# curl 10.42.2.9
......

# 通过kubectl logs命令查看指定容器的标准输出
[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox
10.42.1.0 - - [27/Jun/2021:15:08:54 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;
</code></pre>
<h3 id="812-hostpath">8.1.2 HostPath</h3>
<p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<figure data-type="image" tabindex="42"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h2hdtwsj30ve0ejjsu.jpg" alt="img" loading="lazy"></figure>
<p>创建一个volume-hostpath.yaml：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: volume-hostpath
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - containerPort: 80
    volumeMounts:
    - name: logs-volume
      mountPath: /var/log/nginx
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;]
    volumeMounts:
    - name: logs-volume
      mountPath: /logs
  volumes:
  - name: logs-volume
    hostPath: 
      path: /root/logs
      type: DirectoryOrCreate  # 目录存在就使用，不存在就先创建后使用
</code></pre>
<pre><code>关于type的值的一点说明：
    DirectoryOrCreate 目录存在就使用，不存在就先创建后使用
    Directory   目录必须存在
    FileOrCreate  文件存在就使用，不存在就先创建后使用
    File 文件必须存在 
    Socket  unix套接字必须存在
    CharDevice  字符设备必须存在
    BlockDevice 块设备必须存在
</code></pre>
<pre><code class="language-shell"># 创建Pod
[root@k8s-master01 ~]# kubectl create -f volume-hostpath.yaml
pod/volume-hostpath created

# 查看Pod
[root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......
pod-volume-hostpath   2/2     Running   0          16s   10.42.2.10     node1  ......

#访问nginx
[root@k8s-master01 ~]# curl 10.42.2.10

# 接下来就可以去host的/root/logs目录下查看存储的文件了
###  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）
[root@node1 ~]# ls /root/logs/
access.log  error.log

# 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的
</code></pre>
<h3 id="813-nfs">8.1.3 NFS</h3>
<p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<figure data-type="image" tabindex="43"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h2mfijvj31000at75s.jpg" alt="img" loading="lazy"></figure>
<p>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p>
<pre><code class="language-shell"># 在nfs上安装nfs服务
[root@nfs ~]# yum install nfs-utils -y

# 准备一个共享目录
[root@nfs ~]# mkdir /root/data/nfs -pv

# 将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机
[root@nfs ~]# vim /etc/exports
[root@nfs ~]# more /etc/exports
/root/data/nfs     192.168.5.0/24(rw,no_root_squash)

# 启动nfs服务
[root@nfs ~]# systemctl restart nfs
</code></pre>
<p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p>
<pre><code class="language-shell"># 在node上安装nfs服务，注意不需要启动
[root@k8s-master01 ~]# yum install nfs-utils -y
</code></pre>
<p>3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: volume-nfs
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    ports:
    - containerPort: 80
    volumeMounts:
    - name: logs-volume
      mountPath: /var/log/nginx
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;] 
    volumeMounts:
    - name: logs-volume
      mountPath: /logs
  volumes:
  - name: logs-volume
    nfs:
      server: 192.168.5.6  #nfs服务器地址
      path: /root/data/nfs #共享文件路径
</code></pre>
<p>4）最后，运行下pod，观察结果</p>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f volume-nfs.yaml
pod/volume-nfs created

# 查看pod
[root@k8s-master01 ~]# kubectl get pods volume-nfs -n dev
NAME                  READY   STATUS    RESTARTS   AGE
volume-nfs        2/2     Running   0          2m9s

# 查看nfs服务器上的共享目录，发现已经有文件了
[root@k8s-master01 ~]# ls /root/data/
access.log  error.log
</code></pre>
<h2 id="82-高级存储">8.2 高级存储</h2>
<p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p>
<p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p>
<figure data-type="image" tabindex="44"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h2uh4jwj30uj0hu406.jpg" alt="img" loading="lazy"></figure>
<p>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV： kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h3 id="821-pv">8.2.1 PV</h3>
<p>PV是存储资源的抽象，下面是资源清单文件:</p>
<pre><code class="language-yaml">apiVersion: v1  
kind: PersistentVolume
metadata:
  name: pv2
spec:
  nfs: # 存储类型，与底层真正存储对应
  capacity:  # 存储能力，目前只支持存储空间的设置
    storage: 2Gi
  accessModes:  # 访问模式
  storageClassName: # 存储类别
  persistentVolumeReclaimPolicy: # 回收策略
</code></pre>
<p>PV 的关键配置参数说明：</p>
<ul>
<li>
<p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li>
<p><strong>存储能力（capacity）</strong></p>
</li>
</ul>
<p>目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
<ul>
<li>
<p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li>
<p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain （保留） 保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*</li>
<li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p>
</li>
<li>
<p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li>
<li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li>
</ul>
</li>
<li>
<p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）： 表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p>
<ol>
<li>准备NFS环境</li>
</ol>
<pre><code class="language-shell"># 创建目录
[root@nfs ~]# mkdir /root/data/{pv1,pv2,pv3} -pv

# 暴露服务
[root@nfs ~]# more /etc/exports
/root/data/pv1     192.168.5.0/24(rw,no_root_squash)
/root/data/pv2     192.168.5.0/24(rw,no_root_squash)
/root/data/pv3     192.168.5.0/24(rw,no_root_squash)

# 重启服务
[root@nfs ~]#  systemctl restart nfs
</code></pre>
<ol start="2">
<li>创建pv.yaml</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name:  pv1
spec:
  capacity: 
    storage: 1Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /root/data/pv1
    server: 192.168.5.6

---

apiVersion: v1
kind: PersistentVolume
metadata:
  name:  pv2
spec:
  capacity: 
    storage: 2Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /root/data/pv2
    server: 192.168.5.6
    
---

apiVersion: v1
kind: PersistentVolume
metadata:
  name:  pv3
spec:
  capacity: 
    storage: 3Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /root/data/pv3
    server: 192.168.5.6
</code></pre>
<pre><code class="language-shell"># 创建 pv
[root@k8s-master01 ~]# kubectl create -f pv.yaml
persistentvolume/pv1 created
persistentvolume/pv2 created
persistentvolume/pv3 created

# 查看pv
[root@k8s-master01 ~]# kubectl get pv -o wide
NAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE
pv1    1Gi        RWX            Retain        Available    10s   Filesystem
pv2    2Gi        RWX            Retain        Available    10s   Filesystem
pv3    3Gi        RWX            Retain        Available    9s    Filesystem
</code></pre>
<h3 id="822-pvc">8.2.2 PVC</h3>
<p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc
  namespace: dev
spec:
  accessModes: # 访问模式
  selector: # 采用标签对PV选择
  storageClassName: # 存储类别
  resources: # 请求空间
    requests:
      storage: 5Gi
</code></pre>
<p>PVC 的关键配置参数说明：</p>
<ul>
<li><strong>访问模式（accessModes）</strong></li>
</ul>
<p>用于描述用户应用对存储资源的访问权限</p>
<ul>
<li>
<p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li>
<p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li>
<p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<p><strong>实验</strong></p>
<ol>
<li>创建pvc.yaml，申请pv</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc1
  namespace: dev
spec:
  accessModes: 
  - ReadWriteMany
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc2
  namespace: dev
spec:
  accessModes: 
  - ReadWriteMany
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc3
  namespace: dev
spec:
  accessModes: 
  - ReadWriteMany
  resources:
    requests:
      storage: 1Gi
</code></pre>
<pre><code class="language-shell"># 创建pvc
[root@k8s-master01 ~]# kubectl create -f pvc.yaml
persistentvolumeclaim/pvc1 created
persistentvolumeclaim/pvc2 created
persistentvolumeclaim/pvc3 created

# 查看pvc
[root@k8s-master01 ~]# kubectl get pvc  -n dev -o wide
NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE
pvc1   Bound    pv1      1Gi        RWX                           15s   Filesystem
pvc2   Bound    pv2      2Gi        RWX                           15s   Filesystem
pvc3   Bound    pv3      3Gi        RWX                           15s   Filesystem

# 查看pv
[root@k8s-master01 ~]# kubectl get pv -o wide
NAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE
pv1    1Gi        RWx        Retain          Bound    dev/pvc1    3h37m    Filesystem
pv2    2Gi        RWX        Retain          Bound    dev/pvc2    3h37m    Filesystem
pv3    3Gi        RWX        Retain          Bound    dev/pvc3    3h37m    Filesystem   
</code></pre>
<ol start="2">
<li>创建pods.yaml, 使用pv</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod1
  namespace: dev
spec:
  containers:
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;]
    volumeMounts:
    - name: volume
      mountPath: /root/
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: pvc1
        readOnly: false
---
apiVersion: v1
kind: Pod
metadata:
  name: pod2
  namespace: dev
spec:
  containers:
  - name: busybox
    image: busybox:1.30
    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;]
    volumeMounts:
    - name: volume
      mountPath: /root/
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: pvc2
        readOnly: false
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pods.yaml
pod/pod1 created
pod/pod2 created

# 查看pod
[root@k8s-master01 ~]# kubectl get pods -n dev -o wide
NAME   READY   STATUS    RESTARTS   AGE   IP            NODE   
pod1   1/1     Running   0          14s   10.244.1.69   node1   
pod2   1/1     Running   0          14s   10.244.1.70   node1  

# 查看pvc
[root@k8s-master01 ~]# kubectl get pvc -n dev -o wide
NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE
pvc1   Bound    pv1      1Gi        RWX               94m   Filesystem
pvc2   Bound    pv2      2Gi        RWX               94m   Filesystem
pvc3   Bound    pv3      3Gi        RWX               94m   Filesystem

# 查看pv
[root@k8s-master01 ~]# kubectl get pv -n dev -o wide
NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE
pv1    1Gi        RWX            Retain           Bound    dev/pvc1    5h11m   Filesystem
pv2    2Gi        RWX            Retain           Bound    dev/pvc2    5h11m   Filesystem
pv3    3Gi        RWX            Retain           Bound    dev/pvc3    5h11m   Filesystem

# 查看nfs中的文件存储
[root@nfs ~]# more /root/data/pv1/out.txt
node1
node1
[root@nfs ~]# more /root/data/pv2/out.txt
node2
node2
</code></pre>
<h3 id="823-生命周期">8.2.3 生命周期</h3>
<p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li>
<p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li>
<p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li>
<li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li>
<p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li>
<p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
</li>
<li>
<p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<figure data-type="image" tabindex="45"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h31cz9bj30xv0f20vb.jpg" alt="img" loading="lazy"></figure>
<h2 id="83-配置存储">8.3 配置存储</h2>
<h3 id="831-configmap">8.3.1 ConfigMap</h3>
<p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p>
<p>创建configmap.yaml，内容如下：</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: configmap
  namespace: dev
data:
  info: |
    username:admin
    password:123456
</code></pre>
<p>接下来，使用此配置文件创建configmap</p>
<pre><code class="language-shell"># 创建configmap
[root@k8s-master01 ~]# kubectl create -f configmap.yaml
configmap/configmap created

# 查看configmap详情
[root@k8s-master01 ~]# kubectl describe cm configmap -n dev
Name:         configmap
Namespace:    dev
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
info:
----
username:admin
password:123456

Events:  &lt;none&gt;
</code></pre>
<p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-configmap
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    volumeMounts: # 将configmap挂载到目录
    - name: config
      mountPath: /configmap/config
  volumes: # 引用configmap
  - name: config
    configMap:
      name: configmap
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-configmap.yaml
pod/pod-configmap created

# 查看pod
[root@k8s-master01 ~]# kubectl get pod pod-configmap -n dev
NAME            READY   STATUS    RESTARTS   AGE
pod-configmap   1/1     Running   0          6s

#进入容器
[root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev /bin/sh
# cd /configmap/config/
# ls
info
# more info
username:admin
password:123456

# 可以看到映射已经成功，每个configmap都映射成了一个目录
# key---&gt;文件     value----&gt;文件中的内容
# 此时如果更新configmap的内容, 容器中的值也会动态更新
</code></pre>
<h3 id="832-secret">8.3.2 Secret</h3>
<p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<ol>
<li>首先使用base64对数据进行编码</li>
</ol>
<pre><code class="language-shell">[root@k8s-master01 ~]# echo -n 'admin' | base64 #准备username
YWRtaW4=
[root@k8s-master01 ~]# echo -n '123456' | base64 #准备password
MTIzNDU2
</code></pre>
<ol start="2">
<li>接下来编写secret.yaml，并创建Secret</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: secret
  namespace: dev
type: Opaque
data:
  username: YWRtaW4=
  password: MTIzNDU2
</code></pre>
<pre><code class="language-shell"># 创建secret
[root@k8s-master01 ~]# kubectl create -f secret.yaml
secret/secret created

# 查看secret详情
[root@k8s-master01 ~]# kubectl describe secret secret -n dev
Name:         secret
Namespace:    dev
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Type:  Opaque
Data
====
password:  6 bytes
username:  5 bytes
</code></pre>
<ol start="3">
<li>创建pod-secret.yaml，将上面创建的secret挂载进去：</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-secret
  namespace: dev
spec:
  containers:
  - name: nginx
    image: nginx:1.17.1
    volumeMounts: # 将secret挂载到目录
    - name: config
      mountPath: /secret/config
  volumes:
  - name: config
    secret:
      secretName: secret
</code></pre>
<pre><code class="language-shell"># 创建pod
[root@k8s-master01 ~]# kubectl create -f pod-secret.yaml
pod/pod-secret created

# 查看pod
[root@k8s-master01 ~]# kubectl get pod pod-secret -n dev
NAME            READY   STATUS    RESTARTS   AGE
pod-secret      1/1     Running   0          2m28s

# 进入容器，查看secret信息，发现已经自动解码了
[root@k8s-master01 ~]# kubectl exec -it pod-secret /bin/sh -n dev
/ # ls /secret/config/
password  username
/ # more /secret/config/username
admin
/ # more /secret/config/password
123456
</code></pre>
<p>至此，已经实现了利用secret实现了信息的编码。</p>
<h1 id="9-安全认证">9. 安全认证</h1>
<h2 id="91-访问控制概述">9.1 访问控制概述</h2>
<p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p>
<p><strong>客户端</strong></p>
<p>在Kubernetes集群中，客户端通常有两类：</p>
<ul>
<li><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</li>
<li><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li>
</ul>
<figure data-type="image" tabindex="46"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3748alj30nt07z0tg.jpg" alt="img" loading="lazy"></figure>
<p><strong>认证、授权与准入控制</strong></p>
<p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li>
<li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li>
</ul>
<figure data-type="image" tabindex="47"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3bvb48j30s905ygmc.jpg" alt="img" loading="lazy"></figure>
<h2 id="92-认证管理">9.2 认证管理</h2>
<p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p>
<ul>
<li>
<p>HTTP Base认证：通过用户名+密码的方式认证</p>
<pre><code>    这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。
</code></pre>
</li>
<li>
<p>HTTP Token认证：通过一个Token来识别合法用户</p>
<pre><code>    这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。
</code></pre>
</li>
<li>
<p>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</p>
<pre><code>    这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="48"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3fh42nj30r80djdha.jpg" alt="img" loading="lazy"></figure>
<p><strong>HTTPS认证大体分为3个过程：</strong></p>
<ol>
<li>
<p>证书申请和下发</p>
<pre><code>  HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者
</code></pre>
</li>
<li>
<p>客户端和服务端的双向认证</p>
<pre><code>  1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，
     客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，
     客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器
  2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，
     在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法
</code></pre>
</li>
<li>
<p>服务器端和客户端进行通信</p>
<pre><code>  服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。
  服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密
</code></pre>
</li>
</ol>
<blockquote>
<p>注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p>
</blockquote>
<h2 id="93-授权管理">9.3 授权管理</h2>
<p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p>
<p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p>
<p>API Server目前支持以下几种授权策略：</p>
<ul>
<li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li>
<li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li>
<li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部REST服务对用户进行授权</li>
<li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li>
<li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li>
</ul>
<p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p>
<p>其中涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li>
<li>绑定：将定义好的角色跟用户绑定在一起</li>
</ul>
<figure data-type="image" tabindex="49"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3k7lzcj30pb0cwmyj.jpg" alt="img" loading="lazy"></figure>
<p>RBAC引入了4个顶级资源对象：</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li>
</ul>
<p><strong>Role、ClusterRole</strong></p>
<p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p>
<pre><code class="language-yaml"># Role只能对命名空间内的资源进行授权，需要指定nameapce
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: dev
  name: authorization-role
rules:
- apiGroups: [&quot;&quot;]  # 支持的API组列表,&quot;&quot; 空字符串，表示核心API群
  resources: [&quot;pods&quot;] # 支持的资源对象列表
  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] # 允许的对资源对象的操作方法列表
</code></pre>
<pre><code class="language-yaml"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
 name: authorization-clusterrole
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;]
  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]
</code></pre>
<p>需要详细说明的是，rules中的参数：</p>
<ul>
<li>
<p>apiGroups: 支持的API组列表</p>
<pre><code>&quot;&quot;,&quot;apps&quot;, &quot;autoscaling&quot;, &quot;batch&quot;
</code></pre>
</li>
<li>
<p>resources：支持的资源对象列表</p>
<pre><code>&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;,&quot;secrets&quot;,&quot;configmaps&quot;,&quot;crontabs&quot;,&quot;deployments&quot;,&quot;jobs&quot;,
&quot;nodes&quot;,&quot;rolebindings&quot;,&quot;clusterroles&quot;,&quot;daemonsets&quot;,&quot;replicasets&quot;,&quot;statefulsets&quot;,
&quot;horizontalpodautoscalers&quot;,&quot;replicationcontrollers&quot;,&quot;cronjobs&quot;
</code></pre>
</li>
<li>
<p>verbs：对资源对象的操作方法列表</p>
<pre><code>&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;exec&quot;
</code></pre>
</li>
</ul>
<p><strong>RoleBinding、ClusterRoleBinding</strong></p>
<p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p>
<pre><code class="language-yaml"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: authorization-role-binding
  namespace: dev
subjects:
- kind: User
  name: heima
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: authorization-role
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<pre><code class="language-yaml"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
 name: authorization-clusterrole-binding
subjects:
- kind: User
  name: heima
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: authorization-clusterrole
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<p><strong>RoleBinding引用ClusterRole进行授权</strong></p>
<p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p>
<pre><code>    一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。
</code></pre>
<pre><code class="language-yaml"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding
# 所以heima只能读取dev命名空间中的资源
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: authorization-role-binding-ns
  namespace: dev
subjects:
- kind: User
  name: heima
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: authorization-clusterrole
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<p><strong>实战：创建一个只能管理dev空间下Pods资源的账号</strong></p>
<ol>
<li>创建账号</li>
</ol>
<pre><code class="language-shell"># 1) 创建证书
[root@k8s-master01 pki]# cd /etc/kubernetes/pki/
[root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048)

# 2) 用apiserver的证书去签署
# 2-1) 签名申请，申请的用户是devman,组是devgroup
[root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;     
# 2-2) 签署证书
[root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650

# 3) 设置集群、用户、上下文信息
[root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.109.100:6443

[root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key

[root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman

# 切换账户到devman
[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes
Switched to context &quot;devman@kubernetes&quot;.

# 查看dev下pod，发现没有权限
[root@k8s-master01 pki]# kubectl get pods -n dev
Error from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;

# 切换到admin账户
[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes
Switched to context &quot;kubernetes-admin@kubernetes&quot;.
</code></pre>
<p>2） 创建Role和RoleBinding，为devman用户授权</p>
<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: dev
  name: dev-role
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;]
  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]
  
---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: authorization-role-binding
  namespace: dev
subjects:
- kind: User
  name: devman
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev-role
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<pre><code class="language-shell">[root@k8s-master01 pki]# kubectl create -f dev-role.yaml
role.rbac.authorization.k8s.io/dev-role created
rolebinding.rbac.authorization.k8s.io/authorization-role-binding created
</code></pre>
<ol start="3">
<li>切换账户，再次验证</li>
</ol>
<pre><code class="language-shell"># 切换账户到devman
[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes
Switched to context &quot;devman@kubernetes&quot;.

# 再次查看
[root@k8s-master01 pki]# kubectl get pods -n dev
NAME                                 READY   STATUS             RESTARTS   AGE
nginx-deployment-66cb59b984-8wp2k    1/1     Running            0          4d1h
nginx-deployment-66cb59b984-dc46j    1/1     Running            0          4d1h
nginx-deployment-66cb59b984-thfck    1/1     Running            0          4d1h

# 为了不影响后面的学习,切回admin账户
[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes
Switched to context &quot;kubernetes-admin@kubernetes&quot;.
</code></pre>
<h2 id="94-准入控制">9.4 准入控制</h2>
<p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p>
<p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p>
<pre><code>--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,
                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds
</code></pre>
<p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p>
<p>当前可配置的Admission Control准入控制如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
<h1 id="10-dashboard">10. DashBoard</h1>
<p>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。</p>
<h2 id="101-部署dashboard">10.1 部署Dashboard</h2>
<ol>
<li>下载yaml，并运行Dashboard</li>
</ol>
<pre><code class="language-shell"># 下载yaml
[root@k8s-master01 ~]# wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml

# 修改kubernetes-dashboard的Service类型
kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  type: NodePort  # 新增
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 30009  # 新增
  selector:
    k8s-app: kubernetes-dashboard

# 部署
[root@k8s-master01 ~]# kubectl create -f recommended.yaml

# 查看namespace下的kubernetes-dashboard下的资源
[root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboard
NAME                                            READY   STATUS    RESTARTS   AGE
pod/dashboard-metrics-scraper-c79c65bb7-zwfvw   1/1     Running   0          111s
pod/kubernetes-dashboard-56484d4c5-z95z5        1/1     Running   0          111s

NAME                               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)         AGE
service/dashboard-metrics-scraper  ClusterIP  10.96.89.218    &lt;none&gt;       8000/TCP        111s
service/kubernetes-dashboard       NodePort   10.104.178.171  &lt;none&gt;       443:30009/TCP   111s
</code></pre>
<p>2）创建访问账户，获取token</p>
<pre><code class="language-shell"># 创建账号
[root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard

# 授权
[root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin

# 获取账号token
[root@k8s-master01 ~]#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin
dashboard-admin-token-xbqhh        kubernetes.io/service-account-token   3      2m35s

[root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard
Name:         dashboard-admin-token-xbqhh
Namespace:    kubernetes-dashboard
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: dashboard-admin
              kubernetes.io/service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039

Type:  kubernetes.io/service-account-token

Data
====
namespace:  20 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw
ca.crt:     1025 bytes
</code></pre>
<p>3）通过浏览器访问Dashboard的UI</p>
<p>在登录页面上输入上面的token</p>
<figure data-type="image" tabindex="50"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3snlagj30sm0eoju5.jpg" alt="image-20200520144548997" loading="lazy"></figure>
<p>出现下面的页面代表成功</p>
<figure data-type="image" tabindex="51"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h3vv20aj31h30ppn04.jpg" alt="image-20200520144959353" loading="lazy"></figure>
<h2 id="102-使用dashboard">10.2 使用DashBoard</h2>
<p>本章节以Deployment为例演示DashBoard的使用</p>
<p><strong>查看</strong></p>
<p>选择指定的命名空间<code>dev</code>，然后点击<code>Deployments</code>，查看dev空间下的所有deployment</p>
<figure data-type="image" tabindex="52"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h40658oj31gi0atq3z.jpg" alt="img" loading="lazy"></figure>
<p><strong>扩缩容</strong></p>
<p>在<code>Deployment</code>上点击<code>规模</code>，然后指定<code>目标副本数量</code>，点击确定</p>
<figure data-type="image" tabindex="53"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h43wtwqj317z0h4ac3.jpg" alt="img" loading="lazy"></figure>
<p><strong>编辑</strong></p>
<p>在<code>Deployment</code>上点击<code>编辑</code>，然后修改<code>yaml文件</code>，点击确定</p>
<figure data-type="image" tabindex="54"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h47hae7j31790amabo.jpg" alt="image-20200520163253644" loading="lazy"></figure>
<p><strong>查看Pod</strong></p>
<p>点击<code>Pods</code>, 查看pods列表</p>
<figure data-type="image" tabindex="55"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h4bx3qfj31g70ev415.jpg" alt="img" loading="lazy"></figure>
<p><strong>操作Pod</strong></p>
<p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p>
<figure data-type="image" tabindex="56"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0h4g1x03j316i08pq47.jpg" alt="img" loading="lazy"></figure>
<blockquote>
<p>Dashboard提供了kubectl的绝大部分功能，这里不再一一演示</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高效代码]]></title>
        <id>https://WheatJack.github.io/post/aLiCode/</id>
        <link href="https://WheatJack.github.io/post/aLiCode/">
        </link>
        <updated>2020-10-28T13:45:42.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1常量变量"><strong>1.常量&amp;变量</strong></h2>
<h3 id="11直接赋值常量值禁止声明新对象"><strong>1.1.直接赋值常量值，禁止声明新对象</strong></h3>
<p>直接赋值常量值，只是创建了一个对象引用，而这个对象引用指向常量值。</p>
<p><strong>反例：</strong></p>
<pre><code>Long i = new Long(1L);String s = new String(&quot;abc&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>Long i = 1L;String s = &quot;abc&quot;;
</code></pre>
<h3 id="12当成员变量值无需改变时尽量定义为静态常量"><strong>1.2.当成员变量值无需改变时，尽量定义为静态常量</strong></h3>
<p>在类的每个对象实例中，每个成员变量都有一份副本，而成员静态常量只有一份实例。</p>
<p><strong>反例：</strong></p>
<pre><code>public class HttpConnection {    private final long timeout = 5L;    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public class HttpConnection {    private static final long TIMEOUT = 5L;    ...}
</code></pre>
<h3 id="13尽量使用基本数据类型避免自动装箱和拆箱"><strong>1.3.尽量使用基本数据类型，避免自动装箱和拆箱</strong></h3>
<p>Java 中的基本数据类型double、float、long、int、short、char、boolean，分别对应包装类Double、Float、Long、Integer、Short、Character、Boolean。JVM支持基本类型与对应包装类的自动转换，被称为自动装箱和拆箱。装箱和拆箱都是需要CPU和内存资源的，所以应尽量避免使用自动装箱和拆箱。</p>
<p><strong>反例：</strong></p>
<pre><code>Integer sum = 0;int[] values = ...;for (int value : values) {    sum += value; // 相当于result = Integer.valueOf(result.intValue() + value);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int sum = 0;int[] values = ...;for (int value : values) {    sum += value;}
</code></pre>
<h3 id="14如果变量的初值会被覆盖就没有必要给变量赋初值"><strong>1.4.如果变量的初值会被覆盖，就没有必要给变量赋初值</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;();if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList;if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<h3 id="15尽量使用函数内的基本类型临时变量"><strong>1.5.尽量使用函数内的基本类型临时变量</strong></h3>
<p>在函数内，基本类型的参数和临时变量都保存在栈（Stack）中，访问速度较快；对象类型的参数和临时变量的引用都保存在栈（Stack）中，内容都保存在堆（Heap）中，访问速度较慢。在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">public final class Accumulator {    private double result = 0.0D;    public void addAll(@NonNull double[] values) {        for(double value : values) {            result += value;        }    }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public final class Accumulator {    private double result = 0.0D;    public void addAll(@NonNull double[] values) {        double sum = 0.0D;        for(double value : values) {            sum += value;        }        result += sum;    }    ...}
</code></pre>
<h3 id="16尽量不要在循环体外定义变量"><strong>1.6.尽量不要在循环体外定义变量</strong></h3>
<p>在老版JDK中，建议“尽量不要在循环体内定义变量”，但是在新版的JDK中已经做了优化。通过对编译后的字节码分析，变量定义在循环体外和循环体内没有本质的区别，运行效率基本上是一样的。</p>
<p>反而，根据“ 局部变量作用域最小化 ”原则，变量定义在循环体内更科学更便于维护，避免了延长大对象生命周期导致延缓回收问题 。</p>
<p><strong>反例：</strong></p>
<pre><code>UserVO userVO;List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="17不可变的静态常量尽量使用非线程安全类"><strong>1.7.不可变的静态常量，尽量使用非线程安全类</strong></h3>
<p>不可变的静态常量，虽然需要支持多线程访问，也可以使用非线程安全类。</p>
<p><strong>反例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new ConcurrentHashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new HashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<h3 id="18不可变的成员变量尽量使用非线程安全类">1.8.不可变的成员变量，尽量使用非线程安全类**</h3>
<p>不可变的成员变量，虽然需要支持多线程访问，也可以使用非线程安全类。</p>
<p><strong>反例：</strong></p>
<pre><code>@Servicepublic class StrategyFactory implements InitializingBean {    @Autowired    private List&lt;Strategy&gt; strategyList;    private Map&lt;String, Strategy&gt; strategyMap;    @Override    public void afterPropertiesSet() {        if (CollectionUtils.isNotEmpty(strategyList)) {            int size = (int) Math.ceil(strategyList.size() * 4.0 / 3);            Map&lt;String, Strategy&gt; map = new ConcurrentHashMap&lt;&gt;(size);            for (Strategy strategy : strategyList) {                map.put(strategy.getType(), strategy);            }            strategyMap = Collections.unmodifiableMap(map);        }    }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>@Servicepublic class StrategyFactory implements InitializingBean {    @Autowired    private List&lt;Strategy&gt; strategyList;    private Map&lt;String, Strategy&gt; strategyMap;    @Override    public void afterPropertiesSet() {        if (CollectionUtils.isNotEmpty(strategyList)) {            int size = (int) Math.ceil(strategyList.size() * 4.0 / 3);            Map&lt;String, Strategy&gt; map = new HashMap&lt;&gt;(size);            for (Strategy strategy : strategyList) {                map.put(strategy.getType(), strategy);            }            strategyMap = Collections.unmodifiableMap(map);        }    }    ...
</code></pre>
<h2 id=""></h2>
<h2 id="2对象类"><strong>2</strong>.对象&amp;类</h2>
<h3 id="21禁止使用json转化对象"><strong>2.1.禁止使用JSON转化对象</strong></h3>
<p>JSON提供把对象转化为JSON字符串、把JSON字符串转为对象的功能，于是被某些人用来转化对象。这种对象转化方式，虽然在功能上没有问题，但是在性能上却存在问题。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="22尽量不使用反射赋值对象"><strong>2.2.尽量不使用反射赋值对象</strong></h3>
<p>用反射赋值对象，主要优点是节省了代码量，主要缺点却是性能有所下降。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    BeanUtils.copyProperties(userDO, userVO);    userVOList.add(userVO);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="-2"></h3>
<h3 id="23采用lambda表达式替换内部匿名类"><strong>2.3.采用Lambda表达式替换内部匿名类</strong></h3>
<p>对于大多数刚接触JDK8的同学来说，都会认为Lambda表达式就是匿名内部类的语法糖。实际上， Lambda表达式在大多数虚拟机中采用invokeDynamic指令实现，相对于匿名内部类在效率上会更高一些。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;User&gt; userList = ...;Collections.sort(userList, new Comparator&lt;User&gt;() {    @Override    public int compare(User user1, User user2) {        Long userId1 = user1.getId();        Long userId2 = user2.getId();        ...        return userId1.compareTo(userId2);    }});
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;User&gt; userList = ...;Collections.sort(userList, (user1, user2) -&gt; {    Long userId1 = user1.getId();    Long userId2 = user2.getId();    ...    return userId1.compareTo(userId2);});
</code></pre>
<h3 id="-3"></h3>
<h3 id="24尽量避免定义不必要的子类"><strong>2.4.尽量避免定义不必要的子类</strong></h3>
<p>多一个类就需要多一份类加载，所以尽量避免定义不必要的子类。</p>
<p><strong>反例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP =    Collections.unmodifiableMap(new HashMap&lt;String, Class&gt;(16) {    private static final long serialVersionUID = 1L;    {        put(&quot;VARCHAR&quot;, java.lang.String.class);    }});
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new HashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<h3 id="-4"></h3>
<h3 id="25尽量指定类的final修饰符"><strong>2.5.尽量指定类的final修饰符</strong></h3>
<p>为类指定final修饰符，可以让该类不可以被继承。如果指定了一个类为final，则该类所有的方法都是final的，Java编译器会寻找机会内联所有的final方法。内联对于提升Java运行效率作用重大，具体可参见Java运行期优化，能够使性能平均提高50%。</p>
<p><strong>反例：</strong></p>
<pre><code>public class DateHelper {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public final class DateHelper {    ...}
</code></pre>
<p>注意：使用Spring的AOP特性时，需要对Bean进行动态代理，如果Bean类添加了final修饰，会导致异常。</p>
<h2 id="3方法"><strong>3.方法</strong></h2>
<h3 id="31把跟类成员变量无关的方法声明成静态方法"><strong>3.1.把跟类成员变量无关的方法声明成静态方法</strong></h3>
<p>静态方法的好处就是不用生成类的实例就可以直接调用。静态方法不再属于某个对象，而是属于它所在的类。只需要通过其类名就可以访问，不需要再消耗资源去反复创建对象。即便在类内部的私有方法，如果没有使用到类成员变量，也应该声明为静态方法。</p>
<p><strong>反例：</strong></p>
<pre><code>public int getMonth(Date date) {  Calendar calendar = Calendar.getInstance();  calendar.setTime(date);  return calendar.get(Calendar.MONTH) + 1;}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static int getMonth(Date date) {  Calendar calendar = Calendar.getInstance();  calendar.setTime(date);  return calendar.get(Calendar.MONTH) + 1;}
</code></pre>
<h3 id="32尽量使用基本数据类型作为方法参数类型避免不必要的装箱-拆箱和空指针判断"><strong>3.2.尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>public static double sum(Double value1, Double value2) {    double double1 = Objects.isNull(value1) ? 0.0D : value1;    double double2 = Objects.isNull(value2) ? 0.0D : value2;    return double1 + double2;}double result = sum(1.0D, 2.0D);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static double sum(double value1, double value2) {    return value1 + value2;}double result = sum(1.0D, 2.0D);
</code></pre>
<h3 id="33尽量使用基本数据类型作为方法返回值类型避免不必要的装箱-拆箱和空指针判断">3.3.尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断</h3>
<p>在JDK类库的方法中，很多方法返回值都采用了基本数据类型，首先是为了避免不必要的装箱和拆箱，其次是为了避免返回值的空指针判断。比如：Collection.isEmpty()和Map.size()。</p>
<p><strong>反例：</strong></p>
<pre><code>public static Boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
// 调用代码UserDO user = ...;Boolean isValid = isValid(user);if (Objects.nonNull(isValid) &amp;&amp; isValid.booleanValue()) {     ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
// 调用代码UserDO user = ...;if (isValid(user)) {    ...}
</code></pre>
<h3 id="-5"></h3>
<h3 id="34协议方法参数值非空避免不必要的空指针判断"><strong>3.4.协议方法参数值非空，避免不必要的空指针判断</strong></h3>
<p>协议编程，可以@NonNull和@Nullable标注参数，是否遵循全凭调用者自觉。</p>
<p><strong>反例：</strong></p>
<pre><code>public static boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static boolean isValid(@NonNull UserDO user) {  return Boolean.TRUE.equals(user.getIsValid());}
</code></pre>
<h3 id="-6"></h3>
<h3 id="35协议方法返回值非空避免不必要的空指针判断"><strong>3.5.协议方法返回值非空，避免不必要的空指针判断</strong></h3>
<p>协议编程，可以@NonNull和@Nullable标注参数，是否遵循全凭实现者自觉。</p>
<p><strong>反例：</strong></p>
<pre><code>// 定义接口public interface OrderService {    public List&lt;OrderVO&gt; queryUserOrder(Long userId);}
// 调用代码List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);if (CollectionUtils.isNotEmpty(orderList)) {    for (OrderVO order : orderList) {        ...    }}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>// 定义接口public interface OrderService {    @NonNull    public List&lt;OrderVO&gt; queryUserOrder(Long userId);}
// 调用代码List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);for (OrderVO order : orderList) {    ...}
</code></pre>
<h3 id="-7"></h3>
<h3 id="36被调用方法已支持判空处理调用方法无需再进行判空处理"><strong>3.6.被调用方法已支持判空处理，调用方法无需再进行判空处理</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>UserDO user = null;if (StringUtils.isNotBlank(value)) {    user = JSON.parseObject(value, UserDO.class);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>UserDO user = JSON.parseObject(value, UserDO.class);
</code></pre>
<h3 id="37尽量避免不必要的函数封装"><strong>3.7.尽量避免不必要的函数封装</strong></h3>
<p>方法调用会引起入栈和出栈，导致消耗更多的CPU和内存，应当尽量避免不必要的函数封装。当然，为了使代码更简洁、更清晰、更易维护，增加一定的方法调用所带来的性能损耗是值得的。</p>
<p><strong>反例：</strong></p>
<pre><code>// 函数封装public static boolean isVip(Boolean isVip) {    return Boolean.TRUE.equals(isVip);}
// 使用代码boolean isVip = isVip(user.getVip());
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>boolean isVip = Boolean.TRUE.equals(user.getVip());
</code></pre>
<h3 id="38尽量指定方法的final修饰符"><strong>3.8.尽量指定方法的final修饰符</strong></h3>
<p>方法指定final修饰符，可以让方法不可以被重写，Java编译器会寻找机会内联所有的final方法。内联对于提升Java运行效率作用重大，具体可参见Java运行期优化，能够使性能平均提高50%。</p>
<p>注意：所有的private方法会隐式地被指定final修饰符，所以无须再为其指定final修饰符。</p>
<p><strong>反例：</strong></p>
<pre><code>public class Rectangle {    ...    public double area() {        ...    }}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public class Rectangle {    ...    public final double area() {        ...    }}
</code></pre>
<p>注意：使用Spring的AOP特性时，需要对Bean进行动态代理，如果方法添加了final修饰，将不会被代理。</p>
<h2 id="4表达式"><strong>4.表达式</strong></h2>
<h3 id="41尽量减少方法的重复调用"><strong>4.1.尽量减少方法的重复调用</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = ...;for (int i = 0; i &lt; userList.size(); i++) {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = ...;int userLength = userList.size();for (int i = 0; i &lt; userLength; i++) {    ...}
</code></pre>
<h3 id="-8"></h3>
<h3 id="42尽量避免不必要的方法调用"><strong>4.2.尽量避免不必要的方法调用</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = userDAO.queryActive();if (isAll) {    userList = userDAO.queryAll();}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList;if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<h3 id="-9"></h3>
<h3 id="43尽量使用移位来代替正整数乘除"><strong>4.3.尽量使用移位来代替正整数乘除</strong></h3>
<p>用移位操作可以极大地提高性能。对于乘除2^n(n为正整数)的正整数计算，可以用移位操作来代替。</p>
<p><strong>反例：</strong></p>
<pre><code>int num1 = a * 4;int num2 = a / 4;
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int num1 = a &lt;&lt; 2;int num2 = a &gt;&gt; 2;
</code></pre>
<h3 id="-10"></h3>
<h3 id="44提取公共表达式避免重复计算"><strong>4.4.提取公共表达式，避免重复计算</strong></h3>
<p>提取公共表达式，只计算一次值，然后重复利用值。</p>
<p><strong>反例：</strong></p>
<pre><code>double distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>double dx = x2 - x1;double dy = y2 - y1;double distance = Math.sqrt(dx * dx + dy * dy);或double distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
</code></pre>
<h3 id="-11"></h3>
<h3 id="45尽量不在条件表达式中用取反"><strong>4.5.尽量不在条件表达式中用!取反</strong></h3>
<p>使用!取反会多一次计算，如果没有必要则优化掉。</p>
<p><strong>反例：</strong></p>
<pre><code>if (!(a &gt;= 10)) {    ... // 条件处理1} else {    ... // 条件处理2}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>if (a &lt; 10) {    ... // 条件处理1} else {    ... // 条件处理2}
</code></pre>
<h3 id="-12"></h3>
<h3 id="46对于多常量选择分支尽量使用switch语句而不是if-else语句"><strong>4.6.对于多常量选择分支，尽量使用switch语句而不是if-else语句</strong></h3>
<p>if-else语句，每个if条件语句都要加装计算，直到if条件语句为true为止。switch语句进行了跳转优化，Java中采用tableswitch或lookupswitch指令实现，对于多常量选择分支处理效率更高。经过试验证明：在每个分支出现概率相同的情况下，低于5个分支时if-else语句效率更高，高于5个分支时switch语句效率更高。</p>
<p><strong>反例：</strong></p>
<pre><code>if (i == 1) {    ...; // 分支1} else if (i == 2) {    ...; // 分支2} else if (i == ...) {    ...; // 分支n} else {    ...; // 分支n+1}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>switch (i) {    case 1 :        ... // 分支1        break;    case 2 :        ... // 分支2        break;    case ... :        ... // 分支n        break;    default :        ... // 分支n+1        break;}
</code></pre>
<p>备注：如果业务复杂，可以采用Map实现策略模式。</p>
<h2 id="5字符串"><strong>5.字符串</strong></h2>
<h3 id="51尽量不要使用正则表达式匹配"><strong>5.1.尽量不要使用正则表达式匹配</strong></h3>
<p>正则表达式匹配效率较低，尽量使用字符串匹配操作。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">String source = &quot;a::1,b::2,c::3,d::4&quot;;
String target = source.replaceAll(&quot;::&quot;, &quot;=&quot;);
Stringp[] targets = source.spit(&quot;::&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">String source = &quot;a::1,b::2,c::3,d::4&quot;;
String target = source.replace(&quot;::&quot;, &quot;=&quot;);
Stringp[] targets = StringUtils.split(source, &quot;::&quot;);
</code></pre>
<h3 id="-13"></h3>
<h3 id="52尽量使用字符替换字符串"><strong>5.2.尽量使用字符替换字符串</strong></h3>
<p>字符串的长度不确定，而字符的长度固定为1，查找和匹配的效率自然提高了</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">String source = &quot;a:1,b:2,c:3,d:4&quot;;
int index = source.indexOf(&quot;:&quot;);
String target = source.replace(&quot;:&quot;, &quot;=&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">String source = &quot;a:1,b:2,c:3,d:4&quot;;
int index = source.indexOf(':');
String target = source.replace(':', '=');
</code></pre>
<h3 id="-14"></h3>
<h3 id="53尽量使用stringbuilder进行字符串拼接"><strong>5.3.尽量使用StringBuilder进行字符串拼接</strong></h3>
<p>String是final类，内容不可修改，所以每次字符串拼接都会生成一个新对象。StringBuilder在初始化时申请了一块内存，以后的字符串拼接都在这块内存中执行，不会申请新内存和生成新对象。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        String s = &quot;&quot;;
        for (int i = 0; i &lt; 10; i++) {
            if (i != 0) {
                s += ',';
            }
            s += i;
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        StringBuilder sb = new StringBuilder(128);
        for (int i = 0; i &lt; 10; i++) {
            if (i != 0) {
                sb.append(',');
            }
            sb.append(i);
        }
</code></pre>
<h3 id="-15"></h3>
<h3 id="54不要使用转化字符串"><strong>5.4.不要使用&quot;&quot;+转化字符串</strong></h3>
<p>使用&quot;&quot;+进行字符串转化，使用方便但是效率低，建议使用String.valueOf.</p>
<p><strong>反例：</strong></p>
<pre><code>int i = 12345;String s = &quot;&quot; + i;
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int i = 12345;String s = String.valueOf(i);
</code></pre>
<h2 id="-16"></h2>
<h2 id="6数组"><strong>6.数组</strong></h2>
<h3 id="61不要使用循环拷贝数组尽量使用systemarraycopy拷贝数组"><strong>6.1.不要使用循环拷贝数组，尽量使用System.arraycopy拷贝数组</strong></h3>
<p>推荐使用System.arraycopy拷贝数组，也可以使用Arrays.copyOf拷贝数组。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">int[] sources = new int[] {1, 2, 3, 4, 5};
int[] targets = new int[sources.length];
for (int i = 0; i &lt; targets.length; i++) {    targets[i] = sources[i];}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">int[] sources = new int[] {1, 2, 3, 4, 5};
int[] targets = new int[sources.length];
System.arraycopy(sources, 0, targets, 0, targets.length);
</code></pre>
<h3 id="-17"></h3>
<h3 id="62集合转化为类型t数组时尽量传入空数组t0"><strong>6.2.集合转化为类型T数组时，尽量传入空数组T[0]</strong></h3>
<p>将集合转换为数组有2种形式：toArray(new T[n])和toArray(new T[0])。在旧的Java版本中，建议使用toArray(new T[n])，因为创建数组时所需的反射调用非常慢。在OpenJDK6后，反射调用是内在的，使得性能得以提高，toArray(new T[0])比toArray(new T[n])效率更高。此外，toArray(new T[n])比toArray(new T[0])多获取一次列表大小，如果计算列表大小耗时过长，也会导致toArray(new T[n])效率降低</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, ...);
Integer[] integers = integerList.toArray(new Integer[integerList.size()]);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, ...);
Integer[] integers = integerList.toArray(new Integer[0]); // 勿用new Integer[]{}
</code></pre>
<p>建议：集合应该提供一个toArray(Class<T> clazz)方法，避免无用的空数组初始化（new T[0]）。</p>
<h3 id="63集合转化为object数组时尽量使用toarray方法"><strong>6.3.集合转化为Object数组时，尽量使用toArray()方法</strong></h3>
<p>转化Object数组时，没有必要使用toArray[new Object[0]]，可以直接使用toArray()。避免了类型的判断，也避免了空数组的申请，所以效率会更高。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">List&lt;Object&gt; objectList = Arrays.asList(1, &quot;2&quot;, 3, &quot;4&quot;, 5, ...);
Object[] objects = objectList.toArray(new Object[0]);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">List&lt;Object&gt; objectList = Arrays.asList(1, &quot;2&quot;, 3, &quot;4&quot;, 5, ...);
Object[] objects = objectList.toArray();
</code></pre>
<h2 id="-18"></h2>
<h2 id="7集合"><strong>7.集合</strong></h2>
<h3 id="71初始化集合时尽量指定集合大小"><strong>7.1.初始化集合时，尽量指定集合大小</strong></h3>
<p>Java集合初始化时都会指定一个默认大小，当默认大小不再满足数据需求时就会扩容，每次扩容的时间复杂度有可能是O(n)。所以，尽量指定预知的集合大小，就能避免或减少集合的扩容次数。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userDOList = ...;
        Set&lt;Long&gt; userSet = new HashSet&lt;&gt;();
        Map&lt;Long, UserDO&gt; userMap = new HashMap&lt;&gt;();
        List&lt;UserVO&gt; userList = new ArrayList&lt;&gt;();
        for (UserDO userDO : userDOList) {
            userSet.add(userDO.getId());
            userMap.put(userDO.getId(), userDO);
            userList.add(transUser(userDO));
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userDOList = ...;
        int userSize = userDOList.size();
        Set&lt;Long&gt; userSet = new HashSet&lt;&gt;(userSize);
        Map&lt;Long, UserDO&gt; userMap = new HashMap&lt;&gt;((int) Math.ceil(userSize * 4.0 / 3));
        List&lt;UserVO&gt; userList = new ArrayList&lt;&gt;(userSize);
        for (UserDO userDO : userDOList) {
            userSet.add(userDO.getId());
            userMap.put(userDO.getId(), userDO);
            userList.add(transUser(userDO));
        }
</code></pre>
<h3 id="-19"></h3>
<h3 id="72不要使用循环拷贝集合尽量使用jdk提供的方法拷贝集合"><strong>7.2.不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合</strong></h3>
<p>JDK提供的方法可以一步指定集合的容量，避免多次扩容浪费时间和空间。同时，这些方法的底层也是调用System.arraycopy方法实现，进行数据的批量拷贝效率更高。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; user1List = ...;
        List&lt;UserDO&gt; user2List = ...;
        List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;(user1List.size() + user2List.size());
        for (UserDO user1 : user1List) {
            userList.add(user1);
        }
        for (UserDO user2 : user2List) {
            userList.add(user2);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; user1List = ...;
        List&lt;UserDO&gt; user2List = ...;
        List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;(user1List.size() + user2List.size());
        userList.addAll(user1List);
        userList.addAll(user2List);
</code></pre>
<h3 id="-20"></h3>
<h3 id="73尽量使用arraysaslist转化数组为列表"><strong>7.3.尽量使用Arrays.asList转化数组为列表</strong></h3>
<p>原理与&quot;不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合&quot;类似。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;String&gt; typeList = new ArrayList&lt;&gt;(8);
        typeList.add(&quot;Short&quot;);
        typeList.add(&quot;Integer&quot;);
        typeList.add(&quot;Long&quot;);
        String[] names = ...;
        List&lt;String&gt; nameList = ...;
        for (String name : names) {
            nameList.add(name);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;String&gt; typeList = Arrays.asList(&quot;Short&quot;, &quot;Integer&quot;, &quot;Long&quot;);
        String[] names = ...;
        List&lt;String&gt; nameList = ...;
        nameList.addAll(Arrays.asList(names));
</code></pre>
<h3 id="-21"></h3>
<h3 id="74直接迭代需要使用的集合"><strong>7.4.直接迭代需要使用的集合</strong></h3>
<p>直接迭代需要使用的集合，无需通过其它操作获取数据。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        Map&lt;Long, UserDO&gt; userMap = ...;
        for (Long userId : userMap.keySet()) {
            UserDO user = userMap.get(userId);    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        Map&lt;Long, UserDO&gt; userMap = ...;
        for (Map.Entry&lt;Long, UserDO&gt; userEntry : userMap.entrySet()) {
            Long userId = userEntry.getKey();
            UserDO user = userEntry.getValue();    ...}
</code></pre>
<h3 id="-22"></h3>
<h3 id="75不要使用size方法检测空必须使用isempty方法检测空"><strong>7.5.不要使用size方法检测空，必须使用isEmpty方法检测空</strong></h3>
<p>使用size方法来检测空逻辑上没有问题，但使用isEmpty方法使得代码更易读，并且可以获得更好的性能。任何isEmpty方法实现的时间复杂度都是O(1)，但是某些size方法实现的时间复杂度有可能是O(n)。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userList = ...;
        if (userList.size() == 0) {    ...}
        Map&lt;Long, UserDO&gt; userMap = ...;
        if (userMap.size() == 0) {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userList = ...;
        if (userList.isEmpty()) {    ...} 
        Map&lt;Long, UserDO&gt; userMap = ...;
        if (userMap.isEmpty()) {    ...}
</code></pre>
<h3 id="-23"></h3>
<h3 id="76非随机访问的list尽量使用迭代代替随机访问"><strong>7.6.非随机访问的List，尽量使用迭代代替随机访问</strong></h3>
<p>对于列表，可分为随机访问和非随机访问两类，可以用是否实现RandomAccess接口判断。随机访问列表，直接通过get获取数据不影响效率。而非随机访问列表，通过get获取数据效率极低。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        LinkedList&lt;UserDO&gt; userDOList = ...;
        int size = userDOList.size();
        for (int i = 0; i &lt; size; i++) {
            UserDO userDO = userDOList.get(i);    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        LinkedList&lt;UserDO&gt; userDOList = ...;
        for (UserDO userDO : userDOList) {    ...}
</code></pre>
<p>其实，不管列表支不支持随机访问，都应该使用迭代进行遍历。</p>
<h3 id="77尽量使用hashset判断值存在"><strong>7.7.尽量使用HashSet判断值存在</strong></h3>
<p>在Java集合类库中，List的contains方法普遍时间复杂度是O(n)，而HashSet的时间复杂度为O(1)。如果需要频繁调用contains方法查找数据，可以先将List转换成HashSet。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;Long&gt; adminIdList = ...;
        List&lt;UserDO&gt; userDOList = ...;
        List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());
        for (UserDO userDO : userDOList) {
            if (adminIdList.contains(userDO.getId())) {
                userVOList.add(transUser(userDO));
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        Set&lt;Long&gt; adminIdSet = ...;
        List&lt;UserDO&gt; userDOList = ...;
        List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());
        for (UserDO userDO : userDOList) {
            if (adminIdSet.contains(userDO.getId())) {
                userVOList.add(transUser(userDO));
            }
        }
</code></pre>
<h3 id="-24"></h3>
<h3 id="78避免先判断存在再进行获取"><strong>7.8.避免先判断存在再进行获取</strong></h3>
<p>如果需要先判断存在再进行获取，可以直接获取并判断空，从而避免了二次查找操作。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">    public static UserVO transUser(UserDO user, Map&lt;Long, RoleDO&gt; roleMap) {
        UserVO userVO = new UserVO();
        userVO.setId(user.getId());    ...if (roleMap.contains(user.getRoleId())) {
            RoleDO role = roleMap.get(user.getRoleId());
            userVO.setRole(transRole(role));
        }
    }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">    public static UserVO transUser(UserDO user, Map&lt;Long, RoleDO&gt; roleMap) {
        UserVO userVO = new UserVO();
        userVO.setId(user.getId());    ...RoleDO role = roleMap.get(user.getRoleId());
        if (Objects.nonNull(role)) {
            userVO.setRole(transRole(role));
        }
    }
</code></pre>
<h2 id="-25"></h2>
<h2 id="8异常"><strong>8.异常</strong></h2>
<h3 id="81直接捕获对应的异常"><strong>8.1.直接捕获对应的异常</strong></h3>
<p>直接捕获对应的异常，避免用instanceof判断，效率更高代码更简洁。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        try {
            saveData();
        } catch (Exception e) {
            if (e instanceof IOException) {
                log.error(&quot;保存数据IO异常&quot;, e);
            } else {
                log.error(&quot;保存数据其它异常&quot;, e);
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        try {
            saveData();
        } catch (IOException e) {
            log.error(&quot;保存数据IO异常&quot;, e);
        } catch (Exception e) {
            log.error(&quot;保存数据其它异常&quot;, e);
        }
</code></pre>
<h3 id="-26"></h3>
<h3 id="82尽量避免在循环中捕获异常"><strong>8.2.尽量避免在循环中捕获异常</strong></h3>
<p>当循环体抛出异常后，无需循环继续执行时，没有必要在循环体中捕获异常。因为，过多的捕获异常会降低程序执行效率。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public Double sum (List &lt; String &gt; valueList) {
            double sum = 0.0D;
            for (String value : valueList) {
                try {
                    sum += Double.parseDouble(value);
                } catch (NumberFormatException e) {
                    return null;
                }
            }
            return sum;
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        public Double sum (List &lt; String &gt; valueList) {
            double sum = 0.0D;
            try {
                for (String value : valueList) {
                    sum += Double.parseDouble(value);
                }
            } catch (NumberFormatException e) {
                return null;
            }
            return sum;
        }
</code></pre>
<h3 id="-27"></h3>
<h3 id="83禁止使用异常控制业务流程"><strong>8.3.禁止使用异常控制业务流程</strong></h3>
<p>相对于条件表达式，异常的处理效率更低。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public static boolean isValid (UserDO user){
            try {
                return Boolean.TRUE.equals(user.getIsValid());
            } catch (NullPointerException e) {
                return false;
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        public static boolean isValid (UserDO user){
            if (Objects.isNull(user)) {
                return false;
            }
            return Boolean.TRUE.equals(user.getIsValid());
        }
</code></pre>
<h2 id="-28"></h2>
<h2 id="9缓冲区"><strong>9.缓冲区</strong></h2>
<h3 id="91初始化时尽量指定缓冲区大小"><strong>9.1.初始化时尽量指定缓冲区大小</strong></h3>
<p>初始化时，指定缓冲区的预期容量大小，避免多次扩容浪费时间和空间。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer();
StringBuilder builder = new StringBuilder();
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer(1024);
StringBuilder builder = new StringBuilder(1024);
</code></pre>
<h3 id="-29"></h3>
<h3 id="92尽量重复使用同一缓冲区"><strong>9.2.尽量重复使用同一缓冲区</strong></h3>
<p>针对缓冲区，Java虚拟机需要花时间生成对象，还要花时间进行垃圾回收处理。所以，尽量重复利用缓冲区。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        StringBuilder builder1 = new StringBuilder(128);
        builder1.append(&quot;update t_user set name = '&quot;).append(userName).append(&quot;' where id = &quot;).append(userId);
        statement.executeUpdate(builder1.toString());
        StringBuilder builder2 = new StringBuilder(128);
        builder2.append(&quot;select id, name from t_user where id = &quot;).append(userId);
        ResultSet resultSet = statement.executeQuery(builder2.toString());...
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        StringBuilder builder = new StringBuilder(128);
        builder.append(&quot;update t_user set name = '&quot;).append(userName).append(&quot;' where id = &quot;).append(userId);
        statement.executeUpdate(builder.toString());
        builder.setLength(0);
        builder.append(&quot;select id, name from t_user where id = &quot;).append(userId);
        ResultSet resultSet = statement.executeQuery(builder.toString());...
</code></pre>
<p>其中，使用setLength方法让缓冲区重新从0开始。</p>
<h3 id="93尽量设计使用同一缓冲区"><strong>9.3.尽量设计使用同一缓冲区</strong></h3>
<p>为了提高程序运行效率，在设计上尽量使用同一缓冲区。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        // 转化XML(UserDO)
         public static String toXml (UserDO user){
            StringBuilder builder = new StringBuilder(128);
            builder.append(&quot;&lt;UserDO&gt;&quot;);
            builder.append(toXml(user.getId()));
            builder.append(toXml(user.getName()));
            builder.append(toXml(user.getRole()));
            builder.append(&quot;&lt;/UserDO&gt;&quot;);
            return builder.toString();
        }
        // 转化XML(Long)
        public static String toXml (Long value){
            StringBuilder builder = new StringBuilder(128);
            builder.append(&quot;&lt;Long&gt;&quot;);
            builder.append(value);
            builder.append(&quot;&lt;/Long&gt;&quot;);
            return builder.toString();
        }...
        // 使用代码
        UserDO user = ...;
        String xml = toXml(user);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        // 转化XML(UserDO)
        public static void toXml (StringBuilder builder, UserDO user){
            builder.append(&quot;&lt;UserDO&gt;&quot;);
            toXml(builder, user.getId());
            toXml(builder, user.getName());
            toXml(builder, user.getRole());
            builder.append(&quot;&lt;/UserDO&gt;&quot;);
        }
        // 转化XML(Long)
        public static void toXml (StringBuilder builder, Long value){
            builder.append(&quot;&lt;Long&gt;&quot;);
            builder.append(value);
            builder.append(&quot;&lt;/Long&gt;&quot;);
        }...
        // 使用代码
        UserDO user = ...;
        StringBuilder builder = new StringBuilder(1024);
        toXml(builder, user);
        String xml = builder.toString();
</code></pre>
<p>去掉每个转化方法中的缓冲区申请，申请一个缓冲区给每个转化方法使用。从时间上来说，节约了大量缓冲区的申请释放时间；从空间上来说，节约了大量缓冲区的临时存储空间。</p>
<h3 id="94尽量使用缓冲流减少io操作"><strong>9.4.尽量使用缓冲流减少IO操作</strong></h3>
<p>使用缓冲流BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream等，可以大幅较少IO次数并提升IO速度。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        try (FileInputStream input = new FileInputStream(&quot;a&quot;); FileOutputStream output = new FileOutputStream(&quot;b&quot;)) {
            int size = 0;
            byte[] temp = new byte[1024];
            while ((size = input.read(temp)) != -1) {
                output.write(temp, 0, size);
            }
        } catch (IOException e) {
            log.error(&quot;复制文件异常&quot;, e);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-javascript">        try (BufferedInputStream input = new BufferedInputStream(new FileInputStream(&quot;a&quot;)); BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(&quot;b&quot;))) {
            int size = 0;
            byte[] temp = new byte[1024];
            while ((size = input.read(temp)) != -1) {
                output.write(temp, 0, size);
            }
        } catch (IOException e) {
            log.error(&quot;复制文件异常&quot;, e);
        }
</code></pre>
<p>其中，可以根据实际情况手动指定缓冲流的大小，把缓冲流的缓冲作用发挥到最大。</p>
<h2 id="10线程"><strong>10.线程</strong></h2>
<h3 id="101在单线程中尽量使用非线程安全类"><strong>10.1.在单线程中，尽量使用非线程安全类</strong></h3>
<p>使用非线程安全类，避免了不必要的同步开销。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer(128);
buffer.append(&quot;select * from &quot;).append(T_USER).append(&quot; where id = ?&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">StringBuilder buffer = new StringBuilder(128);
buffer.append(&quot;select * from &quot;).append(T_USER).append(&quot; where id = ?&quot;);
</code></pre>
<h3 id="-30"></h3>
<h3 id="102在多线程中尽量使用线程安全类"><strong>10.2.在多线程中，尽量使用线程安全类</strong></h3>
<p>使用线程安全类，比自己实现的同步代码更简洁更高效。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">				private volatile int counter = 0;
        public void access (Long userId){
            synchronized (this) {
                counter++;
            }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">private final AtomicInteger counter = new AtomicInteger(0);
        public void access (Long userId){
            counter.incrementAndGet();    ...}
</code></pre>
<h3 id="-31"></h3>
<h3 id="103尽量减少同步代码块范围"><strong>10.3.尽量减少同步代码块范围</strong></h3>
<p>在一个方法中，可能只有一小部分的逻辑是需要同步控制的，如果同步控制了整个方法会影响执行效率。所以，尽量减少同步代码块的范围，只对需要进行同步的代码进行同步。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">  		  private volatile int counter = 0;
        public synchronized void access (Long userId){
            counter++;    ... // 非同步操作
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">				private volatile int counter = 0;
        public void access (Long userId){
            synchronized (this) {
                counter++;
            }    ... // 非同步操作}
</code></pre>
<h3 id="-32"></h3>
<h3 id="104尽量合并为同一同步代码块"><strong>10.4.尽量合并为同一同步代码块</strong></h3>
<p>同步代码块是有性能开销的，如果确定可以合并为同一同步代码块，就应该尽量合并为同一同步代码块。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">				// 处理单一订单
        public synchronized handleOrder(OrderDO order) {    ...}
        // 处理所有订单
        public void handleOrder (List &lt; OrderDO &gt; orderList) {
            for (OrderDO order : orderList) {
                handleOrder(order);
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java"> 				 // 处理单一订单
         public handleOrder(OrderDO order) {    ...}
        // 处理所有订单
        public synchronized void handleOrder (List &lt; OrderDO &gt; orderList) {
            for (OrderDO order : orderList) {
                handleOrder(order);
            }
        }
</code></pre>
<h3 id="-33"></h3>
<h3 id="105尽量使用线程池减少线程开销"><strong>10.5.尽量使用线程池减少线程开销</strong></h3>
<p>多线程中两个必要的开销：线程的创建和上下文切换。采用线程池，可以尽量地避免这些开销。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public void executeTask (Runnable runnable){
            new Thread(runnable).start();
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">private static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(10);
        public void executeTask (Runnable runnable){
            executorService.execute(runnable);
        }
</code></pre>
<h2 id="-34"></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次长途自驾呀]]></title>
        <id>https://WheatJack.github.io/post/travel0911/</id>
        <link href="https://WheatJack.github.io/post/travel0911/">
        </link>
        <updated>2020-10-17T14:52:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="青甘大环线七日攻略总结">青甘大环线七日攻略总结</h1>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giw2e1rqefj311c0s8dxr.jpg" alt="image-20200919165906897" loading="lazy"></figure>
<blockquote>
<p>主要是记录一下生活，怕老了忘记了这次旅行。之前出发前也是各种找攻略，但是没有一份很全的攻略，都是七零八落的，但是这次是自己亲身经历，抱着开源的思想，还是把坑坑洼洼的经历告诉大家，避免大家踩坑坑，好了，我们的旅途开始了。GOGOGO。我们是三人自驾游，三个单身狗。第一次自驾三千公里，突然发现有点猛，时间为20200911-20200919，一次不一样的旅行✈️✈️✈️。上面那张图是整个环线的大图，下面还有详细的小图的。</p>
</blockquote>
<h2 id="必备物品清单">必备物品清单</h2>
<blockquote>
<p>我们的组合比例是两男一女，三个死单身狗，并且妹子也不化妆，所以东西都是个人的东西，我们有两个人是24寸行李箱，另外一个精致男带了一个二十寸的小箱子，但是感觉自己带少了，我们带了内衣袜子啥的，之前在网上看攻略，要带一次性内裤，之后才发现确实要带，没得后悔药吃，因为那边好多店没空调，洗了衣服根本干不了，所以朋友都是拿吹风机死命的吹，可怜了宾馆的吹风机。有空调的宾馆，开热风，三十度，晚上都热醒了。所以emmmm，还是多带点衣服。具体看下面的清单🧾吧。</p>
</blockquote>
<h3 id="1-摄影篇">1、摄影篇</h3>
<p>首先有无人机一定要带无人机，因为好多景点都需要上帝视角来看才是最美的，有无人机可以拍出装逼的照片和视频。好多地方都需要无人机都拍的出来，什么恶魔之眼，水上雅丹等；其次，有相机就带相机，如果要拍星星✨，记得一定要带大光圈镜头，因为这边天黑了以后，银河星空都是肉眼可见那种，没带镜头，要哭了，貌似牛逼的华为也可以拍出星空来。但是专业的事情还是要专业的设备来拍。出色的手机也是很强的，还是要多拍拍，毕竟拍了才可以选，不拍肯定没得选，多拍，然后带上万能的墨镜摆pose，墨镜一戴，谁也不爱。哈哈哈哈。</p>
<h3 id="2-护肤篇">2、护肤篇</h3>
<p>这边及其干燥，必须带护肤品来，干到哭泣那种，玩个七天，感觉面容变得极其沧桑。防晒必须带过去，太阳太大了，及其大，紫外线及其强。是个妹子记得多带面膜，补补水，作为一个汉子都想带，后悔没带。</p>
<h3 id="3-衣服篇">3、衣服篇</h3>
<p>必备衣服啥的记得都带，轻薄羽绒服也是可以带的，因为早晚温度超级低。内衣内裤袜子啥的记得多带点，这边好多旅店没空调的，然后暖气也没开，导致洗了衣服根本干不了，一定要带墨镜🕶️，帽子🎩，面巾🎭，因为紫外线真的强了，光线可以照瞎狗眼🐶👀。记得带个拖鞋，因为宾馆的太脏了。枕头套记得带个。要好看，每天穿不一样的，肯定多带好看的衣服嘛，展现不一样的自己。</p>
<h3 id="4-食物篇">4、食物篇</h3>
<p>直接去超市买好几天的吃的东西就行，多买水果，多买喝的，因为及其干，多补充水份；多买些高热量的东西，因为经常是没有地方吃午饭和晚饭，因为一直在路上，emmmmm。</p>
<p>重要的事情说三遍，一定要带一个<strong>空气加湿器</strong>，**空气加湿器，空气加湿器，**一定记得，好点的酒店房间里有这个，大部分酒店是没这个的，买带USB那种，可以放在车上开着使用。</p>
<p><strong>墨镜墨镜墨镜，帽子帽子帽子，一定要带，可以遮阳，又可以当道具。</strong></p>
<h3 id="5-药物篇">5、药物篇</h3>
<p>这边没有高反，所以什么高原药就不要带了，可以带点感冒药啥的，肠胃不好带个肠炎宁来，可以带个指甲剪来，觉得在这边指甲长的特别快。</p>
<p>----------------------我是一条没有感情的分割线-----------------------</p>
<p>重要的事情说三遍，一定要带一个<strong>空气加湿器</strong>，**空气加湿器，空气加湿器，**一定记得，好点的酒店房间里有这个，大部分酒店是没这个的，买带USB那种，可以放在车上开着使用。</p>
<p><strong>墨镜墨镜墨镜，帽子帽子帽子，一定要带，可以遮阳，又可以当道具。</strong></p>
<p>----------------------我是一条没有感情的分割线-----------------------</p>
<h2 id="旅行路线">旅行路线</h2>
<blockquote>
<p>这个路线主要走的就是一个环线，全长2400公里，但是我们开了三千公里，emmm，估计是走了太多的弯路，我们是周五晚上飞机飞到西宁，然后在西宁租车，然后西宁过夜。所以西宁是起点也是终点🏁。网上类型的环线地图很多，给大家找了一个标准的。基本上都是这个，只是细节多少的原因，我们选择了租车，因为自由，但是也是有点累的，毕竟要天天开车；之前看攻略，也是可以包车的，也自由，但是这种地方还是需要方向盘掌握自己手上，包车应该会多花钱，毕竟带了一个专职司机，还是本地人，但是一般都是本地人坑游客的，哈哈哈哈，大家根据自己情况来。如果是自驾，那么你大可以放心开，这边路况真的很好，有的国道比高速路还好，而且就一段坑坑洼洼的路，其他的路都很好，在路上看到了很多轿车都跑这个路，比如20年前的Santana，还有车中之王--五菱宏光大哥，所以，兄弟别犹豫了，赶紧上路吧，车只是工具，主要是有一颗奔跑的心。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc6d72shj30lq0pqjvo.jpg" alt="IMG_2932" loading="lazy"></figure>
<p>因为我们来的那天，青海的天气不好，甘肃的天气很好，所以我们走的是青甘环线的反方向，我们先往甘肃走，然后在绕一个圈子到西宁，第一天住宿在西宁。</p>
<h3 id="1-day01">1、Day01</h3>
<blockquote>
<p>全长340KM，行程比较轻松(相对于后面的路程，真的好轻松)，到祁连山草原时海拔较高，弯道比较多，先是上山路段，然后就是下山路段，然后就是一直大直马路了，山路开车时需要注意。而且路边的厕所比较少，有公共厕所也是一元一次的收费厕所，注意不要喝太多水。</p>
</blockquote>
<p><strong>路线：西宁—黑泉水库—祁连山观景台—门源油菜花—祁连山大草原—张掖</strong></p>
<p>第一天还没有感受到西宁的干燥，因为下雨，房间有加湿器。第一天的行程比较慢，所以我们就去逛了一下超市，毕竟好多时间在车子上，所以买了好多的吃吃喝喝的，还有水果啥的，满满一大袋袋购物车🛒，自助的收银的发票都好长，如图。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4egzs7erj30u0268kjn.jpg" alt="IMG_3038" style="zoom:25%;" />
<p>购物完，我们就开始上路，第一天没找到吃早餐的地方，全靠早上买的东西，所以我们就慢慢开，然后往水库出发。在半路上，看到风景还不错，我们就下车拍了一些照片，还没有到水库。就瞎拍了几张照片，感受了一下大自然的美丽，确实没见过类似的场景。哈哈哈。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc6otl8rj31400u01ky.jpg" alt="IMG_1719" loading="lazy"></figure>
<p>路边的水emmmmm。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc70r7ikj31hc0u04qv.jpg" alt="DJI_0020-1" loading="lazy">然后就是一路上的赶路了，<strong>黑泉水库</strong>就是一个水库，我们直接开过去了，没停下来拍照。然后天气逐渐变好，我们就赶到了下一个<strong>景点祁连山观景台</strong>，这边俯瞰整个山下真的超级美，而且那天的天气也相当的好，不说🙊直接上图。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4faizrbsj31400u0kjq.jpg" alt="IMG_1722" loading="lazy"></figure>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc7coydnj31400u07wo.jpg" alt="IMG_1744"  />
<p><em><strong>帮傻雕拍的照片。。。。。。</strong></em></p>
<p>这里就是观景台了，emmmm好多人，千万别买那边卖的玉米，超级老，那边停车收费五块钱，有厕所哟。</p>
<p>然后就开始下山路了，门源我们没去，因为是江西人，看多了油菜花，没去有点后悔，看了别人的照片发现别人家的油菜花还是香的。然后我们就直奔大草原了。路上看到肉眼可见的雪山，妈呀第一次看见雪山，有点激动。天真蓝呀。</p>
<p><strong>远眺岗什卡雪峰</strong></p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4fn2pnnvj31400u0x6t.jpg" alt="IMG_1749"  />
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4ftspt82j31400u0x6r.jpg" alt="IMG_1754" loading="lazy"></figure>
<p>然后就是一路上开开开了，这227真的是最美国道(接下来会打脸的)。</p>
<p>不知道哪个山头。。。。。</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjspnao9caj31hc0u0qv8.jpg" alt="DJI_0032-1" loading="lazy"></figure>
<p>一路祁连草原连片，牛羊成群。经过扁都峡，后面就没拍照了，一直在赶路。路上到达张掖。</p>
<p>第一天，早上没吃，中午吃了一碗牛肉面。晚上在张掖吃了饭。去了是张掖最有名小吃店，emmmmm别去，好难吃。太油腻了，吃不下。别轻易尝试，一尝试就失败。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjspoxw1aij31400u07wo.jpg" alt="IMG_1773" loading="lazy"></figure>
<p><strong>今天一天的三人开支如下：</strong></p>
<p><strong>超市零食608 、过路费 38 、午饭 41、意外险 27、加油 130、住宿 190、晚饭 176</strong></p>
<h3 id="2-day-02">2、day 02</h3>
<blockquote>
<p>今天的行程是张掖一日游，然后赶路去敦煌市。今天的行程大概600+公里，感觉开了一路上的车子。张掖的丹霞地貌值得一看，尤其是第二个站最高点看的地貌非常的震撼，值得爬上去一看。</p>
</blockquote>
<p>张掖 — 丹霞地貌 — 嘉峪关市 — 敦煌</p>
<p>张掖七彩丹霞 卓尔山 牛心山早餐后前往张掖七彩丹霞，张掖七彩丹霞地貌奇观形成于600万年前，位于张掖市临泽、肃南县境内，这里是国内唯一的丹霞地貌与色彩能丘陵景观复合区。这里也被«中国国家地理»杂志评为中国最美的七大丹霞地貌之一，景区内有多个观景台供大家进行游览、摄影。丹霞景区是张掖丹霞国家地质公园的重要组成部分，分为小西天景观区和大西天景观区。它是中国干旱地区最为典型的丹霞地貌，同时也是中国发育最完整，造型最为奇特的丹霞地貌之一。</p>
<p>day 03</p>
<p>敦煌 — 敦煌莫高窟 — 鸣沙山、月牙泉</p>
<p>莫高窟俗称千佛洞，坐落在河西走廊西端的敦煌。它始建于十六国的前秦时期，历经十六国：北朝、隋、唐、五代、西夏、元等历代的兴建，形成巨大的规模，有洞窟735个，壁画4.5万平方米、泥质彩塑2415尊，是世界上现存规模最大、内容最丰富的佛教艺术地。1961年，莫高窟被中华人民共和国国务院公布为第一批全国重点文物保护单位之一。1987年，莫高窟被列为世界文化遗产。莫高窟门票购买网址http://www.mgk.org.cn/index.htm，提前30天购买，7、8月份必须提前购买，否则只能到现场后买到应急票。</p>
<p>鸣沙山月牙泉风景名胜区，1994年被定为国家重点风景名胜区，荣获“中国最美的五大沙漠之一”等荣誉称号。2015年7月20日，被批准为国家AAAAA级旅游景区。2016年1月，国家旅游局和环保部拟认定甘肃省酒泉市鸣沙山月牙泉景区为国家生态旅游示范区。</p>
<p>门票：莫高窟 200（淡季 100）；鸣沙山月牙泉 110 骆驼100</p>
<p>Day04</p>
<p>敦煌 — 阳关 — 阿克塞 — 石油小镇 — 冷湖镇 — 大柴旦</p>
<p>Day1:西宁-张掖--丹霞口旅游小镇--七彩丹霞--嘉峪关</p>
<p>Day3：嘉峪关城楼--敦煌--鸣沙山、月亮泉--敦煌</p>
<p>Day4：敦煌--莫高窟--石油小镇--大柴旦/德令哈</p>
<p>Day5：大柴旦/德令哈--可鲁克湖--茶卡盐湖--茶卡镇/共和</p>
<p>Day6：茶卡/共和--青海湖--青海湖边油菜花田--藏族民俗村--西宁</p>
<p>Day7：西宁--互助彩虹部落--塔尔寺</p>
<p>塔尔寺位于青海省西宁市湟中县鲁沙尔镇西南隅的莲花山坳中。塔尔寺院依山势建筑，由众多殿宇、经堂、佛塔、僧舍等组成，布局严谨，建筑巍峨，金碧辉煌，气势恢宏，是我国著名的藏传佛教格鲁派六大寺院之一。塔尔寺是青海省佛学院的最高学府，现设有显宗、密宗、时轮、医明四大学院（经院），藏语分别称为参尼、居巴、丁科、曼巴ce札仓。</p>
<p>二郎剑景区位于深入<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>中的特殊地理位置，以草原、沙滩、动植物为主的生态自然资源，以民间文化活动为内容，成为<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>旅游区一颗耀眼的明珠。目前，已经建成了以观鸟台、观鹿园、观海桥、观海亭为组合的观赏区，以码头广场、吉祥四瑞雕塑为组合的休闲区、以水上摩托、自驾游艇为活动内容的水上娱乐区，可以近距离接触到<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>。</p>
<p>黑马河位于西宁以西约220公里处的<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>边，是<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>环湖公路的起点，由此沿环湖公路走70公里可达著名的鸟岛，黑马河往鸟岛方向这一段，又被称为环湖西路，不少&quot;暴走族&quot;驴友或自行车迷，都选择从黑马河开始他们的环湖梦幻之旅。</p>
<p>茶卡盐湖位于青海省海西蒙古族藏族自治州乌兰县茶卡镇附近，盐湖四周雪山环绕，纯净、蓝白、倒影交织，恍若一面天然明镜。因其旅游资源禀赋可与玻利维亚乌尤尼盐沼相媲美，享有中国&quot;天空之镜&quot;之美称，是&quot;青海四大景&quot;之一，是国家旅游地理杂志评选的&quot;人一生必去的55个地方&quot;之一。</p>
<p>第一天，西宁出发，塔尔寺，拉鸡山旅游公路，二郎剑151基地、到达黑马河，住黑马河。</p>
<p>第二天 黑马河看日出，茶卡盐湖、柴达木、德令哈、外星人遗址、翡翠湖,大柴旦住宿。</p>
<p>第三天 大柴旦出发，青海雅丹魔鬼城，阳关，敦煌古城，敦煌住宿，敦煌夜市。</p>
<p>第四天，莫高窟，鸣沙山，月牙泉，敦煌住宿。</p>
<p>第五天 敦煌出发，嘉峪关城楼、七彩丹霞到达张掖。</p>
<p>第六天  张掖出发，扁都口风景旅游区、祁连山大草原、阿柔大寺、祁连卓尔山风景区，住祁连。</p>
<p>第七天，祁连出发，岗卡什雪峰，门源，黑泉水库，到达西宁</p>
<p>Day1：西宁-青海湖-茶卡盐湖-德令哈</p>
<p>Day2：翡翠湖-U型公路-东台-水上雅丹</p>
<p>Day3：西台吉乃尔湖-火星一号公路-火星营地</p>
<p>Day4：恶魔之眼-冷湖-石油小镇 阿克塞老县城</p>
<p>Day5：敦煌莫高窟-鸣沙山-月牙泉</p>
<p>Day6：敦煌-嘉峪关-张掖七彩丹霞</p>
<p>Day7：张掖-门源-祁连大草原-西宁</p>
<p>􏲮􏲯􏰚􏱰􏳖􏴘􏷺􏷻􏷦􏳜􏳝􏳞􏱫􏳌􏶉􏷼􏳑􏷽􏱉􏱊􏱋􏱫􏱉􏱊􏱋􏷾􏷿􏱦 西宁*—30km—<em>塔尔寺</em>—120km—<em>青海湖畔</em>—80km—*黑马河，夜宿黑马河。</p>
<p>早晨 8 点左右出发即可，塔尔寺游玩时间一般在 2 小时，然后驱车前往青海湖，一路边走边玩，经过日月山，到达青海湖南岸。在青海湖边，近距离体验湖水。然后到达黑马河边住宿休息，还能再次去青海湖边，继续欣赏。门票：塔尔寺 80 元；日月山 40 元；青海湖二郎剑 100 元；青海湖进入牧民家 20 元左右；</p>
<p>主要看点：藏传佛教塔尔寺、高原蓝宝石青海湖、青海湖星空。</p>
<p>黑马河*—80km—<em>茶卡盐湖</em>—220km—<em>德令哈</em>—240km—*大柴旦镇；</p>
<p>从茶卡盐湖出来后，就向德令哈方向去。德令哈有可鲁克湖、托素湖、外星人遗址，都是路过即可，没必要买票进入。经过德令哈后一路直奔大柴旦，这个小镇子，每年夏季每天有近 1 万人入住。</p>
<p>门票：茶卡盐湖 70；可鲁克湖 20</p>
<p>主要看点：黑马河日出、茶卡盐湖、戈壁公路</p>
<p>大柴旦*—20km—<em>柴达木盆地公路</em>—200km—<em>青海冷湖雅丹</em>—40km—<em>阿克塞</em>—64km—<em>阳关遗址</em>—63km—<em>敦煌市（或是大柴旦</em>—20km—<em>柴达木盆地公路</em>—240km—<em>阿克塞</em>—122km—<em>玉门关</em>—60km—<em>敦煌雅丹魔鬼城</em>—170km—*敦煌市）；</p>
<p>这两个走法的主要差别在于——雅丹，你是走青海的冷湖雅丹，还是走敦煌的雅丹。两处雅丹各有优劣，目前来说大环线多数都是走青海雅丹。原因有三：无需门票，可以随便进入；亚洲规模最大；路程轻松些。敦煌雅丹进入是捆绑玉门关的门票。敦煌雅丹气势更凌人，但玉门关若不是几句诗词，确是有些不尽人意的。</p>
<p>从大柴旦镇出来后，就是在柴达木盆地的外侧了，公路笔直的延伸在戈壁滩上，雅丹地貌排列在路的两边。到达冷湖后，青海的雅丹地貌群尽显，壮观威严。到 “西出阳关无故人” 的阳关后，再一赏古人面对戈壁的无限苍凉。然后入住敦煌，尽享繁华。</p>
<p>门票：青海雅丹魔鬼城免费，阳关遗址 60，玉门关 40</p>
<p>主要看点：青海雅丹、柴达木盆地公路片、阳关</p>
]]></content>
    </entry>
</feed>