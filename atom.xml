<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://HelloJackGao.github.io</id>
    <title>JackBlog</title>
    <updated>2020-12-06T12:28:08.994Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://HelloJackGao.github.io"/>
    <link rel="self" href="https://HelloJackGao.github.io/atom.xml"/>
    <subtitle>Hello World</subtitle>
    <logo>https://HelloJackGao.github.io/images/avatar.png</logo>
    <icon>https://HelloJackGao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JackBlog</rights>
    <entry>
        <title type="html"><![CDATA[高效代码]]></title>
        <id>https://HelloJackGao.github.io/post/aLiCode/</id>
        <link href="https://HelloJackGao.github.io/post/aLiCode/">
        </link>
        <updated>2020-10-28T13:45:42.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1常量变量"><strong>1.常量&amp;变量</strong></h2>
<h3 id="11直接赋值常量值禁止声明新对象"><strong>1.1.直接赋值常量值，禁止声明新对象</strong></h3>
<p>直接赋值常量值，只是创建了一个对象引用，而这个对象引用指向常量值。</p>
<p><strong>反例：</strong></p>
<pre><code>Long i = new Long(1L);String s = new String(&quot;abc&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>Long i = 1L;String s = &quot;abc&quot;;
</code></pre>
<h3 id="12当成员变量值无需改变时尽量定义为静态常量"><strong>1.2.当成员变量值无需改变时，尽量定义为静态常量</strong></h3>
<p>在类的每个对象实例中，每个成员变量都有一份副本，而成员静态常量只有一份实例。</p>
<p><strong>反例：</strong></p>
<pre><code>public class HttpConnection {    private final long timeout = 5L;    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public class HttpConnection {    private static final long TIMEOUT = 5L;    ...}
</code></pre>
<h3 id="13尽量使用基本数据类型避免自动装箱和拆箱"><strong>1.3.尽量使用基本数据类型，避免自动装箱和拆箱</strong></h3>
<p>Java 中的基本数据类型double、float、long、int、short、char、boolean，分别对应包装类Double、Float、Long、Integer、Short、Character、Boolean。JVM支持基本类型与对应包装类的自动转换，被称为自动装箱和拆箱。装箱和拆箱都是需要CPU和内存资源的，所以应尽量避免使用自动装箱和拆箱。</p>
<p><strong>反例：</strong></p>
<pre><code>Integer sum = 0;int[] values = ...;for (int value : values) {    sum += value; // 相当于result = Integer.valueOf(result.intValue() + value);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int sum = 0;int[] values = ...;for (int value : values) {    sum += value;}
</code></pre>
<h3 id="14如果变量的初值会被覆盖就没有必要给变量赋初值"><strong>1.4.如果变量的初值会被覆盖，就没有必要给变量赋初值</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;();if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList;if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<h3 id="15尽量使用函数内的基本类型临时变量"><strong>1.5.尽量使用函数内的基本类型临时变量</strong></h3>
<p>在函数内，基本类型的参数和临时变量都保存在栈（Stack）中，访问速度较快；对象类型的参数和临时变量的引用都保存在栈（Stack）中，内容都保存在堆（Heap）中，访问速度较慢。在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">public final class Accumulator {    private double result = 0.0D;    public void addAll(@NonNull double[] values) {        for(double value : values) {            result += value;        }    }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public final class Accumulator {    private double result = 0.0D;    public void addAll(@NonNull double[] values) {        double sum = 0.0D;        for(double value : values) {            sum += value;        }        result += sum;    }    ...}
</code></pre>
<h3 id="16尽量不要在循环体外定义变量"><strong>1.6.尽量不要在循环体外定义变量</strong></h3>
<p>在老版JDK中，建议“尽量不要在循环体内定义变量”，但是在新版的JDK中已经做了优化。通过对编译后的字节码分析，变量定义在循环体外和循环体内没有本质的区别，运行效率基本上是一样的。</p>
<p>反而，根据“ 局部变量作用域最小化 ”原则，变量定义在循环体内更科学更便于维护，避免了延长大对象生命周期导致延缓回收问题 。</p>
<p><strong>反例：</strong></p>
<pre><code>UserVO userVO;List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="17不可变的静态常量尽量使用非线程安全类"><strong>1.7.不可变的静态常量，尽量使用非线程安全类</strong></h3>
<p>不可变的静态常量，虽然需要支持多线程访问，也可以使用非线程安全类。</p>
<p><strong>反例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new ConcurrentHashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new HashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<h3 id="18不可变的成员变量尽量使用非线程安全类">1.8.不可变的成员变量，尽量使用非线程安全类**</h3>
<p>不可变的成员变量，虽然需要支持多线程访问，也可以使用非线程安全类。</p>
<p><strong>反例：</strong></p>
<pre><code>@Servicepublic class StrategyFactory implements InitializingBean {    @Autowired    private List&lt;Strategy&gt; strategyList;    private Map&lt;String, Strategy&gt; strategyMap;    @Override    public void afterPropertiesSet() {        if (CollectionUtils.isNotEmpty(strategyList)) {            int size = (int) Math.ceil(strategyList.size() * 4.0 / 3);            Map&lt;String, Strategy&gt; map = new ConcurrentHashMap&lt;&gt;(size);            for (Strategy strategy : strategyList) {                map.put(strategy.getType(), strategy);            }            strategyMap = Collections.unmodifiableMap(map);        }    }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>@Servicepublic class StrategyFactory implements InitializingBean {    @Autowired    private List&lt;Strategy&gt; strategyList;    private Map&lt;String, Strategy&gt; strategyMap;    @Override    public void afterPropertiesSet() {        if (CollectionUtils.isNotEmpty(strategyList)) {            int size = (int) Math.ceil(strategyList.size() * 4.0 / 3);            Map&lt;String, Strategy&gt; map = new HashMap&lt;&gt;(size);            for (Strategy strategy : strategyList) {                map.put(strategy.getType(), strategy);            }            strategyMap = Collections.unmodifiableMap(map);        }    }    ...
</code></pre>
<h2 id=""></h2>
<h2 id="2对象类"><strong>2</strong>.对象&amp;类</h2>
<h3 id="21禁止使用json转化对象"><strong>2.1.禁止使用JSON转化对象</strong></h3>
<p>JSON提供把对象转化为JSON字符串、把JSON字符串转为对象的功能，于是被某些人用来转化对象。这种对象转化方式，虽然在功能上没有问题，但是在性能上却存在问题。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="22尽量不使用反射赋值对象"><strong>2.2.尽量不使用反射赋值对象</strong></h3>
<p>用反射赋值对象，主要优点是节省了代码量，主要缺点却是性能有所下降。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    BeanUtils.copyProperties(userDO, userVO);    userVOList.add(userVO);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userDOList = ...;List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());for (UserDO userDO : userDOList) {    UserVO userVO = new UserVO();    userVO.setId(userDO.getId());    ...    userVOList.add(userVO);}
</code></pre>
<h3 id="-2"></h3>
<h3 id="23采用lambda表达式替换内部匿名类"><strong>2.3.采用Lambda表达式替换内部匿名类</strong></h3>
<p>对于大多数刚接触JDK8的同学来说，都会认为Lambda表达式就是匿名内部类的语法糖。实际上， Lambda表达式在大多数虚拟机中采用invokeDynamic指令实现，相对于匿名内部类在效率上会更高一些。</p>
<p><strong>反例：</strong></p>
<pre><code>List&lt;User&gt; userList = ...;Collections.sort(userList, new Comparator&lt;User&gt;() {    @Override    public int compare(User user1, User user2) {        Long userId1 = user1.getId();        Long userId2 = user2.getId();        ...        return userId1.compareTo(userId2);    }});
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;User&gt; userList = ...;Collections.sort(userList, (user1, user2) -&gt; {    Long userId1 = user1.getId();    Long userId2 = user2.getId();    ...    return userId1.compareTo(userId2);});
</code></pre>
<h3 id="-3"></h3>
<h3 id="24尽量避免定义不必要的子类"><strong>2.4.尽量避免定义不必要的子类</strong></h3>
<p>多一个类就需要多一份类加载，所以尽量避免定义不必要的子类。</p>
<p><strong>反例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP =    Collections.unmodifiableMap(new HashMap&lt;String, Class&gt;(16) {    private static final long serialVersionUID = 1L;    {        put(&quot;VARCHAR&quot;, java.lang.String.class);    }});
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static final Map&lt;String, Class&gt; CLASS_MAP;static {    Map&lt;String, Class&gt; classMap = new HashMap&lt;&gt;(16);    classMap.put(&quot;VARCHAR&quot;, java.lang.String.class);    ...    CLASS_MAP = Collections.unmodifiableMap(classMap);}
</code></pre>
<h3 id="-4"></h3>
<h3 id="25尽量指定类的final修饰符"><strong>2.5.尽量指定类的final修饰符</strong></h3>
<p>为类指定final修饰符，可以让该类不可以被继承。如果指定了一个类为final，则该类所有的方法都是final的，Java编译器会寻找机会内联所有的final方法。内联对于提升Java运行效率作用重大，具体可参见Java运行期优化，能够使性能平均提高50%。</p>
<p><strong>反例：</strong></p>
<pre><code>public class DateHelper {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public final class DateHelper {    ...}
</code></pre>
<p>注意：使用Spring的AOP特性时，需要对Bean进行动态代理，如果Bean类添加了final修饰，会导致异常。</p>
<h2 id="3方法"><strong>3.方法</strong></h2>
<h3 id="31把跟类成员变量无关的方法声明成静态方法"><strong>3.1.把跟类成员变量无关的方法声明成静态方法</strong></h3>
<p>静态方法的好处就是不用生成类的实例就可以直接调用。静态方法不再属于某个对象，而是属于它所在的类。只需要通过其类名就可以访问，不需要再消耗资源去反复创建对象。即便在类内部的私有方法，如果没有使用到类成员变量，也应该声明为静态方法。</p>
<p><strong>反例：</strong></p>
<pre><code>public int getMonth(Date date) {  Calendar calendar = Calendar.getInstance();  calendar.setTime(date);  return calendar.get(Calendar.MONTH) + 1;}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static int getMonth(Date date) {  Calendar calendar = Calendar.getInstance();  calendar.setTime(date);  return calendar.get(Calendar.MONTH) + 1;}
</code></pre>
<h3 id="32尽量使用基本数据类型作为方法参数类型避免不必要的装箱-拆箱和空指针判断"><strong>3.2.尽量使用基本数据类型作为方法参数类型，避免不必要的装箱、拆箱和空指针判断</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>public static double sum(Double value1, Double value2) {    double double1 = Objects.isNull(value1) ? 0.0D : value1;    double double2 = Objects.isNull(value2) ? 0.0D : value2;    return double1 + double2;}double result = sum(1.0D, 2.0D);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static double sum(double value1, double value2) {    return value1 + value2;}double result = sum(1.0D, 2.0D);
</code></pre>
<h3 id="33尽量使用基本数据类型作为方法返回值类型避免不必要的装箱-拆箱和空指针判断">3.3.尽量使用基本数据类型作为方法返回值类型，避免不必要的装箱、拆箱和空指针判断</h3>
<p>在JDK类库的方法中，很多方法返回值都采用了基本数据类型，首先是为了避免不必要的装箱和拆箱，其次是为了避免返回值的空指针判断。比如：Collection.isEmpty()和Map.size()。</p>
<p><strong>反例：</strong></p>
<pre><code>public static Boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
// 调用代码UserDO user = ...;Boolean isValid = isValid(user);if (Objects.nonNull(isValid) &amp;&amp; isValid.booleanValue()) {     ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
// 调用代码UserDO user = ...;if (isValid(user)) {    ...}
</code></pre>
<h3 id="-5"></h3>
<h3 id="34协议方法参数值非空避免不必要的空指针判断"><strong>3.4.协议方法参数值非空，避免不必要的空指针判断</strong></h3>
<p>协议编程，可以@NonNull和@Nullable标注参数，是否遵循全凭调用者自觉。</p>
<p><strong>反例：</strong></p>
<pre><code>public static boolean isValid(UserDO user) {    if (Objects.isNull(user)) {        return false;    }  return Boolean.TRUE.equals(user.getIsValid());}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public static boolean isValid(@NonNull UserDO user) {  return Boolean.TRUE.equals(user.getIsValid());}
</code></pre>
<h3 id="-6"></h3>
<h3 id="35协议方法返回值非空避免不必要的空指针判断"><strong>3.5.协议方法返回值非空，避免不必要的空指针判断</strong></h3>
<p>协议编程，可以@NonNull和@Nullable标注参数，是否遵循全凭实现者自觉。</p>
<p><strong>反例：</strong></p>
<pre><code>// 定义接口public interface OrderService {    public List&lt;OrderVO&gt; queryUserOrder(Long userId);}
// 调用代码List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);if (CollectionUtils.isNotEmpty(orderList)) {    for (OrderVO order : orderList) {        ...    }}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>// 定义接口public interface OrderService {    @NonNull    public List&lt;OrderVO&gt; queryUserOrder(Long userId);}
// 调用代码List&lt;OrderVO&gt; orderList = orderService.queryUserOrder(userId);for (OrderVO order : orderList) {    ...}
</code></pre>
<h3 id="-7"></h3>
<h3 id="36被调用方法已支持判空处理调用方法无需再进行判空处理"><strong>3.6.被调用方法已支持判空处理，调用方法无需再进行判空处理</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>UserDO user = null;if (StringUtils.isNotBlank(value)) {    user = JSON.parseObject(value, UserDO.class);}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>UserDO user = JSON.parseObject(value, UserDO.class);
</code></pre>
<h3 id="37尽量避免不必要的函数封装"><strong>3.7.尽量避免不必要的函数封装</strong></h3>
<p>方法调用会引起入栈和出栈，导致消耗更多的CPU和内存，应当尽量避免不必要的函数封装。当然，为了使代码更简洁、更清晰、更易维护，增加一定的方法调用所带来的性能损耗是值得的。</p>
<p><strong>反例：</strong></p>
<pre><code>// 函数封装public static boolean isVip(Boolean isVip) {    return Boolean.TRUE.equals(isVip);}
// 使用代码boolean isVip = isVip(user.getVip());
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>boolean isVip = Boolean.TRUE.equals(user.getVip());
</code></pre>
<h3 id="38尽量指定方法的final修饰符"><strong>3.8.尽量指定方法的final修饰符</strong></h3>
<p>方法指定final修饰符，可以让方法不可以被重写，Java编译器会寻找机会内联所有的final方法。内联对于提升Java运行效率作用重大，具体可参见Java运行期优化，能够使性能平均提高50%。</p>
<p>注意：所有的private方法会隐式地被指定final修饰符，所以无须再为其指定final修饰符。</p>
<p><strong>反例：</strong></p>
<pre><code>public class Rectangle {    ...    public double area() {        ...    }}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>public class Rectangle {    ...    public final double area() {        ...    }}
</code></pre>
<p>注意：使用Spring的AOP特性时，需要对Bean进行动态代理，如果方法添加了final修饰，将不会被代理。</p>
<h2 id="4表达式"><strong>4.表达式</strong></h2>
<h3 id="41尽量减少方法的重复调用"><strong>4.1.尽量减少方法的重复调用</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = ...;for (int i = 0; i &lt; userList.size(); i++) {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = ...;int userLength = userList.size();for (int i = 0; i &lt; userLength; i++) {    ...}
</code></pre>
<h3 id="-8"></h3>
<h3 id="42尽量避免不必要的方法调用"><strong>4.2.尽量避免不必要的方法调用</strong></h3>
<p><strong>反例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList = userDAO.queryActive();if (isAll) {    userList = userDAO.queryAll();}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>List&lt;UserDO&gt; userList;if (isAll) {    userList = userDAO.queryAll();} else {    userList = userDAO.queryActive();}
</code></pre>
<h3 id="-9"></h3>
<h3 id="43尽量使用移位来代替正整数乘除"><strong>4.3.尽量使用移位来代替正整数乘除</strong></h3>
<p>用移位操作可以极大地提高性能。对于乘除2^n(n为正整数)的正整数计算，可以用移位操作来代替。</p>
<p><strong>反例：</strong></p>
<pre><code>int num1 = a * 4;int num2 = a / 4;
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int num1 = a &lt;&lt; 2;int num2 = a &gt;&gt; 2;
</code></pre>
<h3 id="-10"></h3>
<h3 id="44提取公共表达式避免重复计算"><strong>4.4.提取公共表达式，避免重复计算</strong></h3>
<p>提取公共表达式，只计算一次值，然后重复利用值。</p>
<p><strong>反例：</strong></p>
<pre><code>double distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>double dx = x2 - x1;double dy = y2 - y1;double distance = Math.sqrt(dx * dx + dy * dy);或double distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
</code></pre>
<h3 id="-11"></h3>
<h3 id="45尽量不在条件表达式中用取反"><strong>4.5.尽量不在条件表达式中用!取反</strong></h3>
<p>使用!取反会多一次计算，如果没有必要则优化掉。</p>
<p><strong>反例：</strong></p>
<pre><code>if (!(a &gt;= 10)) {    ... // 条件处理1} else {    ... // 条件处理2}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>if (a &lt; 10) {    ... // 条件处理1} else {    ... // 条件处理2}
</code></pre>
<h3 id="-12"></h3>
<h3 id="46对于多常量选择分支尽量使用switch语句而不是if-else语句"><strong>4.6.对于多常量选择分支，尽量使用switch语句而不是if-else语句</strong></h3>
<p>if-else语句，每个if条件语句都要加装计算，直到if条件语句为true为止。switch语句进行了跳转优化，Java中采用tableswitch或lookupswitch指令实现，对于多常量选择分支处理效率更高。经过试验证明：在每个分支出现概率相同的情况下，低于5个分支时if-else语句效率更高，高于5个分支时switch语句效率更高。</p>
<p><strong>反例：</strong></p>
<pre><code>if (i == 1) {    ...; // 分支1} else if (i == 2) {    ...; // 分支2} else if (i == ...) {    ...; // 分支n} else {    ...; // 分支n+1}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>switch (i) {    case 1 :        ... // 分支1        break;    case 2 :        ... // 分支2        break;    case ... :        ... // 分支n        break;    default :        ... // 分支n+1        break;}
</code></pre>
<p>备注：如果业务复杂，可以采用Map实现策略模式。</p>
<h2 id="5字符串"><strong>5.字符串</strong></h2>
<h3 id="51尽量不要使用正则表达式匹配"><strong>5.1.尽量不要使用正则表达式匹配</strong></h3>
<p>正则表达式匹配效率较低，尽量使用字符串匹配操作。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">String source = &quot;a::1,b::2,c::3,d::4&quot;;
String target = source.replaceAll(&quot;::&quot;, &quot;=&quot;);
Stringp[] targets = source.spit(&quot;::&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">String source = &quot;a::1,b::2,c::3,d::4&quot;;
String target = source.replace(&quot;::&quot;, &quot;=&quot;);
Stringp[] targets = StringUtils.split(source, &quot;::&quot;);
</code></pre>
<h3 id="-13"></h3>
<h3 id="52尽量使用字符替换字符串"><strong>5.2.尽量使用字符替换字符串</strong></h3>
<p>字符串的长度不确定，而字符的长度固定为1，查找和匹配的效率自然提高了</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">String source = &quot;a:1,b:2,c:3,d:4&quot;;
int index = source.indexOf(&quot;:&quot;);
String target = source.replace(&quot;:&quot;, &quot;=&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">String source = &quot;a:1,b:2,c:3,d:4&quot;;
int index = source.indexOf(':');
String target = source.replace(':', '=');
</code></pre>
<h3 id="-14"></h3>
<h3 id="53尽量使用stringbuilder进行字符串拼接"><strong>5.3.尽量使用StringBuilder进行字符串拼接</strong></h3>
<p>String是final类，内容不可修改，所以每次字符串拼接都会生成一个新对象。StringBuilder在初始化时申请了一块内存，以后的字符串拼接都在这块内存中执行，不会申请新内存和生成新对象。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        String s = &quot;&quot;;
        for (int i = 0; i &lt; 10; i++) {
            if (i != 0) {
                s += ',';
            }
            s += i;
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        StringBuilder sb = new StringBuilder(128);
        for (int i = 0; i &lt; 10; i++) {
            if (i != 0) {
                sb.append(',');
            }
            sb.append(i);
        }
</code></pre>
<h3 id="-15"></h3>
<h3 id="54不要使用转化字符串"><strong>5.4.不要使用&quot;&quot;+转化字符串</strong></h3>
<p>使用&quot;&quot;+进行字符串转化，使用方便但是效率低，建议使用String.valueOf.</p>
<p><strong>反例：</strong></p>
<pre><code>int i = 12345;String s = &quot;&quot; + i;
</code></pre>
<p><strong>正例：</strong></p>
<pre><code>int i = 12345;String s = String.valueOf(i);
</code></pre>
<h2 id="-16"></h2>
<h2 id="6数组"><strong>6.数组</strong></h2>
<h3 id="61不要使用循环拷贝数组尽量使用systemarraycopy拷贝数组"><strong>6.1.不要使用循环拷贝数组，尽量使用System.arraycopy拷贝数组</strong></h3>
<p>推荐使用System.arraycopy拷贝数组，也可以使用Arrays.copyOf拷贝数组。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">int[] sources = new int[] {1, 2, 3, 4, 5};
int[] targets = new int[sources.length];
for (int i = 0; i &lt; targets.length; i++) {    targets[i] = sources[i];}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">int[] sources = new int[] {1, 2, 3, 4, 5};
int[] targets = new int[sources.length];
System.arraycopy(sources, 0, targets, 0, targets.length);
</code></pre>
<h3 id="-17"></h3>
<h3 id="62集合转化为类型t数组时尽量传入空数组t0"><strong>6.2.集合转化为类型T数组时，尽量传入空数组T[0]</strong></h3>
<p>将集合转换为数组有2种形式：toArray(new T[n])和toArray(new T[0])。在旧的Java版本中，建议使用toArray(new T[n])，因为创建数组时所需的反射调用非常慢。在OpenJDK6后，反射调用是内在的，使得性能得以提高，toArray(new T[0])比toArray(new T[n])效率更高。此外，toArray(new T[n])比toArray(new T[0])多获取一次列表大小，如果计算列表大小耗时过长，也会导致toArray(new T[n])效率降低</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, ...);
Integer[] integers = integerList.toArray(new Integer[integerList.size()]);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, ...);
Integer[] integers = integerList.toArray(new Integer[0]); // 勿用new Integer[]{}
</code></pre>
<p>建议：集合应该提供一个toArray(Class<T> clazz)方法，避免无用的空数组初始化（new T[0]）。</p>
<h3 id="63集合转化为object数组时尽量使用toarray方法"><strong>6.3.集合转化为Object数组时，尽量使用toArray()方法</strong></h3>
<p>转化Object数组时，没有必要使用toArray[new Object[0]]，可以直接使用toArray()。避免了类型的判断，也避免了空数组的申请，所以效率会更高。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">List&lt;Object&gt; objectList = Arrays.asList(1, &quot;2&quot;, 3, &quot;4&quot;, 5, ...);
Object[] objects = objectList.toArray(new Object[0]);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">List&lt;Object&gt; objectList = Arrays.asList(1, &quot;2&quot;, 3, &quot;4&quot;, 5, ...);
Object[] objects = objectList.toArray();
</code></pre>
<h2 id="-18"></h2>
<h2 id="7集合"><strong>7.集合</strong></h2>
<h3 id="71初始化集合时尽量指定集合大小"><strong>7.1.初始化集合时，尽量指定集合大小</strong></h3>
<p>Java集合初始化时都会指定一个默认大小，当默认大小不再满足数据需求时就会扩容，每次扩容的时间复杂度有可能是O(n)。所以，尽量指定预知的集合大小，就能避免或减少集合的扩容次数。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userDOList = ...;
        Set&lt;Long&gt; userSet = new HashSet&lt;&gt;();
        Map&lt;Long, UserDO&gt; userMap = new HashMap&lt;&gt;();
        List&lt;UserVO&gt; userList = new ArrayList&lt;&gt;();
        for (UserDO userDO : userDOList) {
            userSet.add(userDO.getId());
            userMap.put(userDO.getId(), userDO);
            userList.add(transUser(userDO));
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userDOList = ...;
        int userSize = userDOList.size();
        Set&lt;Long&gt; userSet = new HashSet&lt;&gt;(userSize);
        Map&lt;Long, UserDO&gt; userMap = new HashMap&lt;&gt;((int) Math.ceil(userSize * 4.0 / 3));
        List&lt;UserVO&gt; userList = new ArrayList&lt;&gt;(userSize);
        for (UserDO userDO : userDOList) {
            userSet.add(userDO.getId());
            userMap.put(userDO.getId(), userDO);
            userList.add(transUser(userDO));
        }
</code></pre>
<h3 id="-19"></h3>
<h3 id="72不要使用循环拷贝集合尽量使用jdk提供的方法拷贝集合"><strong>7.2.不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合</strong></h3>
<p>JDK提供的方法可以一步指定集合的容量，避免多次扩容浪费时间和空间。同时，这些方法的底层也是调用System.arraycopy方法实现，进行数据的批量拷贝效率更高。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; user1List = ...;
        List&lt;UserDO&gt; user2List = ...;
        List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;(user1List.size() + user2List.size());
        for (UserDO user1 : user1List) {
            userList.add(user1);
        }
        for (UserDO user2 : user2List) {
            userList.add(user2);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; user1List = ...;
        List&lt;UserDO&gt; user2List = ...;
        List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;(user1List.size() + user2List.size());
        userList.addAll(user1List);
        userList.addAll(user2List);
</code></pre>
<h3 id="-20"></h3>
<h3 id="73尽量使用arraysaslist转化数组为列表"><strong>7.3.尽量使用Arrays.asList转化数组为列表</strong></h3>
<p>原理与&quot;不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合&quot;类似。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;String&gt; typeList = new ArrayList&lt;&gt;(8);
        typeList.add(&quot;Short&quot;);
        typeList.add(&quot;Integer&quot;);
        typeList.add(&quot;Long&quot;);
        String[] names = ...;
        List&lt;String&gt; nameList = ...;
        for (String name : names) {
            nameList.add(name);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;String&gt; typeList = Arrays.asList(&quot;Short&quot;, &quot;Integer&quot;, &quot;Long&quot;);
        String[] names = ...;
        List&lt;String&gt; nameList = ...;
        nameList.addAll(Arrays.asList(names));
</code></pre>
<h3 id="-21"></h3>
<h3 id="74直接迭代需要使用的集合"><strong>7.4.直接迭代需要使用的集合</strong></h3>
<p>直接迭代需要使用的集合，无需通过其它操作获取数据。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        Map&lt;Long, UserDO&gt; userMap = ...;
        for (Long userId : userMap.keySet()) {
            UserDO user = userMap.get(userId);    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        Map&lt;Long, UserDO&gt; userMap = ...;
        for (Map.Entry&lt;Long, UserDO&gt; userEntry : userMap.entrySet()) {
            Long userId = userEntry.getKey();
            UserDO user = userEntry.getValue();    ...}
</code></pre>
<h3 id="-22"></h3>
<h3 id="75不要使用size方法检测空必须使用isempty方法检测空"><strong>7.5.不要使用size方法检测空，必须使用isEmpty方法检测空</strong></h3>
<p>使用size方法来检测空逻辑上没有问题，但使用isEmpty方法使得代码更易读，并且可以获得更好的性能。任何isEmpty方法实现的时间复杂度都是O(1)，但是某些size方法实现的时间复杂度有可能是O(n)。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userList = ...;
        if (userList.size() == 0) {    ...}
        Map&lt;Long, UserDO&gt; userMap = ...;
        if (userMap.size() == 0) {    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        List&lt;UserDO&gt; userList = ...;
        if (userList.isEmpty()) {    ...} 
        Map&lt;Long, UserDO&gt; userMap = ...;
        if (userMap.isEmpty()) {    ...}
</code></pre>
<h3 id="-23"></h3>
<h3 id="76非随机访问的list尽量使用迭代代替随机访问"><strong>7.6.非随机访问的List，尽量使用迭代代替随机访问</strong></h3>
<p>对于列表，可分为随机访问和非随机访问两类，可以用是否实现RandomAccess接口判断。随机访问列表，直接通过get获取数据不影响效率。而非随机访问列表，通过get获取数据效率极低。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        LinkedList&lt;UserDO&gt; userDOList = ...;
        int size = userDOList.size();
        for (int i = 0; i &lt; size; i++) {
            UserDO userDO = userDOList.get(i);    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        LinkedList&lt;UserDO&gt; userDOList = ...;
        for (UserDO userDO : userDOList) {    ...}
</code></pre>
<p>其实，不管列表支不支持随机访问，都应该使用迭代进行遍历。</p>
<h3 id="77尽量使用hashset判断值存在"><strong>7.7.尽量使用HashSet判断值存在</strong></h3>
<p>在Java集合类库中，List的contains方法普遍时间复杂度是O(n)，而HashSet的时间复杂度为O(1)。如果需要频繁调用contains方法查找数据，可以先将List转换成HashSet。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        List&lt;Long&gt; adminIdList = ...;
        List&lt;UserDO&gt; userDOList = ...;
        List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());
        for (UserDO userDO : userDOList) {
            if (adminIdList.contains(userDO.getId())) {
                userVOList.add(transUser(userDO));
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        Set&lt;Long&gt; adminIdSet = ...;
        List&lt;UserDO&gt; userDOList = ...;
        List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;(userDOList.size());
        for (UserDO userDO : userDOList) {
            if (adminIdSet.contains(userDO.getId())) {
                userVOList.add(transUser(userDO));
            }
        }
</code></pre>
<h3 id="-24"></h3>
<h3 id="78避免先判断存在再进行获取"><strong>7.8.避免先判断存在再进行获取</strong></h3>
<p>如果需要先判断存在再进行获取，可以直接获取并判断空，从而避免了二次查找操作。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">    public static UserVO transUser(UserDO user, Map&lt;Long, RoleDO&gt; roleMap) {
        UserVO userVO = new UserVO();
        userVO.setId(user.getId());    ...if (roleMap.contains(user.getRoleId())) {
            RoleDO role = roleMap.get(user.getRoleId());
            userVO.setRole(transRole(role));
        }
    }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">    public static UserVO transUser(UserDO user, Map&lt;Long, RoleDO&gt; roleMap) {
        UserVO userVO = new UserVO();
        userVO.setId(user.getId());    ...RoleDO role = roleMap.get(user.getRoleId());
        if (Objects.nonNull(role)) {
            userVO.setRole(transRole(role));
        }
    }
</code></pre>
<h2 id="-25"></h2>
<h2 id="8异常"><strong>8.异常</strong></h2>
<h3 id="81直接捕获对应的异常"><strong>8.1.直接捕获对应的异常</strong></h3>
<p>直接捕获对应的异常，避免用instanceof判断，效率更高代码更简洁。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        try {
            saveData();
        } catch (Exception e) {
            if (e instanceof IOException) {
                log.error(&quot;保存数据IO异常&quot;, e);
            } else {
                log.error(&quot;保存数据其它异常&quot;, e);
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        try {
            saveData();
        } catch (IOException e) {
            log.error(&quot;保存数据IO异常&quot;, e);
        } catch (Exception e) {
            log.error(&quot;保存数据其它异常&quot;, e);
        }
</code></pre>
<h3 id="-26"></h3>
<h3 id="82尽量避免在循环中捕获异常"><strong>8.2.尽量避免在循环中捕获异常</strong></h3>
<p>当循环体抛出异常后，无需循环继续执行时，没有必要在循环体中捕获异常。因为，过多的捕获异常会降低程序执行效率。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public Double sum (List &lt; String &gt; valueList) {
            double sum = 0.0D;
            for (String value : valueList) {
                try {
                    sum += Double.parseDouble(value);
                } catch (NumberFormatException e) {
                    return null;
                }
            }
            return sum;
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        public Double sum (List &lt; String &gt; valueList) {
            double sum = 0.0D;
            try {
                for (String value : valueList) {
                    sum += Double.parseDouble(value);
                }
            } catch (NumberFormatException e) {
                return null;
            }
            return sum;
        }
</code></pre>
<h3 id="-27"></h3>
<h3 id="83禁止使用异常控制业务流程"><strong>8.3.禁止使用异常控制业务流程</strong></h3>
<p>相对于条件表达式，异常的处理效率更低。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public static boolean isValid (UserDO user){
            try {
                return Boolean.TRUE.equals(user.getIsValid());
            } catch (NullPointerException e) {
                return false;
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        public static boolean isValid (UserDO user){
            if (Objects.isNull(user)) {
                return false;
            }
            return Boolean.TRUE.equals(user.getIsValid());
        }
</code></pre>
<h2 id="-28"></h2>
<h2 id="9缓冲区"><strong>9.缓冲区</strong></h2>
<h3 id="91初始化时尽量指定缓冲区大小"><strong>9.1.初始化时尽量指定缓冲区大小</strong></h3>
<p>初始化时，指定缓冲区的预期容量大小，避免多次扩容浪费时间和空间。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer();
StringBuilder builder = new StringBuilder();
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer(1024);
StringBuilder builder = new StringBuilder(1024);
</code></pre>
<h3 id="-29"></h3>
<h3 id="92尽量重复使用同一缓冲区"><strong>9.2.尽量重复使用同一缓冲区</strong></h3>
<p>针对缓冲区，Java虚拟机需要花时间生成对象，还要花时间进行垃圾回收处理。所以，尽量重复利用缓冲区。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        StringBuilder builder1 = new StringBuilder(128);
        builder1.append(&quot;update t_user set name = '&quot;).append(userName).append(&quot;' where id = &quot;).append(userId);
        statement.executeUpdate(builder1.toString());
        StringBuilder builder2 = new StringBuilder(128);
        builder2.append(&quot;select id, name from t_user where id = &quot;).append(userId);
        ResultSet resultSet = statement.executeQuery(builder2.toString());...
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        StringBuilder builder = new StringBuilder(128);
        builder.append(&quot;update t_user set name = '&quot;).append(userName).append(&quot;' where id = &quot;).append(userId);
        statement.executeUpdate(builder.toString());
        builder.setLength(0);
        builder.append(&quot;select id, name from t_user where id = &quot;).append(userId);
        ResultSet resultSet = statement.executeQuery(builder.toString());...
</code></pre>
<p>其中，使用setLength方法让缓冲区重新从0开始。</p>
<h3 id="93尽量设计使用同一缓冲区"><strong>9.3.尽量设计使用同一缓冲区</strong></h3>
<p>为了提高程序运行效率，在设计上尽量使用同一缓冲区。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        // 转化XML(UserDO)
         public static String toXml (UserDO user){
            StringBuilder builder = new StringBuilder(128);
            builder.append(&quot;&lt;UserDO&gt;&quot;);
            builder.append(toXml(user.getId()));
            builder.append(toXml(user.getName()));
            builder.append(toXml(user.getRole()));
            builder.append(&quot;&lt;/UserDO&gt;&quot;);
            return builder.toString();
        }
        // 转化XML(Long)
        public static String toXml (Long value){
            StringBuilder builder = new StringBuilder(128);
            builder.append(&quot;&lt;Long&gt;&quot;);
            builder.append(value);
            builder.append(&quot;&lt;/Long&gt;&quot;);
            return builder.toString();
        }...
        // 使用代码
        UserDO user = ...;
        String xml = toXml(user);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">        // 转化XML(UserDO)
        public static void toXml (StringBuilder builder, UserDO user){
            builder.append(&quot;&lt;UserDO&gt;&quot;);
            toXml(builder, user.getId());
            toXml(builder, user.getName());
            toXml(builder, user.getRole());
            builder.append(&quot;&lt;/UserDO&gt;&quot;);
        }
        // 转化XML(Long)
        public static void toXml (StringBuilder builder, Long value){
            builder.append(&quot;&lt;Long&gt;&quot;);
            builder.append(value);
            builder.append(&quot;&lt;/Long&gt;&quot;);
        }...
        // 使用代码
        UserDO user = ...;
        StringBuilder builder = new StringBuilder(1024);
        toXml(builder, user);
        String xml = builder.toString();
</code></pre>
<p>去掉每个转化方法中的缓冲区申请，申请一个缓冲区给每个转化方法使用。从时间上来说，节约了大量缓冲区的申请释放时间；从空间上来说，节约了大量缓冲区的临时存储空间。</p>
<h3 id="94尽量使用缓冲流减少io操作"><strong>9.4.尽量使用缓冲流减少IO操作</strong></h3>
<p>使用缓冲流BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream等，可以大幅较少IO次数并提升IO速度。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        try (FileInputStream input = new FileInputStream(&quot;a&quot;); FileOutputStream output = new FileOutputStream(&quot;b&quot;)) {
            int size = 0;
            byte[] temp = new byte[1024];
            while ((size = input.read(temp)) != -1) {
                output.write(temp, 0, size);
            }
        } catch (IOException e) {
            log.error(&quot;复制文件异常&quot;, e);
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-javascript">        try (BufferedInputStream input = new BufferedInputStream(new FileInputStream(&quot;a&quot;)); BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(&quot;b&quot;))) {
            int size = 0;
            byte[] temp = new byte[1024];
            while ((size = input.read(temp)) != -1) {
                output.write(temp, 0, size);
            }
        } catch (IOException e) {
            log.error(&quot;复制文件异常&quot;, e);
        }
</code></pre>
<p>其中，可以根据实际情况手动指定缓冲流的大小，把缓冲流的缓冲作用发挥到最大。</p>
<h2 id="10线程"><strong>10.线程</strong></h2>
<h3 id="101在单线程中尽量使用非线程安全类"><strong>10.1.在单线程中，尽量使用非线程安全类</strong></h3>
<p>使用非线程安全类，避免了不必要的同步开销。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">StringBuffer buffer = new StringBuffer(128);
buffer.append(&quot;select * from &quot;).append(T_USER).append(&quot; where id = ?&quot;);
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">StringBuilder buffer = new StringBuilder(128);
buffer.append(&quot;select * from &quot;).append(T_USER).append(&quot; where id = ?&quot;);
</code></pre>
<h3 id="-30"></h3>
<h3 id="102在多线程中尽量使用线程安全类"><strong>10.2.在多线程中，尽量使用线程安全类</strong></h3>
<p>使用线程安全类，比自己实现的同步代码更简洁更高效。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">				private volatile int counter = 0;
        public void access (Long userId){
            synchronized (this) {
                counter++;
            }    ...}
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">private final AtomicInteger counter = new AtomicInteger(0);
        public void access (Long userId){
            counter.incrementAndGet();    ...}
</code></pre>
<h3 id="-31"></h3>
<h3 id="103尽量减少同步代码块范围"><strong>10.3.尽量减少同步代码块范围</strong></h3>
<p>在一个方法中，可能只有一小部分的逻辑是需要同步控制的，如果同步控制了整个方法会影响执行效率。所以，尽量减少同步代码块的范围，只对需要进行同步的代码进行同步。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">  		  private volatile int counter = 0;
        public synchronized void access (Long userId){
            counter++;    ... // 非同步操作
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">				private volatile int counter = 0;
        public void access (Long userId){
            synchronized (this) {
                counter++;
            }    ... // 非同步操作}
</code></pre>
<h3 id="-32"></h3>
<h3 id="104尽量合并为同一同步代码块"><strong>10.4.尽量合并为同一同步代码块</strong></h3>
<p>同步代码块是有性能开销的，如果确定可以合并为同一同步代码块，就应该尽量合并为同一同步代码块。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">				// 处理单一订单
        public synchronized handleOrder(OrderDO order) {    ...}
        // 处理所有订单
        public void handleOrder (List &lt; OrderDO &gt; orderList) {
            for (OrderDO order : orderList) {
                handleOrder(order);
            }
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java"> 				 // 处理单一订单
         public handleOrder(OrderDO order) {    ...}
        // 处理所有订单
        public synchronized void handleOrder (List &lt; OrderDO &gt; orderList) {
            for (OrderDO order : orderList) {
                handleOrder(order);
            }
        }
</code></pre>
<h3 id="-33"></h3>
<h3 id="105尽量使用线程池减少线程开销"><strong>10.5.尽量使用线程池减少线程开销</strong></h3>
<p>多线程中两个必要的开销：线程的创建和上下文切换。采用线程池，可以尽量地避免这些开销。</p>
<p><strong>反例：</strong></p>
<pre><code class="language-java">        public void executeTask (Runnable runnable){
            new Thread(runnable).start();
        }
</code></pre>
<p><strong>正例：</strong></p>
<pre><code class="language-java">private static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(10);
        public void executeTask (Runnable runnable){
            executorService.execute(runnable);
        }
</code></pre>
<h2 id="-34"></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一次长途自驾呀]]></title>
        <id>https://HelloJackGao.github.io/post/travel0911/</id>
        <link href="https://HelloJackGao.github.io/post/travel0911/">
        </link>
        <updated>2020-10-17T14:52:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="青甘大环线七日攻略总结">青甘大环线七日攻略总结</h1>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giw2e1rqefj311c0s8dxr.jpg" alt="image-20200919165906897" loading="lazy"></figure>
<blockquote>
<p>主要是记录一下生活，怕老了忘记了这次旅行。之前出发前也是各种找攻略，但是没有一份很全的攻略，都是七零八落的，但是这次是自己亲身经历，抱着开源的思想，还是把坑坑洼洼的经历告诉大家，避免大家踩坑坑，好了，我们的旅途开始了。GOGOGO。我们是三人自驾游，三个单身狗。第一次自驾三千公里，突然发现有点猛，时间为20200911-20200919，一次不一样的旅行✈️✈️✈️。上面那张图是整个环线的大图，下面还有详细的小图的。</p>
</blockquote>
<h2 id="必备物品清单">必备物品清单</h2>
<blockquote>
<p>我们的组合比例是两男一女，三个死单身狗，并且妹子也不化妆，所以东西都是个人的东西，我们有两个人是24寸行李箱，另外一个精致男带了一个二十寸的小箱子，但是感觉自己带少了，我们带了内衣袜子啥的，之前在网上看攻略，要带一次性内裤，之后才发现确实要带，没得后悔药吃，因为那边好多店没空调，洗了衣服根本干不了，所以朋友都是拿吹风机死命的吹，可怜了宾馆的吹风机。有空调的宾馆，开热风，三十度，晚上都热醒了。所以emmmm，还是多带点衣服。具体看下面的清单🧾吧。</p>
</blockquote>
<h3 id="1-摄影篇">1、摄影篇</h3>
<p>首先有无人机一定要带无人机，因为好多景点都需要上帝视角来看才是最美的，有无人机可以拍出装逼的照片和视频。好多地方都需要无人机都拍的出来，什么恶魔之眼，水上雅丹等；其次，有相机就带相机，如果要拍星星✨，记得一定要带大光圈镜头，因为这边天黑了以后，银河星空都是肉眼可见那种，没带镜头，要哭了，貌似牛逼的华为也可以拍出星空来。但是专业的事情还是要专业的设备来拍。出色的手机也是很强的，还是要多拍拍，毕竟拍了才可以选，不拍肯定没得选，多拍，然后带上万能的墨镜摆pose，墨镜一戴，谁也不爱。哈哈哈哈。</p>
<h3 id="2-护肤篇">2、护肤篇</h3>
<p>这边及其干燥，必须带护肤品来，干到哭泣那种，玩个七天，感觉面容变得极其沧桑。防晒必须带过去，太阳太大了，及其大，紫外线及其强。是个妹子记得多带面膜，补补水，作为一个汉子都想带，后悔没带。</p>
<h3 id="3-衣服篇">3、衣服篇</h3>
<p>必备衣服啥的记得都带，轻薄羽绒服也是可以带的，因为早晚温度超级低。内衣内裤袜子啥的记得多带点，这边好多旅店没空调的，然后暖气也没开，导致洗了衣服根本干不了，一定要带墨镜🕶️，帽子🎩，面巾🎭，因为紫外线真的强了，光线可以照瞎狗眼🐶👀。记得带个拖鞋，因为宾馆的太脏了。枕头套记得带个。要好看，每天穿不一样的，肯定多带好看的衣服嘛，展现不一样的自己。</p>
<h3 id="4-食物篇">4、食物篇</h3>
<p>直接去超市买好几天的吃的东西就行，多买水果，多买喝的，因为及其干，多补充水份；多买些高热量的东西，因为经常是没有地方吃午饭和晚饭，因为一直在路上，emmmmm。</p>
<p>重要的事情说三遍，一定要带一个<strong>空气加湿器</strong>，**空气加湿器，空气加湿器，**一定记得，好点的酒店房间里有这个，大部分酒店是没这个的，买带USB那种，可以放在车上开着使用。</p>
<p><strong>墨镜墨镜墨镜，帽子帽子帽子，一定要带，可以遮阳，又可以当道具。</strong></p>
<h3 id="5-药物篇">5、药物篇</h3>
<p>这边没有高反，所以什么高原药就不要带了，可以带点感冒药啥的，肠胃不好带个肠炎宁来，可以带个指甲剪来，觉得在这边指甲长的特别快。</p>
<p>----------------------我是一条没有感情的分割线-----------------------</p>
<p>重要的事情说三遍，一定要带一个<strong>空气加湿器</strong>，**空气加湿器，空气加湿器，**一定记得，好点的酒店房间里有这个，大部分酒店是没这个的，买带USB那种，可以放在车上开着使用。</p>
<p><strong>墨镜墨镜墨镜，帽子帽子帽子，一定要带，可以遮阳，又可以当道具。</strong></p>
<p>----------------------我是一条没有感情的分割线-----------------------</p>
<h2 id="旅行路线">旅行路线</h2>
<blockquote>
<p>这个路线主要走的就是一个环线，全长2400公里，但是我们开了三千公里，emmm，估计是走了太多的弯路，我们是周五晚上飞机飞到西宁，然后在西宁租车，然后西宁过夜。所以西宁是起点也是终点🏁。网上类型的环线地图很多，给大家找了一个标准的。基本上都是这个，只是细节多少的原因，我们选择了租车，因为自由，但是也是有点累的，毕竟要天天开车；之前看攻略，也是可以包车的，也自由，但是这种地方还是需要方向盘掌握自己手上，包车应该会多花钱，毕竟带了一个专职司机，还是本地人，但是一般都是本地人坑游客的，哈哈哈哈，大家根据自己情况来。如果是自驾，那么你大可以放心开，这边路况真的很好，有的国道比高速路还好，而且就一段坑坑洼洼的路，其他的路都很好，在路上看到了很多轿车都跑这个路，比如20年前的Santana，还有车中之王--五菱宏光大哥，所以，兄弟别犹豫了，赶紧上路吧，车只是工具，主要是有一颗奔跑的心。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc6d72shj30lq0pqjvo.jpg" alt="IMG_2932" loading="lazy"></figure>
<p>因为我们来的那天，青海的天气不好，甘肃的天气很好，所以我们走的是青甘环线的反方向，我们先往甘肃走，然后在绕一个圈子到西宁，第一天住宿在西宁。</p>
<h3 id="1-day01">1、Day01</h3>
<blockquote>
<p>全长340KM，行程比较轻松(相对于后面的路程，真的好轻松)，到祁连山草原时海拔较高，弯道比较多，先是上山路段，然后就是下山路段，然后就是一直大直马路了，山路开车时需要注意。而且路边的厕所比较少，有公共厕所也是一元一次的收费厕所，注意不要喝太多水。</p>
</blockquote>
<p><strong>路线：西宁—黑泉水库—祁连山观景台—门源油菜花—祁连山大草原—张掖</strong></p>
<p>第一天还没有感受到西宁的干燥，因为下雨，房间有加湿器。第一天的行程比较慢，所以我们就去逛了一下超市，毕竟好多时间在车子上，所以买了好多的吃吃喝喝的，还有水果啥的，满满一大袋袋购物车🛒，自助的收银的发票都好长，如图。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4egzs7erj30u0268kjn.jpg" alt="IMG_3038" style="zoom:25%;" />
<p>购物完，我们就开始上路，第一天没找到吃早餐的地方，全靠早上买的东西，所以我们就慢慢开，然后往水库出发。在半路上，看到风景还不错，我们就下车拍了一些照片，还没有到水库。就瞎拍了几张照片，感受了一下大自然的美丽，确实没见过类似的场景。哈哈哈。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc6otl8rj31400u01ky.jpg" alt="IMG_1719" loading="lazy"></figure>
<p>路边的水emmmmm。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc70r7ikj31hc0u04qv.jpg" alt="DJI_0020-1" loading="lazy">然后就是一路上的赶路了，<strong>黑泉水库</strong>就是一个水库，我们直接开过去了，没停下来拍照。然后天气逐渐变好，我们就赶到了下一个<strong>景点祁连山观景台</strong>，这边俯瞰整个山下真的超级美，而且那天的天气也相当的好，不说🙊直接上图。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4faizrbsj31400u0kjq.jpg" alt="IMG_1722" loading="lazy"></figure>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtc7coydnj31400u07wo.jpg" alt="IMG_1744"  />
<p><em><strong>帮傻雕拍的照片。。。。。。</strong></em></p>
<p>这里就是观景台了，emmmm好多人，千万别买那边卖的玉米，超级老，那边停车收费五块钱，有厕所哟。</p>
<p>然后就开始下山路了，门源我们没去，因为是江西人，看多了油菜花，没去有点后悔，看了别人的照片发现别人家的油菜花还是香的。然后我们就直奔大草原了。路上看到肉眼可见的雪山，妈呀第一次看见雪山，有点激动。天真蓝呀。</p>
<p><strong>远眺岗什卡雪峰</strong></p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4fn2pnnvj31400u0x6t.jpg" alt="IMG_1749"  />
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4ftspt82j31400u0x6r.jpg" alt="IMG_1754" loading="lazy"></figure>
<p>然后就是一路上开开开了，这227真的是最美国道(接下来会打脸的)。</p>
<p>不知道哪个山头。。。。。</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjspnao9caj31hc0u0qv8.jpg" alt="DJI_0032-1" loading="lazy"></figure>
<p>一路祁连草原连片，牛羊成群。经过扁都峡，后面就没拍照了，一直在赶路。路上到达张掖。</p>
<p>第一天，早上没吃，中午吃了一碗牛肉面。晚上在张掖吃了饭。去了是张掖最有名小吃店，emmmmm别去，好难吃。太油腻了，吃不下。别轻易尝试，一尝试就失败。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjspoxw1aij31400u07wo.jpg" alt="IMG_1773" loading="lazy"></figure>
<p><strong>今天一天的三人开支如下：</strong></p>
<p><strong>超市零食608 、过路费 38 、午饭 41、意外险 27、加油 130、住宿 190、晚饭 176</strong></p>
<h3 id="2-day-02">2、day 02</h3>
<blockquote>
<p>今天的行程是张掖一日游，然后赶路去敦煌市。今天的行程大概600+公里，感觉开了一路上的车子。张掖的丹霞地貌值得一看，尤其是第二个站最高点看的地貌非常的震撼，值得爬上去一看。</p>
</blockquote>
<p>张掖 — 丹霞地貌 — 嘉峪关市 — 敦煌</p>
<p>张掖七彩丹霞 卓尔山 牛心山早餐后前往张掖七彩丹霞，张掖七彩丹霞地貌奇观形成于600万年前，位于张掖市临泽、肃南县境内，这里是国内唯一的丹霞地貌与色彩能丘陵景观复合区。这里也被«中国国家地理»杂志评为中国最美的七大丹霞地貌之一，景区内有多个观景台供大家进行游览、摄影。丹霞景区是张掖丹霞国家地质公园的重要组成部分，分为小西天景观区和大西天景观区。它是中国干旱地区最为典型的丹霞地貌，同时也是中国发育最完整，造型最为奇特的丹霞地貌之一。</p>
<p>day 03</p>
<p>敦煌 — 敦煌莫高窟 — 鸣沙山、月牙泉</p>
<p>莫高窟俗称千佛洞，坐落在河西走廊西端的敦煌。它始建于十六国的前秦时期，历经十六国：北朝、隋、唐、五代、西夏、元等历代的兴建，形成巨大的规模，有洞窟735个，壁画4.5万平方米、泥质彩塑2415尊，是世界上现存规模最大、内容最丰富的佛教艺术地。1961年，莫高窟被中华人民共和国国务院公布为第一批全国重点文物保护单位之一。1987年，莫高窟被列为世界文化遗产。莫高窟门票购买网址http://www.mgk.org.cn/index.htm，提前30天购买，7、8月份必须提前购买，否则只能到现场后买到应急票。</p>
<p>鸣沙山月牙泉风景名胜区，1994年被定为国家重点风景名胜区，荣获“中国最美的五大沙漠之一”等荣誉称号。2015年7月20日，被批准为国家AAAAA级旅游景区。2016年1月，国家旅游局和环保部拟认定甘肃省酒泉市鸣沙山月牙泉景区为国家生态旅游示范区。</p>
<p>门票：莫高窟 200（淡季 100）；鸣沙山月牙泉 110 骆驼100</p>
<p>Day04</p>
<p>敦煌 — 阳关 — 阿克塞 — 石油小镇 — 冷湖镇 — 大柴旦</p>
<p>Day1:西宁-张掖--丹霞口旅游小镇--七彩丹霞--嘉峪关</p>
<p>Day3：嘉峪关城楼--敦煌--鸣沙山、月亮泉--敦煌</p>
<p>Day4：敦煌--莫高窟--石油小镇--大柴旦/德令哈</p>
<p>Day5：大柴旦/德令哈--可鲁克湖--茶卡盐湖--茶卡镇/共和</p>
<p>Day6：茶卡/共和--青海湖--青海湖边油菜花田--藏族民俗村--西宁</p>
<p>Day7：西宁--互助彩虹部落--塔尔寺</p>
<p>塔尔寺位于青海省西宁市湟中县鲁沙尔镇西南隅的莲花山坳中。塔尔寺院依山势建筑，由众多殿宇、经堂、佛塔、僧舍等组成，布局严谨，建筑巍峨，金碧辉煌，气势恢宏，是我国著名的藏传佛教格鲁派六大寺院之一。塔尔寺是青海省佛学院的最高学府，现设有显宗、密宗、时轮、医明四大学院（经院），藏语分别称为参尼、居巴、丁科、曼巴ce札仓。</p>
<p>二郎剑景区位于深入<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>中的特殊地理位置，以草原、沙滩、动植物为主的生态自然资源，以民间文化活动为内容，成为<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>旅游区一颗耀眼的明珠。目前，已经建成了以观鸟台、观鹿园、观海桥、观海亭为组合的观赏区，以码头广场、吉祥四瑞雕塑为组合的休闲区、以水上摩托、自驾游艇为活动内容的水上娱乐区，可以近距离接触到<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>。</p>
<p>黑马河位于西宁以西约220公里处的<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>边，是<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10799.html">青海湖</a>环湖公路的起点，由此沿环湖公路走70公里可达著名的鸟岛，黑马河往鸟岛方向这一段，又被称为环湖西路，不少&quot;暴走族&quot;驴友或自行车迷，都选择从黑马河开始他们的环湖梦幻之旅。</p>
<p>茶卡盐湖位于青海省海西蒙古族藏族自治州乌兰县茶卡镇附近，盐湖四周雪山环绕，纯净、蓝白、倒影交织，恍若一面天然明镜。因其旅游资源禀赋可与玻利维亚乌尤尼盐沼相媲美，享有中国&quot;天空之镜&quot;之美称，是&quot;青海四大景&quot;之一，是国家旅游地理杂志评选的&quot;人一生必去的55个地方&quot;之一。</p>
<p>第一天，西宁出发，塔尔寺，拉鸡山旅游公路，二郎剑151基地、到达黑马河，住黑马河。</p>
<p>第二天 黑马河看日出，茶卡盐湖、柴达木、德令哈、外星人遗址、翡翠湖,大柴旦住宿。</p>
<p>第三天 大柴旦出发，青海雅丹魔鬼城，阳关，敦煌古城，敦煌住宿，敦煌夜市。</p>
<p>第四天，莫高窟，鸣沙山，月牙泉，敦煌住宿。</p>
<p>第五天 敦煌出发，嘉峪关城楼、七彩丹霞到达张掖。</p>
<p>第六天  张掖出发，扁都口风景旅游区、祁连山大草原、阿柔大寺、祁连卓尔山风景区，住祁连。</p>
<p>第七天，祁连出发，岗卡什雪峰，门源，黑泉水库，到达西宁</p>
<p>Day1：西宁-青海湖-茶卡盐湖-德令哈</p>
<p>Day2：翡翠湖-U型公路-东台-水上雅丹</p>
<p>Day3：西台吉乃尔湖-火星一号公路-火星营地</p>
<p>Day4：恶魔之眼-冷湖-石油小镇 阿克塞老县城</p>
<p>Day5：敦煌莫高窟-鸣沙山-月牙泉</p>
<p>Day6：敦煌-嘉峪关-张掖七彩丹霞</p>
<p>Day7：张掖-门源-祁连大草原-西宁</p>
<p>􏲮􏲯􏰚􏱰􏳖􏴘􏷺􏷻􏷦􏳜􏳝􏳞􏱫􏳌􏶉􏷼􏳑􏷽􏱉􏱊􏱋􏱫􏱉􏱊􏱋􏷾􏷿􏱦 西宁*—30km—<em>塔尔寺</em>—120km—<em>青海湖畔</em>—80km—*黑马河，夜宿黑马河。</p>
<p>早晨 8 点左右出发即可，塔尔寺游玩时间一般在 2 小时，然后驱车前往青海湖，一路边走边玩，经过日月山，到达青海湖南岸。在青海湖边，近距离体验湖水。然后到达黑马河边住宿休息，还能再次去青海湖边，继续欣赏。门票：塔尔寺 80 元；日月山 40 元；青海湖二郎剑 100 元；青海湖进入牧民家 20 元左右；</p>
<p>主要看点：藏传佛教塔尔寺、高原蓝宝石青海湖、青海湖星空。</p>
<p>黑马河*—80km—<em>茶卡盐湖</em>—220km—<em>德令哈</em>—240km—*大柴旦镇；</p>
<p>从茶卡盐湖出来后，就向德令哈方向去。德令哈有可鲁克湖、托素湖、外星人遗址，都是路过即可，没必要买票进入。经过德令哈后一路直奔大柴旦，这个小镇子，每年夏季每天有近 1 万人入住。</p>
<p>门票：茶卡盐湖 70；可鲁克湖 20</p>
<p>主要看点：黑马河日出、茶卡盐湖、戈壁公路</p>
<p>大柴旦*—20km—<em>柴达木盆地公路</em>—200km—<em>青海冷湖雅丹</em>—40km—<em>阿克塞</em>—64km—<em>阳关遗址</em>—63km—<em>敦煌市（或是大柴旦</em>—20km—<em>柴达木盆地公路</em>—240km—<em>阿克塞</em>—122km—<em>玉门关</em>—60km—<em>敦煌雅丹魔鬼城</em>—170km—*敦煌市）；</p>
<p>这两个走法的主要差别在于——雅丹，你是走青海的冷湖雅丹，还是走敦煌的雅丹。两处雅丹各有优劣，目前来说大环线多数都是走青海雅丹。原因有三：无需门票，可以随便进入；亚洲规模最大；路程轻松些。敦煌雅丹进入是捆绑玉门关的门票。敦煌雅丹气势更凌人，但玉门关若不是几句诗词，确是有些不尽人意的。</p>
<p>从大柴旦镇出来后，就是在柴达木盆地的外侧了，公路笔直的延伸在戈壁滩上，雅丹地貌排列在路的两边。到达冷湖后，青海的雅丹地貌群尽显，壮观威严。到 “西出阳关无故人” 的阳关后，再一赏古人面对戈壁的无限苍凉。然后入住敦煌，尽享繁华。</p>
<p>门票：青海雅丹魔鬼城免费，阳关遗址 60，玉门关 40</p>
<p>主要看点：青海雅丹、柴达木盆地公路片、阳关</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HELLO WORLD]]></title>
        <id>https://HelloJackGao.github.io/post/number1/</id>
        <link href="https://HelloJackGao.github.io/post/number1/">
        </link>
        <updated>2020-01-19T13:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>记录自己的学习和生活呀。</p>
]]></content>
    </entry>
</feed>